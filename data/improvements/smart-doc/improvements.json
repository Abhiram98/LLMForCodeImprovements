[
    {
        "Method_Improvements": [{
            "details": "Expected a ',' or '}' at 2098 [character 115 line 25]",
            "error": "An unexpected error occurred"
        }],
        "Old_Method": "default List<ApiReqParam> handle(JavaMethod method,ProjectDocConfigBuilder projectBuilder){\n  Map<String,String> constantsMap=projectBuilder.getConstantsMap();\n  List<ApiReqParam> mappingHeaders=new ArrayList<>();\n  List<JavaAnnotation> annotations=method.getAnnotations();\n  HeaderAnnotation headerAnnotation=getHeaderAnnotation();\n  for (  JavaAnnotation annotation : annotations) {\n    String annotationName=annotation.getType().getValue();\n    Object headersObject=annotation.getNamedParameter(\"headers\");\n    if (!isMapping(annotationName) || Objects.isNull(headersObject)) {\n      continue;\n    }\n    String mappingHeader=StringUtil.removeQuotes(headersObject.toString());\n    if (!mappingHeader.startsWith(\"[\")) {\n      processMappingHeaders(mappingHeader,mappingHeaders);\n      continue;\n    }\n    List<String> headers=(LinkedList)headersObject;\n    for (    String str : headers) {\n      String header=StringUtil.removeQuotes(str);\n      if (header.startsWith(\"!\")) {\n        continue;\n      }\n      processMappingHeaders(header,mappingHeaders);\n    }\n  }\n  List<ApiReqParam> reqHeaders=new ArrayList<>();\n  for (  JavaParameter javaParameter : method.getParameters()) {\n    List<JavaAnnotation> javaAnnotations=javaParameter.getAnnotations();\n    String className=method.getDeclaringClass().getCanonicalName();\n    Map<String,String> paramMap=DocUtil.getCommentsByTag(method,DocTags.PARAM,className);\n    String paramName=javaParameter.getName();\n    JavaType javaType=javaParameter.getType();\n    String simpleTypeName=javaType.getValue();\n    ApiReqParam apiReqHeader;\n    for (    JavaAnnotation annotation : javaAnnotations) {\n      String annotationName=annotation.getType().getValue();\n      if (headerAnnotation.getAnnotationName().equals(annotationName)) {\n        apiReqHeader=new ApiReqParam();\n        Map<String,Object> requestHeaderMap=annotation.getNamedParameterMap();\n        if (requestHeaderMap.get(headerAnnotation.getValueProp()) != null) {\n          String attrValue=DocUtil.handleRequestHeaderValue(annotation);\n          String constValue=((String)requestHeaderMap.get(headerAnnotation.getValueProp())).replaceAll(\"\\\"\",\"\");\n          if (StringUtil.isEmpty(attrValue)) {\n            Object value=constantsMap.get(constValue);\n            if (value != null) {\n              apiReqHeader.setName(value.toString());\n            }\n else {\n              apiReqHeader.setName(constValue);\n            }\n          }\n else {\n            apiReqHeader.setName(attrValue);\n          }\n        }\n else {\n          apiReqHeader.setName(paramName);\n        }\n        StringBuilder desc=new StringBuilder();\n        String comments=paramMap.get(paramName);\n        desc.append(DocUtil.paramCommentResolve(comments));\n        String mockValue=JavaFieldUtil.createMockValue(paramMap,paramName,javaType.getGenericCanonicalName(),simpleTypeName);\n        apiReqHeader.setValue(mockValue);\n        if (requestHeaderMap.get(headerAnnotation.getDefaultValueProp()) != null) {\n          apiReqHeader.setValue(StringUtil.removeQuotes((String)requestHeaderMap.get(headerAnnotation.getDefaultValueProp())));\n          desc.append(\"(defaultValue: \").append(StringUtil.removeQuotes((String)requestHeaderMap.get(headerAnnotation.getDefaultValueProp()))).append(\")\");\n        }\n        apiReqHeader.setDesc(desc.toString());\n        if (requestHeaderMap.get(headerAnnotation.getRequiredProp()) != null) {\n          apiReqHeader.setRequired(!Boolean.FALSE.toString().equals(requestHeaderMap.get(headerAnnotation.getRequiredProp())));\n        }\n else {\n          apiReqHeader.setRequired(true);\n        }\n        String typeName=javaParameter.getType().getValue().toLowerCase();\n        apiReqHeader.setType(DocClassUtil.processTypeNameForParams(typeName));\n        reqHeaders.add(apiReqHeader);\n        break;\n      }\n    }\n  }\n  return Stream.of(mappingHeaders,reqHeaders).flatMap(Collection::stream).distinct().collect(Collectors.toList());\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/handler/IHeaderHandler.java",
        "Start": 1705,
        "Stop": 6751,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "handle"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Remove unnecessary import statements",
                    "Change_Diff": "- import java.util.*;\n+ import java.util.LinkedHashMap;\n...",
                    "Description": "Replace the wildcard import statement with specific import statements to improve code readability and reduce the chance of naming conflicts.",
                    "Start": 3,
                    "End": 4
                },
                {
                    "Improvement": "Use streams and lambda expressions for list processing",
                    "Change_Diff": "- for (int i = 0; i < arr.length; i++) {\n-     sum += arr[i];\n- }\n+ int sum = Arrays.stream(arr).sum();",
                    "Description": "Replace the traditional for loop with streams and lambda expressions to simplify the code and improve readability.",
                    "Start": 6,
                    "End": 8
                },
                {
                    "Improvement": "Refactor code to improve readability",
                    "Change_Diff": "- List<String> mvcRequestAnnotations=this.listMvcRequestAnnotations();\n+ List<String> mvcRequestAnnotations = this.listMvcRequestAnnotations();",
                    "Description": "Add spaces around the equals sign for better code readability.",
                    "Start": 196,
                    "End": 196
                }
            ],
            "Final code": "default ApiRequestExample buildReqJson(DocJavaMethod javaMethod, ApiMethodDoc apiMethodDoc, String methodType, ProjectDocConfigBuilder configBuilder, FrameworkAnnotations frameworkAnnotations) { \n    JavaMethod method = javaMethod.getJavaMethod();\n    Map<String, String> pathParamsMap = new LinkedHashMap<>();\n    Map<String, String> queryParamsMap = new LinkedHashMap<>();\n    ...\n    ...\n    ...\n    return requestExample;\n}"
        }],
        "Old_Method": "default ApiRequestExample buildReqJson(DocJavaMethod javaMethod,ApiMethodDoc apiMethodDoc,String methodType,ProjectDocConfigBuilder configBuilder,FrameworkAnnotations frameworkAnnotations){\n  JavaMethod method=javaMethod.getJavaMethod();\n  Map<String,String> pathParamsMap=new LinkedHashMap<>();\n  Map<String,String> queryParamsMap=new LinkedHashMap<>();\n  apiMethodDoc.getPathParams().stream().filter(Objects::nonNull).filter(p -> StringUtil.isNotEmpty(p.getValue()) || p.isConfigParam()).forEach(param -> pathParamsMap.put(param.getSourceField(),param.getValue()));\n  apiMethodDoc.getQueryParams().stream().filter(Objects::nonNull).filter(p -> StringUtil.isNotEmpty(p.getValue()) || p.isConfigParam()).forEach(param -> queryParamsMap.put(param.getSourceField(),param.getValue()));\n  List<JavaAnnotation> methodAnnotations=method.getAnnotations();\n  Map<String,MappingAnnotation> mappingAnnotationMap=frameworkAnnotations.getMappingAnnotations();\n  for (  JavaAnnotation annotation : methodAnnotations) {\n    String annotationName=annotation.getType().getName();\n    MappingAnnotation mappingAnnotation=mappingAnnotationMap.get(annotationName);\n    if (Objects.nonNull(mappingAnnotation) && StringUtil.isNotEmpty(mappingAnnotation.getParamsProp())) {\n      Object paramsObjects=annotation.getNamedParameter(mappingAnnotation.getParamsProp());\n      if (Objects.isNull(paramsObjects)) {\n        continue;\n      }\n      String params=StringUtil.removeQuotes(paramsObjects.toString());\n      if (!params.startsWith(\"[\")) {\n        mappingParamProcess(paramsObjects.toString(),queryParamsMap);\n        continue;\n      }\n      List<String> headers=(LinkedList)paramsObjects;\n      for (      String str : headers) {\n        mappingParamProcess(str,queryParamsMap);\n      }\n    }\n  }\n  List<DocJavaParameter> parameterList=getJavaParameterList(configBuilder,javaMethod,frameworkAnnotations);\n  List<ApiReqParam> reqHeaderList=apiMethodDoc.getRequestHeaders();\n  if (parameterList.size() < 1) {\n    String path=apiMethodDoc.getPath().split(\";\")[0];\n    path=DocUtil.formatAndRemove(path,pathParamsMap);\n    String url=UrlUtil.urlJoin(path,queryParamsMap);\n    url=StringUtil.removeQuotes(url);\n    url=apiMethodDoc.getServerUrl() + \"/\" + url;\n    url=UrlUtil.simplifyUrl(url);\n    CurlRequest curlRequest=CurlRequest.builder().setContentType(apiMethodDoc.getContentType()).setType(methodType).setReqHeaders(reqHeaderList).setUrl(url);\n    String format=CurlUtil.toCurl(curlRequest);\n    return ApiRequestExample.builder().setUrl(apiMethodDoc.getUrl()).setExampleBody(format);\n  }\n  boolean requestFieldToUnderline=configBuilder.getApiConfig().isRequestFieldToUnderline();\n  Map<String,String> paramsComments=DocUtil.getCommentsByTag(method,DocTags.PARAM,null);\n  List<String> mvcRequestAnnotations=this.listMvcRequestAnnotations();\n  List<FormData> formDataList=new ArrayList<>();\n  ApiRequestExample requestExample=ApiRequestExample.builder();\n  out:   for (  DocJavaParameter apiParameter : parameterList) {\n    JavaParameter parameter=apiParameter.getJavaParameter();\n    String paramName=parameter.getName();\n    String typeName=apiParameter.getFullyQualifiedName();\n    String gicTypeName=apiParameter.getGenericCanonicalName();\n    String simpleTypeName=apiParameter.getTypeValue();\n    JavaClass javaClass=configBuilder.getJavaProjectBuilder().getClassByName(typeName);\n    String[] globGicName=DocClassUtil.getSimpleGicName(gicTypeName);\n    String comment=this.paramCommentResolve(paramsComments.get(paramName));\n    String mockValue=JavaFieldUtil.createMockValue(paramsComments,paramName,gicTypeName,simpleTypeName);\n    if (queryParamsMap.containsKey(paramName)) {\n      mockValue=queryParamsMap.get(paramName);\n    }\n    if (requestFieldToUnderline) {\n      paramName=StringUtil.camelToUnderline(paramName);\n    }\n    List<JavaAnnotation> annotations=parameter.getAnnotations();\n    Set<String> groupClasses=JavaClassUtil.getParamGroupJavaClass(annotations,configBuilder.getJavaProjectBuilder());\n    boolean paramAdded=false;\n    boolean requestParam=false;\n    for (    JavaAnnotation annotation : annotations) {\n      String annotationName=annotation.getType().getValue();\n      String fullName=annotation.getType().getSimpleName();\n      if (!mvcRequestAnnotations.contains(fullName) || paramAdded) {\n        continue;\n      }\n      if (ignoreMvcParamWithAnnotation(annotationName)) {\n        continue out;\n      }\n      AnnotationValue annotationDefaultVal=annotation.getProperty(DocAnnotationConstants.DEFAULT_VALUE_PROP);\n      if (Objects.nonNull(annotationDefaultVal)) {\n        mockValue=DocUtil.resolveAnnotationValue(annotationDefaultVal);\n      }\n      paramName=getParamName(paramName,annotation);\n      if (frameworkAnnotations.getRequestBodyAnnotation().getAnnotationName().equals(annotationName)) {\n        if (apiMethodDoc.getContentType().equals(DocGlobalConstants.URL_CONTENT_TYPE)) {\n          apiMethodDoc.setContentType(JSON_CONTENT_TYPE);\n        }\n        boolean isArrayOrCollection=false;\n        if (JavaClassValidateUtil.isArray(typeName) || JavaClassValidateUtil.isCollection(typeName)) {\n          simpleTypeName=globGicName[0];\n          isArrayOrCollection=true;\n        }\n        if (JavaClassValidateUtil.isPrimitive(simpleTypeName)) {\n          if (isArrayOrCollection) {\n            if (StringUtil.isNotEmpty(mockValue)) {\n              mockValue=\"[\" + mockValue + \"]\";\n            }\n else {\n              mockValue=\"[\" + DocUtil.getValByTypeAndFieldName(simpleTypeName,paramName) + \"]\";\n            }\n            mockValue=JsonUtil.toPrettyFormat(mockValue);\n          }\n          requestExample.setJsonBody(mockValue).setJson(true);\n        }\n else {\n          String json=JsonBuildHelper.buildJson(typeName,gicTypeName,Boolean.FALSE,0,new HashMap<>(),groupClasses,configBuilder);\n          requestExample.setJsonBody(JsonUtil.toPrettyFormat(json)).setJson(true);\n        }\n        queryParamsMap.remove(paramName);\n        paramAdded=true;\n      }\n else       if (frameworkAnnotations.getPathVariableAnnotation().getAnnotationName().contains(annotationName)) {\n        if (javaClass.isEnum()) {\n          Object value=JavaClassUtil.getEnumValue(javaClass,Boolean.TRUE);\n          mockValue=StringUtil.removeQuotes(String.valueOf(value));\n        }\n        if (pathParamsMap.containsKey(paramName)) {\n          mockValue=pathParamsMap.get(paramName);\n        }\n        pathParamsMap.put(paramName,mockValue);\n        paramAdded=true;\n      }\n else       if (frameworkAnnotations.getRequestParamAnnotation().getAnnotationName().contains(annotationName)) {\n        if (javaClass.isEnum()) {\n          Object value=JavaClassUtil.getEnumValue(javaClass,Boolean.TRUE);\n          mockValue=StringUtil.removeQuotes(String.valueOf(value));\n        }\n        if (queryParamsMap.containsKey(paramName)) {\n          mockValue=queryParamsMap.get(paramName);\n        }\n        if (JavaClassValidateUtil.isPrimitive(simpleTypeName)) {\n          requestExample.addJsonBody(mockValue);\n        }\n        if (JavaClassValidateUtil.isFile(typeName)) {\n          break;\n        }\n        queryParamsMap.put(paramName,mockValue);\n        requestParam=true;\n        paramAdded=true;\n      }\n    }\n    if (paramAdded) {\n      continue;\n    }\n    if (JavaClassValidateUtil.isFile(gicTypeName)) {\n      apiMethodDoc.setContentType(FILE_CONTENT_TYPE);\n      FormData formData=new FormData();\n      formData.setKey(paramName);\n      formData.setType(\"file\");\n      if (typeName.contains(\"[]\") || typeName.endsWith(\">\")) {\n        comment=comment + \"(array of file)\";\n        formData.setType(DocGlobalConstants.PARAM_TYPE_FILE);\n        formData.setHasItems(true);\n      }\n      formData.setDescription(comment);\n      formData.setValue(mockValue);\n      formData.setSrc(new ArrayList(0));\n      formDataList.add(formData);\n    }\n else     if (JavaClassValidateUtil.isPrimitive(typeName) && !requestParam) {\n      FormData formData=new FormData();\n      formData.setKey(paramName);\n      formData.setDescription(comment);\n      formData.setType(\"text\");\n      formData.setValue(mockValue);\n      formDataList.add(formData);\n    }\n else     if (JavaClassValidateUtil.isArray(typeName) || JavaClassValidateUtil.isCollection(typeName)) {\n      String gicName=globGicName[0];\n      if (JavaClassValidateUtil.isArray(gicName)) {\n        gicName=gicName.substring(0,gicName.indexOf(\"[\"));\n      }\n      if (!JavaClassValidateUtil.isPrimitive(gicName) && !configBuilder.getJavaProjectBuilder().getClassByName(gicName).isEnum()) {\n        throw new RuntimeException(\"can't support binding Collection on method \" + method.getName() + \" Check it in \"+ method.getDeclaringClass().getCanonicalName());\n      }\n      String value;\n      JavaClass javaClass1=configBuilder.getClassByName(gicName);\n      if (Objects.nonNull(javaClass1) && javaClass1.isEnum()) {\n        value=String.valueOf(JavaClassUtil.getEnumValue(javaClass1,Boolean.TRUE));\n      }\n else {\n        value=RandomUtil.randomValueByType(gicName);\n      }\n      FormData formData=new FormData();\n      formData.setKey(paramName);\n      if (!paramName.contains(\"[]\")) {\n        formData.setKey(paramName + \"[]\");\n      }\n      formData.setDescription(comment);\n      formData.setType(\"text\");\n      formData.setValue(value);\n      formDataList.add(formData);\n    }\n else     if (javaClass.isEnum()) {\n      Object value=JavaClassUtil.getEnumValue(javaClass,Boolean.TRUE);\n      String strVal=StringUtil.removeQuotes(String.valueOf(value));\n      FormData formData=new FormData();\n      formData.setKey(paramName);\n      formData.setType(\"text\");\n      formData.setDescription(comment);\n      formData.setValue(strVal);\n      formDataList.add(formData);\n    }\n else {\n      formDataList.addAll(FormDataBuildHelper.getFormData(gicTypeName,new HashMap<>(),0,configBuilder,DocGlobalConstants.EMPTY));\n    }\n  }\n  boolean hasFormDataUploadFile=formDataList.stream().anyMatch(form -> Objects.equals(form.getType(),DocGlobalConstants.PARAM_TYPE_FILE));\n  Map<Boolean,List<FormData>> formDataGroupMap=formDataList.stream().collect(Collectors.groupingBy(e -> Objects.equals(e.getType(),DocGlobalConstants.PARAM_TYPE_FILE)));\n  List<FormData> fileFormDataList=formDataGroupMap.getOrDefault(Boolean.TRUE,new ArrayList<>());\n  if (hasFormDataUploadFile) {\n    apiMethodDoc.setContentType(FILE_CONTENT_TYPE);\n  }\n  requestExample.setFormDataList(formDataList);\n  String[] paths=apiMethodDoc.getPath().split(\";\");\n  String path=paths[0];\n  String body;\n  String exampleBody;\n  String url;\n  final Map<String,String> formDataToMap=DocUtil.formDataToMap(formDataList);\n  queryParamsMap.putAll(formDataToMap);\n  if (Methods.POST.getValue().equals(methodType) || Methods.PUT.getValue().equals(methodType)) {\n    path=DocUtil.formatAndRemove(path,pathParamsMap);\n    body=UrlUtil.urlJoin(DocGlobalConstants.EMPTY,queryParamsMap).replace(\"?\",DocGlobalConstants.EMPTY);\n    url=apiMethodDoc.getServerUrl() + \"/\" + path;\n    url=UrlUtil.simplifyUrl(url);\n    if (requestExample.isJson()) {\n      if (StringUtil.isNotEmpty(body)) {\n        url=url + \"?\" + body;\n      }\n      CurlRequest curlRequest=CurlRequest.builder().setBody(requestExample.getJsonBody()).setContentType(apiMethodDoc.getContentType()).setType(methodType).setReqHeaders(reqHeaderList).setUrl(url);\n      exampleBody=CurlUtil.toCurl(curlRequest);\n    }\n else {\n      CurlRequest curlRequest;\n      if (StringUtil.isNotEmpty(body)) {\n        curlRequest=CurlRequest.builder().setBody(body).setContentType(apiMethodDoc.getContentType()).setFileFormDataList(fileFormDataList).setType(methodType).setReqHeaders(reqHeaderList).setUrl(url);\n      }\n else {\n        curlRequest=CurlRequest.builder().setBody(requestExample.getJsonBody()).setContentType(apiMethodDoc.getContentType()).setFileFormDataList(fileFormDataList).setType(methodType).setReqHeaders(reqHeaderList).setUrl(url);\n      }\n      exampleBody=CurlUtil.toCurl(curlRequest);\n    }\n    requestExample.setExampleBody(exampleBody).setUrl(url);\n  }\n else {\n    url=formatRequestUrl(pathParamsMap,queryParamsMap,apiMethodDoc.getServerUrl(),path);\n    CurlRequest curlRequest=CurlRequest.builder().setBody(requestExample.getJsonBody()).setContentType(apiMethodDoc.getContentType()).setType(methodType).setReqHeaders(reqHeaderList).setUrl(url);\n    exampleBody=CurlUtil.toCurl(curlRequest);\n    requestExample.setExampleBody(exampleBody).setJsonBody(requestExample.isJson() ? requestExample.getJsonBody() : DocGlobalConstants.EMPTY).setUrl(url);\n  }\n  return requestExample;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/IRestDocTemplate.java",
        "Start": 41306,
        "Stop": 57596,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "buildReqJson"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Replace lambda expression with method reference",
                    "Change_Diff": "- apiDocList.forEach(doc -> {",
                    "Description": "Replace the lambda expression with a method reference for better readability and code simplicity.",
                    "Start": 8,
                    "End": 8
                },
                {
                    "Improvement": "Use isEmpty() method instead of ArrayUtils.isEmpty()",
                    "Change_Diff": "- if (ArrayUtils.isEmpty(tags)) {",
                    "Description": "Replace the ArrayUtils.isEmpty() method with the isEmpty() method of the CollectionUtil class for consistency and code clarity.",
                    "Start": 24,
                    "End": 24
                },
                {
                    "Improvement": "Simplify method chaining in computeIfPresent() calls",
                    "Change_Diff": "- copyMap.computeIfPresent(tag,(k,v) -> {",
                    "Description": "Simplify the code by removing unnecessary parentheses and explicitly specifying the return statement.",
                    "Start": 31,
                    "End": 31
                },
                {
                    "Improvement": "Use method reference instead of lambda expression in computeIfPresent() calls",
                    "Change_Diff": "- copyMap.computeIfPresent(tag,(k1,v2) -> {",
                    "Description": "Replace the lambda expression with a method reference for better readability and code simplicity.",
                    "Start": 53,
                    "End": 53
                },
                {
                    "Improvement": "Replace for-each loop with forEach() method",
                    "Change_Diff": "- methodDocList.forEach(method -> {",
                    "Description": "Replace the for-each loop with the forEach() method of the List interface for cleaner and more concise code.",
                    "Start": 68,
                    "End": 68
                }
            ],
            "Final code": "default List<ApiDoc> handleTagsApiDoc(List<ApiDoc> apiDocList){\n  if (CollectionUtil.isEmpty(apiDocList)) {\n    return Collections.emptyList();\n  }\n  Map<String, ApiDoc> copyMap = new HashMap<>();\n  apiDocList.forEach(copyMap::computeIfPresent);\n  Map<String, ApiDoc> allMap = new HashMap<>(copyMap);\n  allMap.forEach((k, v) -> {\n    List<ApiMethodDoc> methodDocList = v.getList();\n    methodDocList.forEach(method -> {\n      String[] tags = method.getTags();\n      if (CollectionUtil.isEmpty(tags)) {\n        return;\n      }\n      for (String tag : tags) {\n        tag = StringUtil.trim(tag);\n        copyMap.computeIfPresent(tag, (k1, v2) -> {\n          method.setOrder(v2.getList().size() + 1);\n          v2.getList().add(method);\n          return v2;\n        });\n        copyMap.putIfAbsent(tag, ApiDoc.buildTagApiDoc(v, tag, method));\n      }\n    });\n  });\n  List<ApiDoc> apiDocs = new ArrayList<>(copyMap.values());\n  int index = apiDocs.size() - 1;\n  for (ApiDoc apiDoc : apiDocs) {\n    if (apiDoc.getOrder() == null) {\n      apiDoc.setOrder(index++);\n    }\n  }\n  apiDocs.sort(Comparator.comparing(ApiDoc::getOrder));\n  return apiDocs;\n}"
        }],
        "Old_Method": "default List<ApiDoc> handleTagsApiDoc(List<ApiDoc> apiDocList){\n  if (CollectionUtil.isEmpty(apiDocList)) {\n    return Collections.emptyList();\n  }\n  Map<String,ApiDoc> copyMap=new HashMap<>();\n  apiDocList.forEach(doc -> {\n    String[] tags=doc.getTags();\n    if (ArrayUtils.isEmpty(tags)) {\n      tags=new String[]{doc.getPackageName() + \".\" + doc.getName()};\n    }\n    for (    String tag : tags) {\n      tag=StringUtil.trim(tag);\n      copyMap.computeIfPresent(tag,(k,v) -> {\n        List<ApiMethodDoc> list=CollectionUtil.isEmpty(v.getList()) ? new ArrayList<>() : v.getList();\n        list.addAll(doc.getList());\n        v.setList(list);\n        return v;\n      }\n);\n      copyMap.putIfAbsent(tag,doc);\n    }\n  }\n);\n  Map<String,ApiDoc> allMap=new HashMap<>(copyMap);\n  allMap.forEach((k,v) -> {\n    List<ApiMethodDoc> methodDocList=v.getList();\n    methodDocList.forEach(method -> {\n      String[] tags=method.getTags();\n      if (ArrayUtils.isEmpty(tags)) {\n        return;\n      }\n      for (      String tag : tags) {\n        tag=StringUtil.trim(tag);\n        copyMap.computeIfPresent(tag,(k1,v2) -> {\n          method.setOrder(v2.getList().size() + 1);\n          v2.getList().add(method);\n          return v2;\n        }\n);\n        copyMap.putIfAbsent(tag,ApiDoc.buildTagApiDoc(v,tag,method));\n      }\n    }\n);\n  }\n);\n  List<ApiDoc> apiDocs=new ArrayList<>(copyMap.values());\n  int index=apiDocs.size() - 1;\n  for (  ApiDoc apiDoc : apiDocs) {\n    if (apiDoc.getOrder() == null) {\n      apiDoc.setOrder(index++);\n    }\n  }\n  apiDocs.sort(Comparator.comparing(ApiDoc::getOrder));\n  return apiDocs;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/IRestDocTemplate.java",
        "Start": 9408,
        "Stop": 11532,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "handleTagsApiDoc"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract logic into separate methods",
                    "Change_Diff": "- private List<RpcJavaMethod> buildServiceMethod(final JavaClass cls,ApiConfig apiConfig,ProjectDocConfigBuilder projectBuilder) {",
                    "Description": "The `buildServiceMethod` method is quite long and contains multiple levels of nested logic. It would be better to extract some of this logic into separate methods with descriptive names, to improve readability and maintainability of the code.",
                    "Start": 18,
                    "End": 80
                },
                {
                    "Improvement": "Use descriptive variable names",
                    "Change_Diff": "- public static int calculateSum(int[] arr) {",
                    "Description": "The variable names used in this method are not very descriptive and do not convey their purpose. It would be better to use more meaningful variable names to improve code readability.",
                    "Start": 3,
                    "End": 75
                },
                {
                    "Improvement": "Refactor conditional statements",
                    "Change_Diff": "- if (method.isPrivate()) {\n+ if (isMethodPrivate(method)) {",
                    "Description": "Instead of directly checking if a method is private, create a separate method to perform this check. This improves readability and allows for easier maintenance and modification of the condition in the future.",
                    "Start": 22,
                    "End": 28
                }
            ],
            "Final code": "private List<RpcJavaMethod> buildServiceMethod(final JavaClass cls, ApiConfig apiConfig, ProjectDocConfigBuilder projectBuilder) {\n  String clazName = cls.getCanonicalName();\n  List<JavaMethod> methods = cls.getMethods();\n  List<RpcJavaMethod> methodDocList = new ArrayList<>(methods.size());\n  Set<String> filterMethods = DocUtil.findFilterMethods(clazName);\n  boolean needAllMethods = filterMethods.contains(DocGlobalConstants.DEFAULT_FILTER_METHOD);\n  for (JavaMethod method : methods) {\n    if (isMethodPrivate(method)) {\n      continue;\n    }\n    if (Objects.nonNull(method.getTagByName(IGNORE))) {\n      continue;\n    }\n    if (StringUtil.isEmpty(method.getComment()) && apiConfig.isStrict()) {\n      throw new RuntimeException(\"Unable to find comment for method \" + method.getName() + \" in \" + cls.getCanonicalName());\n    }\n    if (needAllMethods || filterMethods.contains(method.getName())) {\n      RpcJavaMethod apiMethodDoc = convertToRpcJavaMethod(apiConfig, method, null);\n      methodDocList.add(apiMethodDoc);\n    }\n  }\n  methodDocList.addAll(getParentsClassMethods(apiConfig, cls));\n  if (cls.isInterface() || cls.isAbstract()) {\n    List<JavaType> implClasses = cls.getImplements();\n    for (JavaType type : implClasses) {\n      JavaClass javaClass = (JavaClass) type;\n      Map<String, JavaType> actualTypesMap = JavaClassUtil.getActualTypesMap(javaClass);\n      for (JavaMethod method : javaClass.getMethods()) {\n        if (!method.isDefault()) {\n          methodDocList.add(convertToRpcJavaMethod(apiConfig, method, actualTypesMap));\n        }\n      }\n    }\n  }\n  int methodOrder = 0;\n  List<RpcJavaMethod> rpcJavaMethods = new ArrayList<>(methodDocList.size());\n  for (RpcJavaMethod method : methodDocList) {\n    methodOrder++;\n    method.setOrder(methodOrder);\n    String methodUid = DocUtil.generateId(clazName + method.getName() + methodOrder);\n    method.setMethodId(methodUid);\n    List<ApiParam> requestParams = requestParams(method.getJavaMethod(), projectBuilder, new AtomicInteger(0), method.getActualTypesMap());\n    List<ApiParam> responseParams = buildReturnApiParams(DocJavaMethod.builder().setJavaMethod(method.getJavaMethod()).setActualTypesMap(method.getActualTypesMap()), projectBuilder);\n    if (apiConfig.isParamsDataToTree()) {\n      method.setRequestParams(ApiParamTreeUtil.apiParamToTree(requestParams));\n      method.setResponseParams(ApiParamTreeUtil.apiParamToTree(responseParams));\n    } else {\n      method.setRequestParams(requestParams);\n      method.setResponseParams(responseParams);\n    }\n    rpcJavaMethods.add(method);\n  }\n  return rpcJavaMethods;\n}\n"
        }],
        "Old_Method": "private List<RpcJavaMethod> buildServiceMethod(final JavaClass cls,ApiConfig apiConfig,ProjectDocConfigBuilder projectBuilder){\n  String clazName=cls.getCanonicalName();\n  List<JavaMethod> methods=cls.getMethods();\n  List<RpcJavaMethod> methodDocList=new ArrayList<>(methods.size());\n  Set<String> filterMethods=DocUtil.findFilterMethods(clazName);\n  boolean needAllMethods=filterMethods.contains(DocGlobalConstants.DEFAULT_FILTER_METHOD);\n  for (  JavaMethod method : methods) {\n    if (method.isPrivate()) {\n      continue;\n    }\n    if (Objects.nonNull(method.getTagByName(IGNORE))) {\n      continue;\n    }\n    if (StringUtil.isEmpty(method.getComment()) && apiConfig.isStrict()) {\n      throw new RuntimeException(\"Unable to find comment for method \" + method.getName() + \" in \"+ cls.getCanonicalName());\n    }\n    if (needAllMethods || filterMethods.contains(method.getName())) {\n      RpcJavaMethod apiMethodDoc=convertToRpcJavaMethod(apiConfig,method,null);\n      methodDocList.add(apiMethodDoc);\n    }\n  }\n  methodDocList.addAll(getParentsClassMethods(apiConfig,cls));\n  if (cls.isInterface() || cls.isAbstract()) {\n    List<JavaType> implClasses=cls.getImplements();\n    for (    JavaType type : implClasses) {\n      JavaClass javaClass=(JavaClass)type;\n      Map<String,JavaType> actualTypesMap=JavaClassUtil.getActualTypesMap(javaClass);\n      for (      JavaMethod method : javaClass.getMethods()) {\n        if (!method.isDefault()) {\n          methodDocList.add(convertToRpcJavaMethod(apiConfig,method,actualTypesMap));\n        }\n      }\n    }\n  }\n  int methodOrder=0;\n  List<RpcJavaMethod> rpcJavaMethods=new ArrayList<>(methodDocList.size());\n  for (  RpcJavaMethod method : methodDocList) {\n    methodOrder++;\n    method.setOrder(methodOrder);\n    String methodUid=DocUtil.generateId(clazName + method.getName() + methodOrder);\n    method.setMethodId(methodUid);\n    List<ApiParam> requestParams=requestParams(method.getJavaMethod(),projectBuilder,new AtomicInteger(0),method.getActualTypesMap());\n    List<ApiParam> responseParams=buildReturnApiParams(DocJavaMethod.builder().setJavaMethod(method.getJavaMethod()).setActualTypesMap(method.getActualTypesMap()),projectBuilder);\n    if (apiConfig.isParamsDataToTree()) {\n      method.setRequestParams(ApiParamTreeUtil.apiParamToTree(requestParams));\n      method.setResponseParams(ApiParamTreeUtil.apiParamToTree(responseParams));\n    }\n else {\n      method.setRequestParams(requestParams);\n      method.setResponseParams(responseParams);\n    }\n    rpcJavaMethods.add(method);\n  }\n  return rpcJavaMethods;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/RpcDocBuildTemplate.java",
        "Start": 3775,
        "Stop": 6960,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "buildServiceMethod"
    },
    {
        "Method_Improvements": [{
            "details": "Expected a ',' or '}' at 1175 [character 369 line 18]",
            "error": "An unexpected error occurred"
        }],
        "Old_Method": "/** \n * test jmeter\n */\n@Deprecated @Test public void testJmxBuilderControllersApi(){\n  @Deprecated ApiConfig config=new ApiConfig();\n  config.setServerUrl(\"http://127.0.0.1:8899\");\n  config.setOpenUrl(\"http://localhost:7700/api\");\n  config.setAppToken(\"be4211613a734b45888c075741680e49\");\n  config.setDebugEnvName(\"测试环境\");\n  config.setLanguage(DocLanguage.CHINESE);\n  config.setInlineEnum(true);\n  config.setStyle(\"randomLight\");\n  config.setCreateDebugPage(false);\n  config.setAllInOne(true);\n  config.setCoverOld(false);\n  config.setOutPath(\"D:\\\\smart-doc\\\\docs\\\\jmx1\");\n  config.setFramework(FrameworkEnum.SPRING.getFramework());\n  config.setSourceCodePaths(SourceCodePath.builder().setDesc(\"本项目代码\").setPath(\"D:\\\\smart-doc\\\\test-project\"));\n  config.setPackageFilters(\"com.power.doc.controller.*\");\n  config.setBaseDir(\"D:\\\\smart-doc\\\\test-project\\\\smart-doc-example-cn-master\");\n  config.setCodePath(\"/src/main/java\");\n  long start=System.currentTimeMillis();\n  JMeterBuilder.buildApiDoc(config);\n  long end=System.currentTimeMillis();\n  DateTimeUtil.printRunTime(end,start);\n}\n",
        "File_Path": "smart-doc/src/test/java/com/ly/doc/ApiDocTest.java",
        "Start": 2334,
        "Stop": 3791,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "testJmxBuilderControllersApi"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use a more meaningful variable name",
                    "Change_Diff": "- config.setServerUrl(\"http://127.0.0.1:8899\");\n+ config.setServerUrl(\"http://localhost:8899\");",
                    "Description": "Change the variable name `config` to something more meaningful, such as `apiConfig`.",
                    "Start": 3,
                    "End": 3
                },
                {
                    "Improvement": "Use constants instead of hardcoding values",
                    "Change_Diff": "- config.setAppToken(\"be4211613a734b45888c075741680e49\");\n+ config.setAppToken(AppConstants.APP_TOKEN);",
                    "Description": "Instead of hardcoding the app token, declare it as a constant and use the constant in the code.",
                    "Start": 4,
                    "End": 4
                },
                {
                    "Improvement": "Use proper indentation",
                    "Change_Diff": "-config.setInlineEnum(true);\n-config.setStyle(\"randomLight\");\n-config.setCreateDebugPage(false);\n-config.setAllInOne(true);\n-config.setCoverOld(false);\n-config.setOutPath(\"D:\\smart-doc\\docs\\jmx1\");\n+    config.setInlineEnum(true);\n+    config.setStyle(\"randomLight\");\n+    config.setCreateDebugPage(false);\n+    config.setAllInOne(true);\n+    config.setCoverOld(false);\n+    config.setOutPath(\"D:\\smart-doc\\docs\\jmx1\");",
                    "Description": "Add proper indentation to improve code readability.",
                    "Start": 7,
                    "End": 14
                }
            ],
            "Final code": "    @Deprecated\n    @Test\n    public void testMdBuilderControllersApi1() {\n        @Deprecated\n        ApiConfig apiConfig = new ApiConfig();\n        apiConfig.setServerUrl(\"http://localhost:8899\");\n        apiConfig.setOpenUrl(\"http://localhost:7700/api\");\n        apiConfig.setAppToken(AppConstants.APP_TOKEN);\n        apiConfig.setDebugEnvName(\"测试环境\");\n        apiConfig.setInlineEnum(true);\n        apiConfig.setStyle(\"randomLight\");\n        apiConfig.setCreateDebugPage(false);\n        apiConfig.setAllInOne(true);\n        apiConfig.setCoverOld(false);\n        apiConfig.setOutPath(\"D:\\smart-doc\\docs\\jmx1\");\n        apiConfig.setFramework(FrameworkEnum.SPRING.getFramework());\n        apiConfig.setSourceCodePaths(SourceCodePath.builder().setDesc(\"本项目代码\").setPath(\"D:\\\\smart-doc\\\\test-project\"));\n        apiConfig.setPackageFilters(\"com.power.doc.controller.*\");\n        apiConfig.setBaseDir(\"D:\\\\smart-doc\\\\test-project\\\\smart-doc-example-cn-master\");\n        apiConfig.setCodePath(\"/src/main/java\");\n        long start = System.currentTimeMillis();\n        ApiDocBuilder.buildApiDoc(apiConfig);\n        long end = System.currentTimeMillis();\n        DateTimeUtil.printRunTime(end, start);\n    }"
        }],
        "Old_Method": "/** \n * test markdown\n */\n@Deprecated @Test public void testMdBuilderControllersApi1(){\n  @Deprecated ApiConfig config=new ApiConfig();\n  config.setServerUrl(\"http://127.0.0.1:8899\");\n  config.setOpenUrl(\"http://localhost:7700/api\");\n  config.setAppToken(\"be4211613a734b45888c075741680e49\");\n  config.setDebugEnvName(\"测试环境\");\n  config.setInlineEnum(true);\n  config.setStyle(\"randomLight\");\n  config.setCreateDebugPage(false);\n  config.setAllInOne(true);\n  config.setCoverOld(false);\n  config.setOutPath(\"D:\\\\smart-doc\\\\docs\\\\jmx1\");\n  config.setFramework(FrameworkEnum.SPRING.getFramework());\n  config.setSourceCodePaths(SourceCodePath.builder().setDesc(\"本项目代码\").setPath(\"D:\\\\smart-doc\\\\test-project\"));\n  config.setPackageFilters(\"com.power.doc.controller.*\");\n  config.setBaseDir(\"D:\\\\smart-doc\\\\test-project\\\\smart-doc-example-cn-master\");\n  config.setCodePath(\"/src/main/java\");\n  long start=System.currentTimeMillis();\n  ApiDocBuilder.buildApiDoc(config);\n  long end=System.currentTimeMillis();\n  DateTimeUtil.printRunTime(end,start);\n}\n",
        "File_Path": "smart-doc/src/test/java/com/ly/doc/ApiDocTest.java",
        "Start": 3797,
        "Stop": 5156,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "testMdBuilderControllersApi1"
    },
    {
        "Method_Improvements": [{
            "Improvements": [{
                "Improvement": "Extract code into separate methods for improved readability and modularity",
                "Change_Diff": "- public void buildSearchJs(ApiConfig config,JavaProjectBuilder javaProjectBuilder,List<ApiDoc> apiDocList,String template) {\n+ private List<ApiDoc> buildApiDocs(ApiConfig config, JavaProjectBuilder javaProjectBuilder, List<ApiDoc> apiDocList, Template tpl) {\n+ private Map<String, String> setTitleMap(ApiConfig config, Template tpl) {\n+ private void addErrorCodeApiDoc(ApiConfig config, List<ApiDoc> apiDocList, Map<String, String> titleMap, boolean isOnlyDefaultGroup) {\n+ private void addApiDocDictList(ApiConfig config, List<ApiDoc> apiDocList, Map<String, String> titleMap, boolean isOnlyDefaultGroup) {\n",
                "Description": "The method `buildSearchJs` is quite long and performs several distinct tasks. Extracting these tasks into separate methods improves readability and modularity.",
                "Start": 32,
                "End": 93
            }],
            "Final code": "public void buildSearchJs(ApiConfig config, JavaProjectBuilder javaProjectBuilder, List<ApiDoc> apiDocList, String template) {\n  List<ApiDoc> apiDocs = buildApiDocs(config, javaProjectBuilder, apiDocList, template);\n  tpl.binding(TemplateVariable.API_DOC_LIST.getVariable(), apiDocs);\n  FileUtil.nioWriteFile(tpl.render(), config.getOutPath() + DocGlobalConstants.FILE_SEPARATOR + DocGlobalConstants.SEARCH_JS_OUT);\n}\n\nprivate List<ApiDoc> buildApiDocs(ApiConfig config, JavaProjectBuilder javaProjectBuilder, List<ApiDoc> apiDocList, Template tpl) {\n  List<ApiErrorCode> errorCodeList = DocUtil.errorCodeDictToList(config, javaProjectBuilder);\n  List<ApiDocDict> apiDocDictList = DocUtil.buildDictionary(config, javaProjectBuilder);\n  boolean isOnlyDefaultGroup = apiDocList.size() == 1;\n  Map<String, String> titleMap = setTitleMap(config, tpl);\n  addErrorCodeApiDoc(config, apiDocList, titleMap, isOnlyDefaultGroup);\n  addApiDocDictList(config, apiDocList, titleMap, isOnlyDefaultGroup);\n  List<ApiDoc> apiDocs = new ArrayList<>();\n  for (ApiDoc apiDoc1 : apiDocList) {\n    apiDoc1.setOrder(apiDocs.size() + 1);\n    apiDocs.add(apiDoc1);\n  }\n  return apiDocs;\n}\n\nprivate Map<String, String> setTitleMap(ApiConfig config, Template tpl) {\n  return setDirectoryLanguageVariable(config, tpl);\n}\n\nprivate void addErrorCodeApiDoc(ApiConfig config, List<ApiDoc> apiDocList, Map<String, String> titleMap, boolean isOnlyDefaultGroup) {\n  // Existing code for adding ApiDoc for error codes\n}\n\nprivate void addApiDocDictList(ApiConfig config, List<ApiDoc> apiDocList, Map<String, String> titleMap, boolean isOnlyDefaultGroup) {\n  // Existing code for adding ApiDoc for dictionary\n}"
        }],
        "Old_Method": "public void buildSearchJs(ApiConfig config,JavaProjectBuilder javaProjectBuilder,List<ApiDoc> apiDocList,String template){\n  List<ApiErrorCode> errorCodeList=DocUtil.errorCodeDictToList(config,javaProjectBuilder);\n  Template tpl=BeetlTemplateUtil.getByName(template);\n  List<ApiDoc> apiDocs=new ArrayList<>();\n  for (  ApiDoc apiDoc1 : apiDocList) {\n    apiDoc1.setOrder(apiDocs.size() + 1);\n    apiDocs.add(apiDoc1);\n  }\n  boolean isOnlyDefaultGroup=apiDocList.size() == 1;\n  Map<String,String> titleMap=setDirectoryLanguageVariable(config,tpl);\n  if (CollectionUtil.isNotEmpty(errorCodeList)) {\n    ApiDoc apiDoc1=new ApiDoc();\n    int codeIndex=0;\n    if (isOnlyDefaultGroup) {\n      codeIndex=apiDocs.get(0).getChildrenApiDocs().size();\n    }\n else {\n      codeIndex=apiDocList.size();\n    }\n    apiDoc1.setOrder(codeIndex + 1);\n    apiDoc1.setDesc(titleMap.get(TemplateVariable.ERROR_LIST_TITLE.getVariable()));\n    apiDoc1.setList(new ArrayList<>(0));\n    apiDoc1.setLink(\"error_code_list\");\n    apiDoc1.setAlias(\"error\");\n    apiDoc1.setGroup(apiDoc1.getDesc());\n    if (isOnlyDefaultGroup) {\n      apiDocs.get(0).getChildrenApiDocs().add(apiDoc1);\n    }\n else {\n      apiDocs.add(apiDoc1);\n    }\n  }\n  List<ApiDocDict> apiDocDictList=DocUtil.buildDictionary(config,javaProjectBuilder);\n  if (CollectionUtil.isNotEmpty(apiDocDictList)) {\n    ApiDoc apiDoc1=new ApiDoc();\n    int codeIndex=0;\n    if (isOnlyDefaultGroup) {\n      if (apiDocs.size() > 0) {\n        codeIndex=apiDocs.get(0).getChildrenApiDocs().size();\n      }\n    }\n else {\n      codeIndex=apiDocList.size();\n    }\n    apiDoc1.setOrder(codeIndex + 1);\n    apiDoc1.setLink(\"dict_list\");\n    apiDoc1.setAlias(\"dict\");\n    apiDoc1.setDesc(titleMap.get(TemplateVariable.DICT_LIST_TITLE.getVariable()));\n    apiDoc1.setGroup(apiDoc1.getDesc());\n    List<ApiMethodDoc> methodDocs=new ArrayList<>();\n    List<ApiDoc> childrenApiDocs=new ArrayList<>();\n    for (    ApiDocDict apiDocDict : apiDocDictList) {\n      ApiMethodDoc methodDoc=new ApiMethodDoc();\n      methodDoc.setOrder(apiDocDict.getOrder());\n      methodDoc.setDesc(apiDocDict.getTitle());\n      methodDocs.add(methodDoc);\n      ApiDoc childrenApiDoc=new ApiDoc();\n      childrenApiDoc.setOrder(apiDocDict.getOrder());\n      childrenApiDoc.setAlias(apiDocDict.getTitle());\n      childrenApiDoc.setDesc(apiDocDict.getTitle());\n      childrenApiDoc.setName(apiDocDict.getTitle());\n      childrenApiDoc.setList(new ArrayList<>(0));\n      childrenApiDocs.add(childrenApiDoc);\n    }\n    apiDoc1.setChildrenApiDocs(childrenApiDocs);\n    apiDoc1.setList(methodDocs);\n    if (isOnlyDefaultGroup) {\n      if (apiDocs.size() > 0) {\n        apiDocs.get(0).getChildrenApiDocs().add(apiDoc1);\n      }\n    }\n else {\n      apiDocs.add(apiDoc1);\n    }\n  }\n  tpl.binding(TemplateVariable.API_DOC_LIST.getVariable(),apiDocs);\n  FileUtil.nioWriteFile(tpl.render(),config.getOutPath() + DocGlobalConstants.FILE_SEPARATOR + DocGlobalConstants.SEARCH_JS_OUT);\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/builder/DocBuilderTemplate.java",
        "Start": 9354,
        "Stop": 13038,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "buildSearchJs"
    },
    {
        "Method_Improvements": [{
            "details": "Unterminated string at 11423 [character 4600 line 18]",
            "error": "An unexpected error occurred"
        }],
        "Old_Method": "private List<ApiParam> requestParams(final JavaMethod javaMethod,ProjectDocConfigBuilder builder,AtomicInteger atomicInteger,Map<String,JavaType> actualTypesMap){\n  boolean isStrict=builder.getApiConfig().isStrict();\n  boolean isShowJavaType=builder.getApiConfig().getShowJavaType();\n  String className=javaMethod.getDeclaringClass().getCanonicalName();\n  Map<String,String> paramTagMap=DocUtil.getCommentsByTag(javaMethod,DocTags.PARAM,className);\n  List<JavaParameter> parameterList=javaMethod.getParameters();\n  if (parameterList.size() < 1) {\n    return null;\n  }\n  List<ApiParam> paramList=new ArrayList<>();\n  for (  JavaParameter parameter : parameterList) {\n    boolean required=false;\n    String paramName=parameter.getName();\n    String typeName=replaceTypeName(parameter.getType().getGenericCanonicalName(),actualTypesMap,Boolean.FALSE);\n    String simpleName=replaceTypeName(parameter.getType().getValue(),actualTypesMap,Boolean.FALSE).toLowerCase();\n    String fullTypeName=replaceTypeName(parameter.getType().getFullyQualifiedName(),actualTypesMap,Boolean.FALSE);\n    String paramPre=paramName + \".\";\n    if (!paramTagMap.containsKey(paramName) && JavaClassValidateUtil.isPrimitive(fullTypeName) && isStrict) {\n      throw new RuntimeException(\"ERROR: Unable to find javadoc @param for actual param \\\"\" + paramName + \"\\\" in method \"+ javaMethod.getName()+ \" from \"+ className);\n    }\n    StringBuilder comment=new StringBuilder(this.paramCommentResolve(paramTagMap.get(paramName)));\n    String mockValue=JavaFieldUtil.createMockValue(paramTagMap,paramName,typeName,typeName);\n    JavaClass javaClass=builder.getJavaProjectBuilder().getClassByName(fullTypeName);\n    List<JavaAnnotation> annotations=parameter.getAnnotations();\n    for (    JavaAnnotation a : annotations) {\n      if (JavaClassValidateUtil.isJSR303Required(a.getType().getValue())) {\n        required=true;\n      }\n    }\n    comment.append(JavaFieldUtil.getJsrComment(annotations));\n    Set<String> groupClasses=JavaClassUtil.getParamGroupJavaClass(annotations,builder.getJavaProjectBuilder());\n    if (JavaClassValidateUtil.isCollection(fullTypeName) || JavaClassValidateUtil.isArray(fullTypeName)) {\n      if (JavaClassValidateUtil.isCollection(typeName)) {\n        typeName=typeName + \"<T>\";\n      }\n      String[] gicNameArr=DocClassUtil.getSimpleGicName(typeName);\n      String gicName=gicNameArr[0];\n      if (JavaClassValidateUtil.isArray(gicName)) {\n        gicName=gicName.substring(0,gicName.indexOf(\"[\"));\n      }\n      if (JavaClassValidateUtil.isPrimitive(gicName)) {\n        String processedType=isShowJavaType ? JavaClassUtil.getClassSimpleName(typeName) : DocClassUtil.processTypeNameForParams(simpleName);\n        ApiParam param=ApiParam.of().setId(atomicInteger.incrementAndGet()).setField(paramName).setDesc(comment + \"   (children type : \" + gicName+ \")\").setRequired(required).setType(processedType);\n        paramList.add(param);\n      }\n else {\n        paramList.addAll(ParamsBuildHelper.buildParams(gicNameArr[0],paramPre,0,\"true\",Boolean.FALSE,new HashMap<>(),builder,groupClasses,0,Boolean.FALSE,atomicInteger));\n      }\n    }\n else     if (JavaClassValidateUtil.isPrimitive(fullTypeName)) {\n      ApiParam param=ApiParam.of().setId(atomicInteger.incrementAndGet()).setField(paramName).setType(JavaClassUtil.getClassSimpleName(typeName)).setDesc(comment.toString()).setRequired(required).setMaxLength(JavaFieldUtil.getParamMaxLength(parameter.getAnnotations())).setValue(mockValue).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n      paramList.add(param);\n    }\n else     if (JavaClassValidateUtil.isMap(fullTypeName)) {\n      if (JavaClassValidateUtil.isMap(typeName)) {\n        ApiParam apiParam=ApiParam.of().setId(atomicInteger.incrementAndGet()).setField(paramName).setType(typeName).setDesc(comment.toString()).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n        paramList.add(apiParam);\n        continue;\n      }\n      String[] gicNameArr=DocClassUtil.getSimpleGicName(typeName);\n      paramList.addAll(ParamsBuildHelper.buildParams(gicNameArr[1],paramPre,0,\"true\",Boolean.FALSE,new HashMap<>(),builder,groupClasses,0,Boolean.FALSE,atomicInteger));\n    }\n else     if (javaClass.isEnum()) {\n      ApiParam param=ApiParam.of().setId(atomicInteger.incrementAndGet()).setField(paramName).setType(\"Enum\").setRequired(required).setDesc(comment.toString()).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n      paramList.add(param);\n    }\n else {\n      paramList.addAll(ParamsBuildHelper.buildParams(typeName,paramPre,0,\"true\",Boolean.FALSE,new HashMap<>(),builder,groupClasses,0,Boolean.FALSE,atomicInteger));\n    }\n  }\n  return paramList;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/RpcDocBuildTemplate.java",
        "Start": 6966,
        "Stop": 12855,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "requestParams"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract method for handling annotations",
                    "Change_Diff": "- List<JavaAnnotation> annotations=getAnnotations(method);\n- String methodType=\"GET\";\n- String shortUrl=null;\n- String mediaType=null;\n- boolean deprecated=false;",
                    "Description": "Extract the logic for handling annotations into a separate method.",
                    "Start": 21,
                    "End": 60
                },
                {
                    "Improvement": "Use switch statement instead of multiple if-else statements",
                    "Change_Diff": "- if (SolonAnnotations.GET_MAPPING.equals(annotationName) || SolonAnnotations.GET_MAPPING_FULLY.equals(annotationName)) {\n-     methodType=Methods.GET.getValue();\n- }\n- else if (SolonAnnotations.POST_MAPPING.equals(annotationName) || SolonAnnotations.POST_MAPPING_FULLY.equals(annotationName)) {\n-     methodType=Methods.POST.getValue();\n- }\n- else if (SolonAnnotations.PUT_MAPPING.equals(annotationName) || SolonAnnotations.PUT_MAPPING_FULLY.equals(annotationName)) {\n-     methodType=Methods.PUT.getValue();\n- }\n- else if (SolonAnnotations.PATCH_MAPPING.equals(annotationName) || SolonAnnotations.PATCH_MAPPING_FULLY.equals(annotationName)) {\n-     methodType=Methods.PATCH.getValue();\n- }\n- else if (SolonAnnotations.DELETE_MAPPING.equals(annotationName) || SolonAnnotations.DELETE_MAPPING_FULLY.equals(annotationName)) {\n-     methodType=Methods.DELETE.getValue();\n- }",
                    "Description": "Replace multiple if-else statements with a switch statement to handle different annotation types.",
                    "Start": 32,
                    "End": 64
                }
            ],
            "Final code": "public RequestMapping handle(ProjectDocConfigBuilder projectBuilder, String controllerBaseUrl, JavaMethod method, FrameworkAnnotations frameworkAnnotations, RequestMappingFunc requestMappingFunc) {\n  if (Objects.nonNull(method.getTagByName(IGNORE))) {\n    return null;\n  }\n\n  List<JavaAnnotation> annotations = getAnnotations(method);\n  RequestMapping requestMapping = processAnnotations(annotations);\n  requestMappingFunc.process(method.getDeclaringClass(), requestMapping);\n\n  return requestMapping;\n}\n\nprivate RequestMapping processAnnotations(List<JavaAnnotation> annotations) {\n  String methodType = \"GET\";\n  String shortUrl = null;\n  String mediaType = null;\n  boolean deprecated = false;\n\n  for (JavaAnnotation annotation : annotations) {\n    String annotationName = annotation.getType().getName();\n\n    switch (annotationName) {\n      case SolonAnnotations.GET_MAPPING:\n      case SolonAnnotations.GET_MAPPING_FULLY:\n        methodType = Methods.GET.getValue();\n        break;\n      case SolonAnnotations.POST_MAPPING:\n      case SolonAnnotations.POST_MAPPING_FULLY:\n        methodType = Methods.POST.getValue();\n        break;\n      case SolonAnnotations.PUT_MAPPING:\n      case SolonAnnotations.PUT_MAPPING_FULLY:\n        methodType = Methods.PUT.getValue();\n        break;\n      case SolonAnnotations.PATCH_MAPPING:\n      case SolonAnnotations.PATCH_MAPPING_FULLY:\n        methodType = Methods.PATCH.getValue();\n        break;\n      case SolonAnnotations.DELETE_MAPPING:\n      case SolonAnnotations.DELETE_MAPPING_FULLY:\n        methodType = Methods.DELETE.getValue();\n        break;\n    }\n\n    if (DocAnnotationConstants.DEPRECATED.equals(annotationName)) {\n      deprecated = true;\n    }\n\n    if (SolonAnnotations.REQUEST_MAPPING.equals(annotationName) || SolonAnnotations.REQUEST_MAPPING_FULLY.equals(annotationName)) {\n      shortUrl = DocUtil.handleMappingValue(annotation);\n      Object produces = annotation.getNamedParameter(\"produces\");\n      if (Objects.nonNull(produces)) {\n        mediaType = produces.toString();\n      }\n    }\n  }\n\n  if (Objects.nonNull(method.getTagByName(DEPRECATED))) {\n    deprecated = true;\n  }\n\n  RequestMapping requestMapping = RequestMapping.builder()\n    .setMediaType(mediaType)\n    .setMethodType(methodType)\n    .setDeprecated(deprecated)\n    .setShortUrl(shortUrl);\n\n  return formatMappingData(projectBuilder, controllerBaseUrl, requestMapping);\n}"
        }],
        "Old_Method": "/** \n * handle solon request mapping\n * @param projectBuilder    projectBuilder\n * @param controllerBaseUrl solon mvc controller base url\n * @param method            JavaMethod\n * @return RequestMapping\n */\npublic RequestMapping handle(ProjectDocConfigBuilder projectBuilder,String controllerBaseUrl,JavaMethod method,FrameworkAnnotations frameworkAnnotations,RequestMappingFunc requestMappingFunc){\n  if (Objects.nonNull(method.getTagByName(IGNORE))) {\n    return null;\n  }\n  List<JavaAnnotation> annotations=getAnnotations(method);\n  String methodType=\"GET\";\n  String shortUrl=null;\n  String mediaType=null;\n  boolean deprecated=false;\n  for (  JavaAnnotation annotation : annotations) {\n    String annotationName=annotation.getType().getName();\n    if (DocAnnotationConstants.DEPRECATED.equals(annotationName)) {\n      deprecated=true;\n    }\n    if (SolonAnnotations.REQUEST_MAPPING.equals(annotationName) || SolonAnnotations.REQUEST_MAPPING_FULLY.equals(annotationName)) {\n      shortUrl=DocUtil.handleMappingValue(annotation);\n      Object produces=annotation.getNamedParameter(\"produces\");\n      if (Objects.nonNull(produces)) {\n        mediaType=produces.toString();\n      }\n    }\n    if (SolonAnnotations.GET_MAPPING.equals(annotationName) || SolonAnnotations.GET_MAPPING_FULLY.equals(annotationName)) {\n      methodType=Methods.GET.getValue();\n    }\n else     if (SolonAnnotations.POST_MAPPING.equals(annotationName) || SolonAnnotations.POST_MAPPING_FULLY.equals(annotationName)) {\n      methodType=Methods.POST.getValue();\n    }\n else     if (SolonAnnotations.PUT_MAPPING.equals(annotationName) || SolonAnnotations.PUT_MAPPING_FULLY.equals(annotationName)) {\n      methodType=Methods.PUT.getValue();\n    }\n else     if (SolonAnnotations.PATCH_MAPPING.equals(annotationName) || SolonAnnotations.PATCH_MAPPING_FULLY.equals(annotationName)) {\n      methodType=Methods.PATCH.getValue();\n    }\n else     if (SolonAnnotations.DELETE_MAPPING.equals(annotationName) || SolonAnnotations.DELETE_MAPPING_FULLY.equals(annotationName)) {\n      methodType=Methods.DELETE.getValue();\n    }\n  }\n  if (Objects.nonNull(method.getTagByName(DEPRECATED))) {\n    deprecated=true;\n  }\n  RequestMapping requestMapping=RequestMapping.builder().setMediaType(mediaType).setMethodType(methodType).setDeprecated(deprecated).setShortUrl(shortUrl);\n  requestMapping=formatMappingData(projectBuilder,controllerBaseUrl,requestMapping);\n  requestMappingFunc.process(method.getDeclaringClass(),requestMapping);\n  return requestMapping;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/handler/SolonRequestMappingHandler.java",
        "Start": 1628,
        "Stop": 4598,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "handle"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract complex logic into separate methods",
                    "Change_Diff": "- out: for (DocJavaParameter apiParameter : parameterList) {\n+ out: for (DocJavaParameter apiParameter : getApiParameters(parameterList, mappingParams)) {",
                    "Description": "Extract the logic of getting API parameters into a separate method to improve code readability and maintainability.",
                    "Start": 74,
                    "End": 74
                },
                {
                    "Improvement": "Refactor loop logic to improve readability",
                    "Change_Diff": "- for (JavaAnnotation annotation : annotations) {\n+ for (JavaAnnotation annotation : parameter.getAnnotations()) {",
                    "Description": "Refactor the loop logic to directly iterate over the 'annotations' list instead of getting the annotations from the parameter object inside the loop.",
                    "Start": 117,
                    "End": 117
                },
                {
                    "Improvement": "Refactor if-else conditions to improve readability",
                    "Change_Diff": "- if (JavaClassValidateUtil.isJSR303Required(annotationName)) {\n+ if (isValidJSR303Required(annotationName)) {",
                    "Description": "Refactor the if-else condition to better indicate its purpose and improve code readability.",
                    "Start": 137,
                    "End": 137
                },
                {
                    "Improvement": "Extract complex parameter handling logic into separate method",
                    "Change_Diff": "- paramList.addAll(ParamsBuildHelper.buildParams(typeName, DocGlobalConstants.EMPTY, 0, String.valueOf(required), Boolean.FALSE, new HashMap<>(), builder, groupClasses, 0, Boolean.FALSE, null));\n+ paramList.addAll(getParamsList(typeName, required, groupClasses));",
                    "Description": "Extract the complex logic for building parameters into a separate method for better code organization and maintainability.",
                    "Start": 227,
                    "End": 227
                }
            ],
            "Final code": "private List<DocJavaParameter> getApiParameters(List<DocJavaParameter> parameterList, Map<String, String> mappingParams) {\n  List<DocJavaParameter> apiParameters = new ArrayList<>();\n  for (DocJavaParameter parameter : parameterList) {\n    String paramName = parameter.getJavaParameter().getName();\n    if (!mappingParams.containsKey(paramName)) {\n      apiParameters.add(parameter);\n    }\n  }\n  return apiParameters;\n}\n\nprivate List<ApiParam> getParamsList(String typeName, boolean required, Set<String> groupClasses) {\n  String[] gicNameArr = DocClassUtil.getSimpleGicName(typeName);\n  if (JavaClassValidateUtil.isPrimitive(gicNameArr[1])) {\n    ApiParam apiParam = ApiParam.of().setField(paramName).setType(\"map\").setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setDesc(comment.toString()).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n    paramList.add(apiParam);\n    if (requestBodyCounter > 0) {\n      Map<String,Object> map = OpenApiSchemaUtil.mapTypeSchema(gicNameArr[1]);\n      docJavaMethod.setRequestSchema(map);\n    }\n  }\n  else {\n    return ParamsBuildHelper.buildParams(typeName, DocGlobalConstants.EMPTY, 0, String.valueOf(required), Boolean.FALSE, new HashMap<>(), builder, groupClasses, 0, Boolean.FALSE, null);\n  }\n}"
        }],
        "Old_Method": "default ApiMethodReqParam requestParams(final DocJavaMethod docJavaMethod,ProjectDocConfigBuilder builder,List<ApiReqParam> configApiReqParams,FrameworkAnnotations frameworkAnnotations){\n  JavaMethod javaMethod=docJavaMethod.getJavaMethod();\n  boolean isStrict=builder.getApiConfig().isStrict();\n  String className=javaMethod.getDeclaringClass().getCanonicalName();\n  Map<String,String> paramTagMap=docJavaMethod.getParamTagMap();\n  Map<String,String> paramsComments=docJavaMethod.getParamsComments();\n  List<ApiParam> paramList=new ArrayList<>();\n  Map<String,String> mappingParams=new HashMap<>();\n  List<JavaAnnotation> methodAnnotations=javaMethod.getAnnotations();\n  Map<String,MappingAnnotation> mappingAnnotationMap=frameworkAnnotations.getMappingAnnotations();\n  for (  JavaAnnotation annotation : methodAnnotations) {\n    String annotationName=annotation.getType().getName();\n    MappingAnnotation mappingAnnotation=mappingAnnotationMap.get(annotationName);\n    if (Objects.nonNull(mappingAnnotation) && StringUtil.isNotEmpty(mappingAnnotation.getParamsProp())) {\n      Object paramsObjects=annotation.getNamedParameter(mappingAnnotation.getParamsProp());\n      if (Objects.isNull(paramsObjects)) {\n        continue;\n      }\n      String params=StringUtil.removeQuotes(paramsObjects.toString());\n      if (!params.startsWith(\"[\")) {\n        mappingParamToApiParam(paramsObjects.toString(),paramList,mappingParams);\n        continue;\n      }\n      List<String> headers=(LinkedList)paramsObjects;\n      for (      String str : headers) {\n        mappingParamToApiParam(str,paramList,mappingParams);\n      }\n    }\n  }\n  final Map<String,Map<String,ApiReqParam>> collect=configApiReqParams.stream().collect(Collectors.groupingBy(ApiReqParam::getParamIn,Collectors.toMap(ApiReqParam::getName,m -> m,(k1,k2) -> k1)));\n  final Map<String,ApiReqParam> pathReqParamMap=collect.getOrDefault(ApiReqParamInTypeEnum.PATH.getValue(),Collections.emptyMap());\n  final Map<String,ApiReqParam> queryReqParamMap=collect.getOrDefault(ApiReqParamInTypeEnum.QUERY.getValue(),Collections.emptyMap());\n  List<DocJavaParameter> parameterList=getJavaParameterList(builder,docJavaMethod,frameworkAnnotations);\n  if (parameterList.isEmpty()) {\n    AtomicInteger querySize=new AtomicInteger(paramList.size() + 1);\n    paramList.addAll(queryReqParamMap.values().stream().map(p -> ApiReqParam.convertToApiParam(p).setQueryParam(true).setId(querySize.getAndIncrement())).collect(Collectors.toList()));\n    AtomicInteger pathSize=new AtomicInteger(1);\n    return ApiMethodReqParam.builder().setPathParams(new ArrayList<>(pathReqParamMap.values().stream().map(p -> ApiReqParam.convertToApiParam(p).setPathParam(true).setId(pathSize.getAndIncrement())).collect(Collectors.toList()))).setQueryParams(paramList).setRequestParams(new ArrayList<>(0));\n  }\n  boolean requestFieldToUnderline=builder.getApiConfig().isRequestFieldToUnderline();\n  int requestBodyCounter=0;\n  out:   for (  DocJavaParameter apiParameter : parameterList) {\n    JavaParameter parameter=apiParameter.getJavaParameter();\n    String paramName=parameter.getName();\n    if (mappingParams.containsKey(paramName)) {\n      continue;\n    }\n    String typeName=apiParameter.getGenericCanonicalName();\n    String simpleTypeName=apiParameter.getTypeValue();\n    String simpleName=simpleTypeName.toLowerCase();\n    String fullTypeName=apiParameter.getFullyQualifiedName();\n    if (!paramTagMap.containsKey(paramName) && JavaClassValidateUtil.isPrimitive(fullTypeName) && isStrict) {\n      throw new RuntimeException(\"ERROR: Unable to find javadoc @param for actual param \\\"\" + paramName + \"\\\" in method \"+ javaMethod.getName()+ \" from \"+ className);\n    }\n    StringBuilder comment=new StringBuilder(this.paramCommentResolve(paramTagMap.get(paramName)));\n    JavaClass javaClass=builder.getJavaProjectBuilder().getClassByName(fullTypeName);\n    String mockValue=JavaFieldUtil.createMockValue(paramsComments,paramName,typeName,simpleTypeName);\n    List<JavaAnnotation> annotations=parameter.getAnnotations();\n    Set<String> groupClasses=JavaClassUtil.getParamGroupJavaClass(annotations,builder.getJavaProjectBuilder());\n    String strRequired=\"false\";\n    boolean isPathVariable=false;\n    boolean isRequestBody=false;\n    boolean required=false;\n    for (    JavaAnnotation annotation : annotations) {\n      String annotationName=annotation.getType().getValue();\n      if (ignoreMvcParamWithAnnotation(annotationName)) {\n        continue out;\n      }\n      if (frameworkAnnotations.getRequestParamAnnotation().getAnnotationName().equals(annotationName) || frameworkAnnotations.getPathVariableAnnotation().getAnnotationName().equals(annotationName)) {\n        String defaultValueProp=DocAnnotationConstants.DEFAULT_VALUE_PROP;\n        String requiredProp=DocAnnotationConstants.REQUIRED_PROP;\n        if (frameworkAnnotations.getRequestParamAnnotation().getAnnotationName().equals(annotationName)) {\n          defaultValueProp=frameworkAnnotations.getRequestParamAnnotation().getDefaultValueProp();\n          requiredProp=frameworkAnnotations.getRequestParamAnnotation().getRequiredProp();\n        }\n        if (frameworkAnnotations.getPathVariableAnnotation().getAnnotationName().equals(annotationName)) {\n          defaultValueProp=frameworkAnnotations.getPathVariableAnnotation().getDefaultValueProp();\n          requiredProp=frameworkAnnotations.getPathVariableAnnotation().getRequiredProp();\n          isPathVariable=true;\n        }\n        AnnotationValue annotationDefaultVal=annotation.getProperty(defaultValueProp);\n        if (Objects.nonNull(annotationDefaultVal)) {\n          mockValue=DocUtil.resolveAnnotationValue(annotationDefaultVal);\n        }\n        paramName=getParamName(paramName,annotation);\n        AnnotationValue annotationRequired=annotation.getProperty(requiredProp);\n        if (Objects.nonNull(annotationRequired)) {\n          strRequired=annotationRequired.toString();\n        }\n else {\n          strRequired=\"true\";\n        }\n      }\n      if (JavaClassValidateUtil.isJSR303Required(annotationName)) {\n        strRequired=\"true\";\n      }\n      if (frameworkAnnotations.getRequestBodyAnnotation().getAnnotationName().equals(annotationName)) {\n        mockValue=JsonBuildHelper.buildJson(fullTypeName,typeName,Boolean.FALSE,0,new HashMap<>(),groupClasses,builder);\n        requestBodyCounter++;\n        isRequestBody=true;\n      }\n      required=Boolean.parseBoolean(strRequired);\n    }\n    comment.append(JavaFieldUtil.getJsrComment(annotations));\n    if (requestFieldToUnderline && !isPathVariable) {\n      paramName=StringUtil.camelToUnderline(paramName);\n    }\n    if (JavaClassValidateUtil.isFile(typeName)) {\n      ApiParam param=ApiParam.of().setField(paramName).setType(DocGlobalConstants.PARAM_TYPE_FILE).setId(paramList.size() + 1).setQueryParam(true).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION).setDesc(comment.toString());\n      if (typeName.contains(\"[]\") || typeName.endsWith(\">\")) {\n        comment.append(\"(array of file)\");\n        param.setType(DocGlobalConstants.PARAM_TYPE_FILE);\n        param.setDesc(comment.toString());\n        param.setHasItems(true);\n      }\n      paramList.add(param);\n      continue;\n    }\n    boolean queryParam=!isRequestBody && !isPathVariable;\n    if (JavaClassValidateUtil.isCollection(fullTypeName) || JavaClassValidateUtil.isArray(fullTypeName)) {\n      String[] gicNameArr=DocClassUtil.getSimpleGicName(typeName);\n      String gicName=gicNameArr[0];\n      if (JavaClassValidateUtil.isArray(gicName)) {\n        gicName=gicName.substring(0,gicName.indexOf(\"[\"));\n      }\n      mockValue=JavaFieldUtil.createMockValue(paramsComments,paramName,gicName,gicName);\n      if (StringUtil.isNotEmpty(mockValue) && !mockValue.contains(\",\")) {\n        mockValue=StringUtils.join(mockValue,\",\",JavaFieldUtil.createMockValue(paramsComments,paramName,gicName,gicName));\n      }\n      JavaClass gicJavaClass=builder.getJavaProjectBuilder().getClassByName(gicName);\n      if (gicJavaClass.isEnum()) {\n        Object value=JavaClassUtil.getEnumValue(gicJavaClass,Boolean.TRUE);\n        ApiParam param=ApiParam.of().setField(paramName).setDesc(comment + \",[array of enum]\").setRequired(required).setPathParam(isPathVariable).setQueryParam(queryParam).setId(paramList.size() + 1).setEnumValues(JavaClassUtil.getEnumValues(gicJavaClass)).setEnumInfo(JavaClassUtil.getEnumInfo(gicJavaClass,builder)).setType(\"array\").setValue(String.valueOf(value));\n        paramList.add(param);\n        if (requestBodyCounter > 0) {\n          Map<String,Object> map=OpenApiSchemaUtil.arrayTypeSchema(gicName);\n          docJavaMethod.setRequestSchema(map);\n        }\n      }\n else       if (JavaClassValidateUtil.isPrimitive(gicName)) {\n        String shortSimple=DocClassUtil.processTypeNameForParams(gicName);\n        ApiParam param=ApiParam.of().setField(paramName).setDesc(comment + \",[array of \" + shortSimple+ \"]\").setRequired(required).setPathParam(isPathVariable).setQueryParam(queryParam).setId(paramList.size() + 1).setType(\"array\").setVersion(DocGlobalConstants.DEFAULT_VERSION).setValue(mockValue);\n        paramList.add(param);\n        if (requestBodyCounter > 0) {\n          Map<String,Object> map=OpenApiSchemaUtil.arrayTypeSchema(gicName);\n          docJavaMethod.setRequestSchema(map);\n        }\n      }\n else       if (JavaClassValidateUtil.isFile(gicName)) {\n        ApiParam param=ApiParam.of().setField(paramName).setType(DocGlobalConstants.PARAM_TYPE_FILE).setId(paramList.size() + 1).setQueryParam(true).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION).setHasItems(true).setDesc(comment + \"(array of file)\");\n        paramList.add(param);\n      }\n else {\n        if (requestBodyCounter > 0) {\n          paramList.addAll(ParamsBuildHelper.buildParams(gicNameArr[0],DocGlobalConstants.EMPTY,0,String.valueOf(required),Boolean.FALSE,new HashMap<>(),builder,groupClasses,0,Boolean.TRUE,null));\n        }\n      }\n    }\n else     if (JavaClassValidateUtil.isPrimitive(fullTypeName)) {\n      ApiParam param=ApiParam.of().setField(paramName).setType(DocClassUtil.processTypeNameForParams(simpleName)).setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setValue(mockValue).setDesc(comment.toString()).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n      paramList.add(param);\n      if (requestBodyCounter > 0) {\n        Map<String,Object> map=OpenApiSchemaUtil.primaryTypeSchema(simpleName);\n        docJavaMethod.setRequestSchema(map);\n      }\n    }\n else     if (JavaClassValidateUtil.isMap(fullTypeName)) {\n      log.warning(\"When using smart-doc, it is not recommended to use Map to receive parameters, Check it in \" + javaMethod.getDeclaringClass().getCanonicalName() + \"#\"+ javaMethod.getName());\n      if (JavaClassValidateUtil.isMap(typeName)) {\n        ApiParam apiParam=ApiParam.of().setField(paramName).setType(\"map\").setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setDesc(comment.toString()).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n        paramList.add(apiParam);\n        if (requestBodyCounter > 0) {\n          Map<String,Object> map=OpenApiSchemaUtil.mapTypeSchema(\"object\");\n          docJavaMethod.setRequestSchema(map);\n        }\n        continue;\n      }\n      String[] gicNameArr=DocClassUtil.getSimpleGicName(typeName);\n      if (JavaClassValidateUtil.isPrimitive(gicNameArr[1])) {\n        ApiParam apiParam=ApiParam.of().setField(paramName).setType(\"map\").setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setDesc(comment.toString()).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n        paramList.add(apiParam);\n        if (requestBodyCounter > 0) {\n          Map<String,Object> map=OpenApiSchemaUtil.mapTypeSchema(gicNameArr[1]);\n          docJavaMethod.setRequestSchema(map);\n        }\n      }\n else {\n        paramList.addAll(ParamsBuildHelper.buildParams(gicNameArr[1],DocGlobalConstants.EMPTY,0,String.valueOf(required),Boolean.FALSE,new HashMap<>(),builder,groupClasses,0,Boolean.FALSE,null));\n      }\n    }\n else     if (javaClass.isEnum()) {\n      String o=JavaClassUtil.getEnumParams(javaClass);\n      Object value=JavaClassUtil.getEnumValue(javaClass,isPathVariable || queryParam);\n      ApiParam param=ApiParam.of().setField(paramName).setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setValue(String.valueOf(value)).setType(\"enum\").setDesc(StringUtil.removeQuotes(o)).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION).setEnumInfo(JavaClassUtil.getEnumInfo(javaClass,builder)).setEnumValues(JavaClassUtil.getEnumValues(javaClass));\n      paramList.add(param);\n    }\n else {\n      paramList.addAll(ParamsBuildHelper.buildParams(typeName,DocGlobalConstants.EMPTY,0,String.valueOf(required),Boolean.FALSE,new HashMap<>(),builder,groupClasses,0,Boolean.FALSE,null));\n    }\n  }\n  return ApiParamTreeUtil.buildMethodReqParam(paramList,queryReqParamMap,pathReqParamMap,requestBodyCounter);\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/IRestDocTemplate.java",
        "Start": 23413,
        "Stop": 41300,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "requestParams"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Simplify the condition in the if statement",
                    "Change_Diff": "- if (typeName.contains(\"<\")) {\n+ if (typeName.contains(\"<\") && typeName.contains(\">\")) {",
                    "Description": "The condition `typeName.contains(\"<\")` checks if the string `typeName` contains the character `<`. However, this condition may incorrectly trigger if the string contains only the opening bracket `<` without the closing bracket `>`. Update the condition to also check if `typeName` contains the closing bracket `>`.",
                    "Start": 3,
                    "End": 3
                },
                {
                    "Improvement": "Use ternary operator to simplify assigning value to gicType",
                    "Change_Diff": "- if (typeName.contains(\"<\")) {\n    gicType = typeName.substring(typeName.indexOf(\"<\") + 1, typeName.lastIndexOf(\">\"));\n} else {\n    gicType = typeName;\n}\n+ gicType = typeName.contains(\"<\") ? typeName.substring(typeName.indexOf(\"<\") + 1, typeName.lastIndexOf(\">\")) : typeName;",
                    "Description": "The conditional assignment to `gicType` can be simplified using a ternary operator. Instead of using an if-else statement, the value of `gicType` can be assigned directly in one line using the ternary operator.",
                    "Start": 6,
                    "End": 10
                },
                {
                    "Improvement": "Remove redundant check for array",
                    "Change_Diff": "- if (gicType.contains(\"[\")) {\n    gicType = gicType.substring(0, gicType.indexOf(\"[\"));\n}",
                    "Description": "The if statement `if (gicType.contains(\"[\"))` checks if the string `gicType` contains the character `[`. However, this check is redundant since the substring `gicType.substring(0, gicType.indexOf(\"[\"))` will return the original string `gicType` if it does not contain the character `[`. Remove this unnecessary if statement.",
                    "Start": 13,
                    "End": 13
                },
                {
                    "Improvement": "Use StringUtils.substringAfterLast instead of manually subtracting from the start index",
                    "Change_Diff": "- return gicType.substring(gicType.lastIndexOf(\".\") + 1).toLowerCase();\n+ return StringUtils.substringAfterLast(gicType, \".\").toLowerCase();",
                    "Description": "Instead of manually subtracting from the start index to extract the substring after the last dot (`.`), use the `StringUtils.substringAfterLast` method from the Apache Commons Lang library. This method provides a more concise and readable solution.",
                    "Start": 15,
                    "End": 15
                }
            ],
            "Final code": "private static String getType(String typeName) {\n    String gicType;\n    if (typeName.contains(\"<\") && typeName.contains(\">\")) {\n        gicType = typeName.substring(typeName.indexOf(\"<\") + 1, typeName.lastIndexOf(\">\")\n    } else {\n        gicType = typeName;\n    }\n    gicType = typeName.contains(\"<\") ? typeName.substring(typeName.indexOf(\"<\") + 1, typeName.lastIndexOf(\">\") : typeName;\n    return StringUtils.substringAfterLast(gicType, \".\").toLowerCase();\n}"
        }],
        "Old_Method": "private static String getType(String typeName){\n  String gicType;\n  if (typeName.contains(\"<\")) {\n    gicType=typeName.substring(typeName.indexOf(\"<\") + 1,typeName.lastIndexOf(\">\"));\n  }\n else {\n    gicType=typeName;\n  }\n  if (gicType.contains(\"[\")) {\n    gicType=gicType.substring(0,gicType.indexOf(\"[\"));\n  }\n  return gicType.substring(gicType.lastIndexOf(\".\") + 1).toLowerCase();\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/utils/TornaUtil.java",
        "Start": 17508,
        "Stop": 17998,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "getType"
    },
    {
        "Method_Improvements": [{
            "Improvements": [{
                "Improvement": "Use Java 8 streams instead of traditional for loops",
                "Change_Diff": "- for (ApiParam apiParam : apiParamList) {\n+ apiParamList.stream().forEach(apiParam -> {",
                "Description": "Instead of using traditional for loops, use Java 8 streams to iterate over `apiParamList` and perform operations.",
                "Start": 3,
                "End": 5
            }],
            "Final code": "public static List<ApiParam> apiParamToTree(List<ApiParam> apiParamList) {\n  if (CollectionUtil.isEmpty(apiParamList)) {\n    return new ArrayList<>(0);\n  }\n\n  List<ApiParam> params = apiParamList.stream()\n      .peek(apiParam -> apiParam.setField(apiParam.getField().replaceAll(DocGlobalConstants.PARAM_PREFIX,\"\").replaceAll(\"&nbsp;\",\"\")))\n      .filter(apiParam -> apiParam.getPid() == 0)\n      .collect(Collectors.toList());\n\n  params.forEach(apiParam -> apiParam.setChildren(getChild(apiParam.getId(), apiParamList, 0)));\n\n  return params;\n}"
        }],
        "Old_Method": "public static List<ApiParam> apiParamToTree(List<ApiParam> apiParamList){\n  if (CollectionUtil.isEmpty(apiParamList)) {\n    return new ArrayList<>(0);\n  }\n  List<ApiParam> params=new ArrayList<>();\n  for (  ApiParam apiParam : apiParamList) {\n    apiParam.setField(apiParam.getField().replaceAll(DocGlobalConstants.PARAM_PREFIX,\"\").replaceAll(\"&nbsp;\",\"\"));\n    if (apiParam.getPid() == 0) {\n      params.add(apiParam);\n    }\n  }\n  for (  ApiParam apiParam : params) {\n    apiParam.setChildren(getChild(apiParam.getId(),apiParamList,0));\n  }\n  return params;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/utils/ApiParamTreeUtil.java",
        "Start": 1284,
        "Stop": 2064,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "apiParamToTree"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Refactor the method to improve readability and maintainability",
                    "Change_Diff": "- private ApiMethodReqParam requestParams(final DocJavaMethod docJavaMethod,ProjectDocConfigBuilder builder){\n+ private ApiMethodReqParam requestParams(final DocJavaMethod docJavaMethod, ProjectDocConfigBuilder builder) {",
                    "Description": "Add a space before the opening parenthesis in the method signature to improve readability.",
                    "Start": 1,
                    "End": 1
                },
                {
                    "Improvement": "Extract complex code inside the method into smaller helper methods",
                    "Change_Diff": "- List<DocJavaParameter> parameterList = getJavaParameterList(builder, docJavaMethod, null);\n+ List<DocJavaParameter> parameterList = getJavaParameterList(builder, docJavaMethod, null);\n+ if (parameterList.isEmpty()) {\n+   return buildApiMethodReqParamEmpty();\n+ }\n\n+ List<ApiParam> paramList = buildApiParamList(parameterList, isStrict, javaMethod, className, paramTagMap, paramsComments, constantsMap, requestFieldToUnderline, ignoreSets);\n\n+ return buildApiMethodReqParamResponse(paramList);",
                    "Description": "Extract the code to build the parameter list and return the `ApiMethodReqParam` object into smaller helper methods.",
                    "Start": 14,
                    "End": 41
                },
                {
                    "Improvement": "Refactor the code to remove unnecessary variables and conditions",
                    "Change_Diff": "- List<ApiParam> queryParams = new ArrayList<>();\n+ List<ApiParam> queryParams = new ArrayList<>(paramList.size());\n\n for (ApiParam param : paramList) {\n   param.setValue(StringUtil.removeDoubleQuotes(param.getValue()));\n\n   if (param.isPathParam()) {\n     param.setId(pathParams.size() + 1);\n     pathParams.add(param);\n   }\n   else if (param.isQueryParam()) {\n     param.setId(queryParams.size() + 1);\n-     queryParams.add(param);\n   }\n   else {\n     param.setId(bodyParams.size() + 1);\n     bodyParams.add(param);\n   }\n }\n\n- return ApiMethodReqParam.builder()\n-     .setRequestParams(bodyParams)\n-     .setPathParams(pathParams)\n-     .setQueryParams(queryParams);\n+ return buildApiMethodReqParamResponse(queryParams, bodyParams, pathParams);",
                    "Description": "Remove the unnecessary creation of `ArrayList` and unnecessary conditions when adding parameters to `queryParams` and `bodyParams` lists.",
                    "Start": 78,
                    "End": 97
                }
            ],
            "Final code": "private ApiMethodReqParam requestParams(final DocJavaMethod docJavaMethod, ProjectDocConfigBuilder builder) {\n  List<DocJavaParameter> parameterList = getJavaParameterList(builder, docJavaMethod, null);\n  if (parameterList.isEmpty()) {\n    return buildApiMethodReqParamEmpty();\n  }\n\n  List<ApiParam> paramList = buildApiParamList(parameterList, isStrict, javaMethod, className, paramTagMap, paramsComments, constantsMap, requestFieldToUnderline, ignoreSets);\n\n  return buildApiMethodReqParamResponse(paramList);\n}\n\nprivate ApiMethodReqParam buildApiMethodReqParamEmpty() {\n  return ApiMethodReqParam.builder()\n      .setPathParams(new ArrayList<>(0))\n      .setQueryParams(new ArrayList<>(0))\n      .setRequestParams(new ArrayList<>(0));\n}\n\nprivate List<ApiParam> buildApiParamList(List<DocJavaParameter> parameterList, boolean isStrict, JavaMethod javaMethod, String className, Map<String, String> paramTagMap, Map<String, String> paramsComments, Map<String, String> constantsMap, boolean requestFieldToUnderline, Set<String> ignoreSets) {\n  List<ApiParam> paramList = new ArrayList<>();\n\n  // existing code for building paramList\n\n  return paramList;\n}\n\nprivate ApiMethodReqParam buildApiMethodReqParamResponse(List<ApiParam> paramList) {\n  List<ApiParam> pathParams = new ArrayList<>();\n  List<ApiParam> queryParams = new ArrayList<>(paramList.size());\n  List<ApiParam> bodyParams = new ArrayList<>();\n\n  for (ApiParam param : paramList) {\n    param.setValue(StringUtil.removeDoubleQuotes(param.getValue()));\n\n    if (param.isPathParam()) {\n      param.setId(pathParams.size() + 1);\n      pathParams.add(param);\n    }\n    else if (param.isQueryParam()) {\n      param.setId(queryParams.size() + 1);\n      queryParams.add(param);\n    }\n    else {\n      param.setId(bodyParams.size() + 1);\n      bodyParams.add(param);\n    }\n  }\n\n  return ApiMethodReqParam.builder()\n      .setRequestParams(bodyParams)\n      .setPathParams(pathParams)\n      .setQueryParams(queryParams);\n}"
        }],
        "Old_Method": "/** \n * build request params\n * @param docJavaMethod docJavaMethod\n * @param builder       builder\n * @return ApiMethodReqParam\n */\nprivate ApiMethodReqParam requestParams(final DocJavaMethod docJavaMethod,ProjectDocConfigBuilder builder){\n  List<ApiParam> paramList=new ArrayList<>();\n  List<DocJavaParameter> parameterList=getJavaParameterList(builder,docJavaMethod,null);\n  if (parameterList.isEmpty()) {\n    return ApiMethodReqParam.builder().setPathParams(new ArrayList<>(0)).setQueryParams(paramList).setRequestParams(new ArrayList<>(0));\n  }\n  boolean isStrict=builder.getApiConfig().isStrict();\n  JavaMethod javaMethod=docJavaMethod.getJavaMethod();\n  String className=javaMethod.getDeclaringClass().getCanonicalName();\n  Map<String,String> paramTagMap=docJavaMethod.getParamTagMap();\n  Map<String,String> paramsComments=docJavaMethod.getParamsComments();\n  Map<String,String> constantsMap=builder.getConstantsMap();\n  boolean requestFieldToUnderline=builder.getApiConfig().isRequestFieldToUnderline();\n  Set<String> ignoreSets=ignoreParamsSets(javaMethod);\n  out:   for (  DocJavaParameter apiParameter : parameterList) {\n    JavaParameter parameter=apiParameter.getJavaParameter();\n    String paramName=parameter.getName();\n    if (ignoreSets.contains(paramName)) {\n      continue;\n    }\n    String typeName=apiParameter.getGenericCanonicalName();\n    String simpleName=apiParameter.getTypeValue().toLowerCase();\n    String fullTypeName=apiParameter.getFullyQualifiedName();\n    String simpleTypeName=apiParameter.getTypeValue();\n    if (!paramTagMap.containsKey(paramName) && JavaClassValidateUtil.isPrimitive(fullTypeName) && isStrict) {\n      throw new RuntimeException(\"ERROR: Unable to find javadoc @QueryParam for actual param \\\"\" + paramName + \"\\\" in method \"+ javaMethod.getName()+ \" from \"+ className);\n    }\n    if (requestFieldToUnderline) {\n      paramName=StringUtil.camelToUnderline(paramName);\n    }\n    String mockValue=JavaFieldUtil.createMockValue(paramsComments,paramName,typeName,simpleTypeName);\n    JavaClass javaClass=builder.getJavaProjectBuilder().getClassByName(fullTypeName);\n    List<JavaAnnotation> annotations=parameter.getAnnotations();\n    Set<String> groupClasses=JavaClassUtil.getParamGroupJavaClass(annotations,builder.getJavaProjectBuilder());\n    StringBuilder comment=new StringBuilder(this.paramCommentResolve(paramTagMap.get(paramName)));\n    boolean isPathVariable=false;\n    boolean isRequestBody=false;\n    String strRequired=\"false\";\n    if (CollectionUtil.isNotEmpty(annotations)) {\n      for (      JavaAnnotation annotation : annotations) {\n        String annotationName=annotation.getType().getFullyQualifiedName();\n        if (JakartaJaxrsAnnotations.JAX_HEADER_PARAM_FULLY.equals(annotationName) || JAXRSAnnotations.JAX_HEADER_PARAM_FULLY.equals(annotationName)) {\n          continue out;\n        }\n        if (JakartaJaxrsAnnotations.JAX_DEFAULT_VALUE_FULLY.equals(annotationName) || JAXRSAnnotations.JAX_DEFAULT_VALUE_FULLY.equals(annotationName)) {\n          mockValue=StringUtil.removeQuotes(DocUtil.getRequestHeaderValue(annotation));\n          mockValue=DocUtil.handleConstants(constantsMap,mockValue);\n        }\n        if (JakartaJaxrsAnnotations.JAX_PATH_PARAM_FULLY.equals(annotationName) || JakartaJaxrsAnnotations.JAXB_REST_PATH_FULLY.equals(annotationName) || JAXRSAnnotations.JAX_PATH_PARAM_FULLY.equals(annotationName)) {\n          isPathVariable=true;\n          strRequired=\"true\";\n        }\n        if (JavaClassValidateUtil.isJSR303Required(annotation.getType().getValue())) {\n          strRequired=\"true\";\n        }\n      }\n      comment.append(JavaFieldUtil.getJsrComment(annotations));\n    }\n else {\n      isRequestBody=true;\n    }\n    boolean required=Boolean.parseBoolean(strRequired);\n    boolean queryParam=!isRequestBody && !isPathVariable;\n    if (JavaClassValidateUtil.isCollection(fullTypeName) || JavaClassValidateUtil.isArray(fullTypeName)) {\n      String[] gicNameArr=DocClassUtil.getSimpleGicName(typeName);\n      String gicName=gicNameArr[0];\n      if (JavaClassValidateUtil.isArray(gicName)) {\n        gicName=gicName.substring(0,gicName.indexOf(\"[\"));\n      }\n      JavaClass gicJavaClass=builder.getJavaProjectBuilder().getClassByName(gicName);\n      if (gicJavaClass.isEnum()) {\n        Object value=JavaClassUtil.getEnumValue(gicJavaClass,Boolean.TRUE);\n        ApiParam param=ApiParam.of().setField(paramName).setDesc(comment + \",[array of enum]\").setRequired(required).setPathParam(isPathVariable).setQueryParam(queryParam).setId(paramList.size() + 1).setType(\"array\").setValue(String.valueOf(value));\n        paramList.add(param);\n      }\n else       if (JavaClassValidateUtil.isPrimitive(gicName)) {\n        String shortSimple=DocClassUtil.processTypeNameForParams(gicName);\n        ApiParam param=ApiParam.of().setField(paramName).setDesc(comment + \",[array of \" + shortSimple+ \"]\").setRequired(required).setPathParam(isPathVariable).setQueryParam(queryParam).setId(paramList.size() + 1).setType(\"array\").setValue(DocUtil.getValByTypeAndFieldName(gicName,paramName));\n        paramList.add(param);\n      }\n else {\n        int id=paramList.size() + 1;\n        ApiParam param=ApiParam.of().setField(paramName).setDesc(comment + \",[array of object]\").setRequired(required).setPathParam(isPathVariable).setQueryParam(queryParam).setId(id).setType(\"array\");\n        paramList.add(param);\n        List<ApiParam> apiParamList=ParamsBuildHelper.buildParams(typeName,\"└─\",1,\"true\",Boolean.FALSE,new HashMap<>(),builder,groupClasses,id,Boolean.FALSE,null);\n        paramList.addAll(apiParamList);\n      }\n    }\n else     if (JavaClassValidateUtil.isPrimitive(fullTypeName)) {\n      ApiParam param=ApiParam.of().setField(paramName).setType(DocClassUtil.processTypeNameForParams(simpleName)).setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setValue(mockValue).setDesc(comment.toString()).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n      paramList.add(param);\n    }\n else     if (JavaClassValidateUtil.isMap(fullTypeName)) {\n      log.warning(\"When using smart-doc, it is not recommended to use Map to receive parameters, Check it in \" + javaMethod.getDeclaringClass().getCanonicalName() + \"#\"+ javaMethod.getName());\n      if (JavaClassValidateUtil.isMap(typeName)) {\n        ApiParam apiParam=ApiParam.of().setField(paramName).setType(\"map\").setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setDesc(comment.toString()).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n        paramList.add(apiParam);\n        continue;\n      }\n      String[] gicNameArr=DocClassUtil.getSimpleGicName(typeName);\n      if (JavaClassValidateUtil.isPrimitive(gicNameArr[1])) {\n        ApiParam apiParam=ApiParam.of().setField(paramName).setType(\"map\").setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setDesc(comment.toString()).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION);\n        paramList.add(apiParam);\n      }\n else {\n        paramList.addAll(ParamsBuildHelper.buildParams(gicNameArr[1],DocGlobalConstants.EMPTY,0,\"true\",Boolean.FALSE,new HashMap<>(),builder,groupClasses,0,Boolean.FALSE,null));\n      }\n    }\n else     if (JavaClassValidateUtil.isFile(typeName)) {\n      ApiParam param=ApiParam.of().setField(paramName).setType(\"file\").setId(paramList.size() + 1).setQueryParam(true).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION).setDesc(comment.toString());\n      if (typeName.contains(\"[]\") || typeName.endsWith(\">\")) {\n        comment.append(\"(array of file)\");\n        param.setDesc(comment.toString());\n        param.setHasItems(true);\n      }\n      paramList.add(param);\n    }\n else     if (javaClass.isEnum()) {\n      String o=JavaClassUtil.getEnumParams(javaClass);\n      Object value=JavaClassUtil.getEnumValue(javaClass,true);\n      ApiParam param=ApiParam.of().setField(paramName).setId(paramList.size() + 1).setPathParam(isPathVariable).setQueryParam(queryParam).setValue(String.valueOf(value)).setType(\"enum\").setDesc(StringUtil.removeQuotes(o)).setRequired(required).setVersion(DocGlobalConstants.DEFAULT_VERSION).setEnumValues(JavaClassUtil.getEnumValues(javaClass));\n      paramList.add(param);\n    }\n else {\n      paramList.addAll(ParamsBuildHelper.buildParams(typeName,DocGlobalConstants.EMPTY,0,\"true\",Boolean.FALSE,new HashMap<>(),builder,groupClasses,0,Boolean.FALSE,null));\n    }\n  }\n  List<ApiParam> pathParams=new ArrayList<>();\n  List<ApiParam> queryParams=new ArrayList<>();\n  List<ApiParam> bodyParams=new ArrayList<>();\n  for (  ApiParam param : paramList) {\n    param.setValue(StringUtil.removeDoubleQuotes(param.getValue()));\n    if (param.isPathParam()) {\n      param.setId(pathParams.size() + 1);\n      pathParams.add(param);\n    }\n else     if (param.isQueryParam()) {\n      param.setId(queryParams.size() + 1);\n      queryParams.add(param);\n    }\n else {\n      param.setId(bodyParams.size() + 1);\n      bodyParams.add(param);\n    }\n  }\n  return ApiMethodReqParam.builder().setRequestParams(bodyParams).setPathParams(pathParams).setQueryParams(queryParams);\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/JaxrsDocBuildTemplate.java",
        "Start": 14475,
        "Stop": 27140,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "requestParams"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use enhanced for-loop instead of traditional for-loop",
                    "Change_Diff": "- for (JavaMethod method : methods) {\n+ for (DocJavaMethod docJavaMethod : docJavaMethods) {",
                    "Description": "Instead of using a traditional for loop to iterate over `methods`, use an enhanced for-loop.",
                    "Start": 59,
                    "End": 59
                },
                {
                    "Improvement": "Extract method to remove code duplication",
                    "Change_Diff": "- docJavaMethods.add(convertToDocJavaMethod(apiConfig,projectBuilder,method,null));\n+ docJavaMethods.add(buildDocJavaMethod(apiConfig,projectBuilder,method,null));",
                    "Description": "Extract the logic of converting a `JavaMethod` to a `DocJavaMethod` into a separate method to remove code duplication.",
                    "Start": 67,
                    "End": 67
                }
            ],
            "Final code": "default List<ApiMethodDoc> buildEntryPointMethod(final JavaClass cls, ApiConfig apiConfig, ProjectDocConfigBuilder projectBuilder, FrameworkAnnotations frameworkAnnotations, List<ApiReqParam> configApiReqParams, IRequestMappingHandler baseMappingHandler, IHeaderHandler headerHandler) {\n    ...\n    List<DocJavaMethod> docJavaMethods = new ArrayList<>(methods.size());\n    for (JavaMethod method : methods) {\n        ...\n        if (needAllMethods || filterMethods.contains(method.getName())) {\n            docJavaMethods.add(buildDocJavaMethod(apiConfig, projectBuilder, method, null));\n        }\n    }\n    docJavaMethods.addAll(getParentsClassMethods(apiConfig,projectBuilder,cls));\n    ...\n}\n\nprivate DocJavaMethod buildDocJavaMethod(ApiConfig apiConfig, ProjectDocConfigBuilder projectBuilder,JavaMethod method,Map<String, JavaType> actualTypesMap) {\n    return convertToDocJavaMethod(apiConfig, projectBuilder, method,actualTypesMap);\n}"
        }],
        "Old_Method": "default List<ApiMethodDoc> buildEntryPointMethod(final JavaClass cls,ApiConfig apiConfig,ProjectDocConfigBuilder projectBuilder,FrameworkAnnotations frameworkAnnotations,List<ApiReqParam> configApiReqParams,IRequestMappingHandler baseMappingHandler,IHeaderHandler headerHandler){\n  String clazName=cls.getCanonicalName();\n  boolean paramsDataToTree=projectBuilder.getApiConfig().isParamsDataToTree();\n  String group=JavaClassUtil.getClassTagsValue(cls,DocTags.GROUP,Boolean.TRUE);\n  List<JavaAnnotation> classAnnotations=this.getClassAnnotations(cls,frameworkAnnotations);\n  String baseUrl=\"\";\n  String classMediaType=null;\n  Map<String,MappingAnnotation> mappingAnnotationMap=frameworkAnnotations.getMappingAnnotations();\n  for (  JavaAnnotation annotation : classAnnotations) {\n    String annotationName=annotation.getType().getValue();\n    MappingAnnotation mappingAnnotation=mappingAnnotationMap.get(annotationName);\n    if (Objects.isNull(mappingAnnotation)) {\n      continue;\n    }\n    if (CollectionUtil.isNotEmpty(mappingAnnotation.getPathProps())) {\n      baseUrl=StringUtil.removeQuotes(DocUtil.getPathUrl(annotation,mappingAnnotation.getPathProps().toArray(new String[0])));\n    }\n    if (classMediaType == null) {\n      Object consumes=annotation.getNamedParameter(mappingAnnotation.getConsumesProp());\n      if (consumes != null) {\n        classMediaType=consumes.toString();\n      }\n    }\n  }\n  Set<String> filterMethods=DocUtil.findFilterMethods(clazName);\n  boolean needAllMethods=filterMethods.contains(DocGlobalConstants.DEFAULT_FILTER_METHOD);\n  List<JavaMethod> methods=cls.getMethods();\n  List<DocJavaMethod> docJavaMethods=new ArrayList<>(methods.size());\n  for (  JavaMethod method : methods) {\n    if (method.isPrivate() || DocUtil.isMatch(apiConfig.getPackageExcludeFilters(),clazName + \".\" + method.getName())) {\n      continue;\n    }\n    if (Objects.nonNull(method.getTagByName(IGNORE))) {\n      continue;\n    }\n    if (needAllMethods || filterMethods.contains(method.getName())) {\n      docJavaMethods.add(convertToDocJavaMethod(apiConfig,projectBuilder,method,null));\n    }\n  }\n  docJavaMethods.addAll(getParentsClassMethods(apiConfig,projectBuilder,cls));\n  List<JavaType> implClasses=cls.getImplements();\n  for (  JavaType type : implClasses) {\n    JavaClass javaClass=(JavaClass)type;\n    Map<String,JavaType> actualTypesMap=JavaClassUtil.getActualTypesMap(javaClass);\n    for (    JavaMethod method : javaClass.getMethods()) {\n      if (method.isDefault()) {\n        docJavaMethods.add(convertToDocJavaMethod(apiConfig,projectBuilder,method,actualTypesMap));\n      }\n    }\n  }\n  if (apiConfig.getCustomJavaMethodHandler() != null) {\n    docJavaMethods=apiConfig.getCustomJavaMethodHandler().apply(cls,docJavaMethods);\n  }\n  List<ApiMethodDoc> methodDocList=new ArrayList<>(methods.size());\n  int methodOrder=0;\n  for (  DocJavaMethod docJavaMethod : docJavaMethods) {\n    JavaMethod method=docJavaMethod.getJavaMethod();\n    RequestMapping requestMapping=baseMappingHandler.handle(projectBuilder,baseUrl,method,frameworkAnnotations,(javaClass,mapping) -> this.requestMappingPostProcess(javaClass,method,mapping));\n    if (Objects.isNull(requestMapping)) {\n      continue;\n    }\n    if (Objects.isNull(requestMapping.getShortUrl())) {\n      continue;\n    }\n    ApiMethodDoc apiMethodDoc=new ApiMethodDoc();\n    String mediaType=requestMapping.getMediaType();\n    if (Objects.nonNull(mediaType)) {\n      apiMethodDoc.setContentType(MediaType.valueOf(mediaType));\n    }\n else     if (Objects.nonNull(classMediaType)) {\n      apiMethodDoc.setContentType(MediaType.valueOf(classMediaType));\n    }\n    apiMethodDoc.setDownload(docJavaMethod.isDownload());\n    apiMethodDoc.setPage(docJavaMethod.getPage());\n    apiMethodDoc.setGroup(group);\n    apiMethodDoc.setVersion(docJavaMethod.getVersion());\n    if (Objects.nonNull(docJavaMethod.getGroup())) {\n      apiMethodDoc.setGroup(docJavaMethod.getGroup());\n    }\n    List<DocletTag> tags=method.getTagsByName(DocTags.TAG);\n    apiMethodDoc.setTags(tags.stream().map(DocletTag::getValue).toArray(String[]::new));\n    methodOrder++;\n    apiMethodDoc.setOrder(methodOrder);\n    apiMethodDoc.setName(method.getName());\n    String common=method.getComment();\n    if (StringUtil.isEmpty(common)) {\n      common=JavaClassUtil.getSameSignatureMethodCommonFromInterface(cls,method);\n    }\n    apiMethodDoc.setDesc(common);\n    apiMethodDoc.setAuthor(docJavaMethod.getAuthor());\n    apiMethodDoc.setDetail(docJavaMethod.getDetail());\n    String methodUid=DocUtil.generateId(clazName + method.getName() + methodOrder);\n    apiMethodDoc.setMethodId(methodUid);\n    List<ApiReqParam> apiReqHeaders=headerHandler.handle(method,projectBuilder);\n    apiReqHeaders=apiReqHeaders.stream().filter(param -> DocUtil.filterPath(requestMapping,param)).collect(Collectors.toList());\n    apiMethodDoc.setType(requestMapping.getMethodType());\n    apiMethodDoc.setUrl(requestMapping.getUrl());\n    apiMethodDoc.setServerUrl(projectBuilder.getServerUrl());\n    apiMethodDoc.setPath(requestMapping.getShortUrl());\n    apiMethodDoc.setDeprecated(requestMapping.isDeprecated());\n    final List<ApiReqParam> apiReqParamList=configApiReqParams.stream().filter(param -> DocUtil.filterPath(requestMapping,param)).collect(Collectors.toList());\n    ApiMethodReqParam apiMethodReqParam=requestParams(docJavaMethod,projectBuilder,apiReqParamList,frameworkAnnotations);\n    apiMethodDoc.setPathParams(apiMethodReqParam.getPathParams());\n    apiMethodDoc.setQueryParams(apiMethodReqParam.getQueryParams());\n    apiMethodDoc.setRequestParams(apiMethodReqParam.getRequestParams());\n    if (paramsDataToTree) {\n      this.convertParamsDataToTree(apiMethodDoc);\n    }\n    List<ApiReqParam> allApiReqHeaders;\n    final Map<String,List<ApiReqParam>> reqParamMap=configApiReqParams.stream().collect(Collectors.groupingBy(ApiReqParam::getParamIn));\n    final List<ApiReqParam> headerParamList=reqParamMap.getOrDefault(ApiReqParamInTypeEnum.HEADER.getValue(),Collections.emptyList());\n    allApiReqHeaders=Stream.of(headerParamList,apiReqHeaders).filter(Objects::nonNull).flatMap(Collection::stream).distinct().filter(param -> DocUtil.filterPath(requestMapping,param)).collect(Collectors.toList());\n    apiMethodDoc.setHeaders(this.createDocRenderHeaders(allApiReqHeaders,apiConfig.isAdoc()));\n    apiMethodDoc.setRequestHeaders(allApiReqHeaders);\n    String path=apiMethodDoc.getPath().split(\";\")[0];\n    String pathUrl=DocUtil.formatPathUrl(path);\n    List<ApiParam> pathParams=apiMethodDoc.getPathParams();\n    Iterator<ApiParam> pathIterator=pathParams.iterator();\n    while (pathIterator.hasNext()) {\n      ApiParam next=pathIterator.next();\n      String pathKey=\"{\" + next.getField() + \"}\";\n      if (!pathUrl.contains(pathKey)) {\n        pathIterator.remove();\n      }\n    }\n    ApiRequestExample requestExample=buildReqJson(docJavaMethod,apiMethodDoc,requestMapping.getMethodType(),projectBuilder,frameworkAnnotations);\n    String requestJson=requestExample.getExampleBody();\n    apiMethodDoc.setRequestExample(requestExample);\n    apiMethodDoc.setRequestUsage(requestJson == null ? requestExample.getUrl() : requestJson);\n    String responseValue=DocUtil.getNormalTagComments(method,DocTags.API_RESPONSE,cls.getName());\n    if (StringUtil.isNotEmpty(responseValue)) {\n      responseValue=responseValue.replaceAll(\"<br>\",\"\");\n      apiMethodDoc.setResponseUsage(JsonUtil.toPrettyFormat(responseValue));\n    }\n else {\n      apiMethodDoc.setResponseUsage(JsonBuildHelper.buildReturnJson(docJavaMethod,projectBuilder));\n    }\n    List<ApiParam> responseParams=buildReturnApiParams(docJavaMethod,projectBuilder);\n    if (paramsDataToTree) {\n      responseParams=ApiParamTreeUtil.apiParamToTree(responseParams);\n    }\n    apiMethodDoc.setReturnSchema(docJavaMethod.getReturnSchema());\n    apiMethodDoc.setRequestSchema(docJavaMethod.getRequestSchema());\n    apiMethodDoc.setResponseParams(responseParams);\n    TornaUtil.setTornaArrayTags(docJavaMethod.getJavaMethod(),apiMethodDoc,apiConfig);\n    methodDocList.add(apiMethodDoc);\n  }\n  return methodDocList;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/IRestDocTemplate.java",
        "Start": 13094,
        "Stop": 23407,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "buildEntryPointMethod"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract method for getting fully qualified name",
                    "Change_Diff": "+ private String getFullyQualifiedName(JavaType javaType, Map<String,String> replacementMap, String commentClass) {\n+     String fullTypeName = javaType.getFullyQualifiedName();\n+\n+     if (Objects.nonNull(commentClass) && commentClass.contains(IGNORE)) {\n+         return null;\n+     }\n+\n+     String rewriteClassName = getRewriteClassName(replacementMap, fullTypeName, commentClass);\n+\n+     if (JavaClassValidateUtil.isClassName(rewriteClassName)) {\n+         return rewriteClassName;\n+     }\n+\n+     return DocClassUtil.getSimpleName(rewriteClassName);\n+ }",
                    "Description": "Extract the logic for getting the fully qualified name of a Java type into a separate method, `getFullyQualifiedName()`. This improves readability and reduces duplicated code.",
                    "Start": 10,
                    "End": 35
                },
                {
                    "Improvement": "Don't use Objects.nonNull() for null check",
                    "Change_Diff": "- if (Objects.nonNull(actualTypesMap) && Objects.nonNull(actualTypesMap.get(javaType.getCanonicalName()))) {\n+ if (actualTypesMap != null && actualTypesMap.get(javaType.getCanonicalName()) != null) {",
                    "Description": "Instead of using `Objects.nonNull()` from the java.util.Objects class for null check, use a simple comparison against null (`!= null`) for better readability.",
                    "Start": 25,
                    "End": 25
                },
                {
                    "Improvement": "Remove unnecessary if condition for rewriting class name",
                    "Change_Diff": "- if (JavaClassValidateUtil.isClassName(rewriteClassName)) {\n-     genericCanonicalName = rewriteClassName;\n-     fullTypeName = DocClassUtil.getSimpleName(rewriteClassName);\n- }",
                    "Description": "Remove the if condition for checking if the `rewriteClassName` is a valid class name since that check is redundant.",
                    "Start": 35,
                    "End": 38
                },
                {
                    "Improvement": "Simplify if condition for collection and array types",
                    "Change_Diff": "- if (JavaClassValidateUtil.isCollection(fullTypeName) || JavaClassValidateUtil.isArray(fullTypeName)) {\n-     if (JavaClassValidateUtil.isCollection(genericCanonicalName)) {\n-         genericCanonicalName = genericCanonicalName + \"<T>\";\n-     }\n- }",
                    "Description": "Simplify the if condition for checking if the Java type is a collection or array type and updating the `genericCanonicalName` accordingly. This can be simplified to a single if condition.",
                    "Start": 39,
                    "End": 42
                }
            ],
            "Final code": "private String getFullyQualifiedName(JavaType javaType, Map<String,String> replacementMap, String commentClass) {\n    String fullTypeName = javaType.getFullyQualifiedName();\n\n    if (Objects.nonNull(commentClass) && commentClass.contains(IGNORE)) {\n        return null;\n    }\n\n    String rewriteClassName = getRewriteClassName(replacementMap, fullTypeName, commentClass);\n\n    if (JavaClassValidateUtil.isClassName(rewriteClassName)) {\n        return rewriteClassName;\n    }\n\n    return DocClassUtil.getSimpleName(rewriteClassName);\n}\n\ndefault List<DocJavaParameter> getJavaParameterList(ProjectDocConfigBuilder builder, final DocJavaMethod docJavaMethod, FrameworkAnnotations frameworkAnnotations) {\n    JavaMethod javaMethod = docJavaMethod.getJavaMethod();\n    Map<String, String> replacementMap = builder.getReplaceClassMap();\n    Map<String, String> paramTagMap = docJavaMethod.getParamTagMap();\n    List<JavaParameter> parameterList = javaMethod.getParameters();\n\n    if (parameterList.isEmpty()) {\n        return new ArrayList<>(0);\n    }\n\n    Set<String> ignoreSets = ignoreParamsSets(javaMethod);\n    List<DocJavaParameter> apiJavaParameterList = new ArrayList<>(parameterList.size());\n    Map<String, JavaType> actualTypesMap = docJavaMethod.getActualTypesMap();\n\n    for (JavaParameter parameter : parameterList) {\n        String paramName = parameter.getName();\n\n        if (ignoreSets.contains(paramName)) {\n            continue;\n        }\n\n        DocJavaParameter apiJavaParameter = new DocJavaParameter();\n        apiJavaParameter.setJavaParameter(parameter);\n        JavaType javaType = parameter.getType();\n\n        if (actualTypesMap != null && actualTypesMap.get(javaType.getCanonicalName()) != null) {\n            javaType = actualTypesMap.get(javaType.getCanonicalName());\n        }\n\n        apiJavaParameter.setTypeValue(javaType.getValue());\n        String genericCanonicalName = javaType.getGenericCanonicalName();\n        String fullTypeName = javaType.getFullyQualifiedName();\n        String commentClass = paramTagMap.get(paramName);\n\n        if (commentClass != null && commentClass.contains(IGNORE)) {\n            continue;\n        }\n\n        String rewriteClassName = getRewriteClassName(replacementMap, fullTypeName, commentClass);\n\n        if (JavaClassValidateUtil.isClassName(rewriteClassName)) {\n            genericCanonicalName = rewriteClassName;\n            fullTypeName = DocClassUtil.getSimpleName(rewriteClassName);\n        }\n\n        if (JavaClassValidateUtil.isMvcIgnoreParams(genericCanonicalName, builder.getApiConfig().getIgnoreRequestParams())) {\n            continue;\n        }\n\n        fullTypeName = DocClassUtil.rewriteRequestParam(fullTypeName);\n        genericCanonicalName = DocClassUtil.rewriteRequestParam(genericCanonicalName);\n        List<JavaAnnotation> annotations = parameter.getAnnotations();\n        apiJavaParameter.setAnnotations(annotations);\n\n        for (JavaAnnotation annotation : annotations) {\n            String annotationName = annotation.getType().getValue();\n\n            if (frameworkAnnotations != null && frameworkAnnotations.getRequestBodyAnnotation().getAnnotationName().equals(annotationName)) {\n                if (builder.getApiConfig().getRequestBodyAdvice() != null && javaMethod.getTagByName(IGNORE_REQUEST_BODY_ADVICE) == null) {\n                    String requestBodyAdvice = builder.getApiConfig().getRequestBodyAdvice().getClassName();\n                    fullTypeName = requestBodyAdvice;\n                    genericCanonicalName = requestBodyAdvice + \"<\" + genericCanonicalName + \">\";\n                }\n            }\n        }\n\n        if (JavaClassValidateUtil.isCollection(fullTypeName) || JavaClassValidateUtil.isArray(fullTypeName)) {\n            if (JavaClassValidateUtil.isCollection(genericCanonicalName)) {\n                genericCanonicalName = genericCanonicalName + \"<T>\";\n            }\n        }\n\n        apiJavaParameter.setGenericCanonicalName(genericCanonicalName);\n        apiJavaParameter.setFullyQualifiedName(fullTypeName);\n        apiJavaParameterList.add(apiJavaParameter);\n    }\n\n    return apiJavaParameterList;\n}"
        }],
        "Old_Method": "default List<DocJavaParameter> getJavaParameterList(ProjectDocConfigBuilder builder,final DocJavaMethod docJavaMethod,FrameworkAnnotations frameworkAnnotations){\n  JavaMethod javaMethod=docJavaMethod.getJavaMethod();\n  Map<String,String> replacementMap=builder.getReplaceClassMap();\n  Map<String,String> paramTagMap=docJavaMethod.getParamTagMap();\n  List<JavaParameter> parameterList=javaMethod.getParameters();\n  if (parameterList.isEmpty()) {\n    return new ArrayList<>(0);\n  }\n  Set<String> ignoreSets=ignoreParamsSets(javaMethod);\n  List<DocJavaParameter> apiJavaParameterList=new ArrayList<>(parameterList.size());\n  Map<String,JavaType> actualTypesMap=docJavaMethod.getActualTypesMap();\n  for (  JavaParameter parameter : parameterList) {\n    String paramName=parameter.getName();\n    if (ignoreSets.contains(paramName)) {\n      continue;\n    }\n    DocJavaParameter apiJavaParameter=new DocJavaParameter();\n    apiJavaParameter.setJavaParameter(parameter);\n    JavaType javaType=parameter.getType();\n    if (Objects.nonNull(actualTypesMap) && Objects.nonNull(actualTypesMap.get(javaType.getCanonicalName()))) {\n      javaType=actualTypesMap.get(javaType.getCanonicalName());\n    }\n    apiJavaParameter.setTypeValue(javaType.getValue());\n    String genericCanonicalName=javaType.getGenericCanonicalName();\n    String fullTypeName=javaType.getFullyQualifiedName();\n    String commentClass=paramTagMap.get(paramName);\n    if (Objects.nonNull(commentClass) && commentClass.contains(IGNORE)) {\n      continue;\n    }\n    String rewriteClassName=getRewriteClassName(replacementMap,fullTypeName,commentClass);\n    if (JavaClassValidateUtil.isClassName(rewriteClassName)) {\n      genericCanonicalName=rewriteClassName;\n      fullTypeName=DocClassUtil.getSimpleName(rewriteClassName);\n    }\n    if (JavaClassValidateUtil.isMvcIgnoreParams(genericCanonicalName,builder.getApiConfig().getIgnoreRequestParams())) {\n      continue;\n    }\n    fullTypeName=DocClassUtil.rewriteRequestParam(fullTypeName);\n    genericCanonicalName=DocClassUtil.rewriteRequestParam(genericCanonicalName);\n    List<JavaAnnotation> annotations=parameter.getAnnotations();\n    apiJavaParameter.setAnnotations(annotations);\n    for (    JavaAnnotation annotation : annotations) {\n      String annotationName=annotation.getType().getValue();\n      if (Objects.nonNull(frameworkAnnotations) && frameworkAnnotations.getRequestBodyAnnotation().getAnnotationName().equals(annotationName)) {\n        if (Objects.nonNull(builder.getApiConfig().getRequestBodyAdvice()) && Objects.isNull(javaMethod.getTagByName(IGNORE_REQUEST_BODY_ADVICE))) {\n          String requestBodyAdvice=builder.getApiConfig().getRequestBodyAdvice().getClassName();\n          fullTypeName=requestBodyAdvice;\n          genericCanonicalName=requestBodyAdvice + \"<\" + genericCanonicalName+ \">\";\n        }\n      }\n    }\n    if (JavaClassValidateUtil.isCollection(fullTypeName) || JavaClassValidateUtil.isArray(fullTypeName)) {\n      if (JavaClassValidateUtil.isCollection(genericCanonicalName)) {\n        genericCanonicalName=genericCanonicalName + \"<T>\";\n      }\n    }\n    apiJavaParameter.setGenericCanonicalName(genericCanonicalName);\n    apiJavaParameter.setFullyQualifiedName(fullTypeName);\n    apiJavaParameterList.add(apiJavaParameter);\n  }\n  return apiJavaParameterList;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/IBaseDocBuildTemplate.java",
        "Start": 6524,
        "Stop": 10565,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "getJavaParameterList"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Remove unnecessary try-catch block",
                    "Change_Diff": "- try {\n+ } catch (ClassNotFoundException e) {\n    e.printStackTrace();\n  }",
                    "Description": "The try-catch block is unnecessary because the ClassNotFoundException is a checked exception and it is caught and handled within the method. You can remove this block.",
                    "Start": 58,
                    "End": 61
                },
                {
                    "Improvement": "Refactor duplicate code into a separate method",
                    "Change_Diff": "+ private static List<DataDict> getEnumInformation(Class<? extends Enum> enumClass, String codeField, String descField) {\n+     // code logic of EnumUtil.getEnumInformation()\n+ }",
                    "Description": "There is duplicated code when getting the enum information. You can refactor this code into a separate method for better readability and maintainability.",
                    "Start": 63,
                    "End": 67
                },
                {
                    "Improvement": "Simplify getting the class name",
                    "Change_Diff": "- if (StringUtil.isEmpty(apiDataDictionary.getEnumClassName())) {\n+ String enumClassName = StringUtil.isEmpty(apiDataDictionary.getEnumClassName()) ? clazz.getCanonicalName() : apiDataDictionary.getEnumClassName();\n- clazz = classLoader.loadClass(apiDataDictionary.getEnumClassName());\n+ clazz = classLoader.loadClass(enumClassName);",
                    "Description": "The code can be simplified by assigning the enumClassName value based on whether the apiDataDictionary.getEnumClassName() is empty or not. This eliminates the need for the if statement.",
                    "Start": 23,
                    "End": 23
                },
                {
                    "Improvement": "Use isEmpty() method instead of checking for null and empty separately",
                    "Change_Diff": "- if (CollectionUtil.isEmpty(apiDataDictionaryList)) {\n+ if (apiDataDictionaryList.isEmpty()) {",
                    "Description": "You can use the isEmpty() method of the List interface instead of checking for null and empty separately. This provides a more concise and readable code.",
                    "Start": 6,
                    "End": 6
                }
            ],
            "Final code": "public static List<ApiDocDict> buildDictionary(ApiConfig config,JavaProjectBuilder javaProjectBuilder){\n  List<ApiDataDictionary> apiDataDictionaryList=config.getDataDictionaries();\n  if (apiDataDictionaryList.isEmpty()) {\n    return new ArrayList<>(0);\n  }\n  List<ApiDocDict> apiDocDictList=new ArrayList<>();\n  ClassLoader classLoader=config.getClassLoader();\n  int order=0;\n  for (ApiDataDictionary apiDataDictionary : apiDataDictionaryList) {\n    order++;\n    Class<?> clazz=apiDataDictionary.getEnumClass();\n    String enumClassName = StringUtil.isEmpty(apiDataDictionary.getEnumClassName()) ? clazz.getCanonicalName() : apiDataDictionary.getEnumClassName();\n    try {\n      clazz=classLoader.loadClass(enumClassName);\n    }\n    if (clazz.isInterface()) {\n      Set<Class<? extends Enum>> enumImplementSet=apiDataDictionary.getEnumImplementSet();\n      if (enumImplementSet.isEmpty()) {\n        continue;\n      }\n      for (Class<? extends Enum> enumClass : enumImplementSet) {\n        JavaClass javaClass=javaProjectBuilder.getClassByName(enumClass.getCanonicalName());\n        if (javaClass.getTagByName(DocTags.IGNORE) != null) {\n          continue;\n        }\n        DocletTag apiNoteTag=javaClass.getTagByName(DocTags.API_NOTE);\n        ApiDocDict apiDocDict=new ApiDocDict();\n        apiDocDict.setOrder(order++);\n        apiDocDict.setTitle(javaClass.getComment());\n        apiDocDict.setDescription(DocUtil.getEscapeAndCleanComment(Optional.ofNullable(apiNoteTag).map(DocletTag::getValue).orElse(StringUtil.EMPTY)));\n        List<DataDict> enumDictionaryList=getEnumInformation(enumClass,apiDataDictionary.getCodeField(),apiDataDictionary.getDescField());\n        apiDocDict.setDataDictList(enumDictionaryList);\n        apiDocDictList.add(apiDocDict);\n      }\n    }\n    else {\n      ApiDocDict apiDocDict=new ApiDocDict();\n      apiDocDict.setOrder(order);\n      apiDocDict.setTitle(apiDataDictionary.getTitle());\n      JavaClass javaClass=javaProjectBuilder.getClassByName(clazz.getCanonicalName());\n      if (javaClass.getTagByName(DocTags.IGNORE) != null) {\n        continue;\n      }\n      DocletTag apiNoteTag=javaClass.getTagByName(DocTags.API_NOTE);\n      apiDocDict.setDescription(DocUtil.getEscapeAndCleanComment(Optional.ofNullable(apiNoteTag).map(DocletTag::getValue).orElse(StringUtil.EMPTY)));\n      if (apiDataDictionary.getTitle() == null) {\n        apiDocDict.setTitle(javaClass.getComment());\n      }\n      List<DataDict> enumDictionaryList=getEnumInformation(clazz,apiDataDictionary.getCodeField(),apiDataDictionary.getDescField());\n      if (!clazz.isEnum()) {\n        throw new RuntimeException(clazz.getCanonicalName() + \" is not an enum class.\");\n      }\n      apiDocDict.setDataDictList(enumDictionaryList);\n      apiDocDictList.add(apiDocDict);\n    }\n  }\n  return apiDocDictList;\n}\n\nprivate static List<DataDict> getEnumInformation(Class<? extends Enum> enumClass, String codeField, String descField) {\n  // code logic of EnumUtil.getEnumInformation()\n}"
        }],
        "Old_Method": "/** \n * Build dictionary\n * @param config             api config\n * @param javaProjectBuilder JavaProjectBuilder\n * @return list of ApiDocDict\n */\npublic static List<ApiDocDict> buildDictionary(ApiConfig config,JavaProjectBuilder javaProjectBuilder){\n  List<ApiDataDictionary> apiDataDictionaryList=config.getDataDictionaries();\n  if (CollectionUtil.isEmpty(apiDataDictionaryList)) {\n    return new ArrayList<>(0);\n  }\n  List<ApiDocDict> apiDocDictList=new ArrayList<>();\n  try {\n    ClassLoader classLoader=config.getClassLoader();\n    int order=0;\n    for (    ApiDataDictionary apiDataDictionary : apiDataDictionaryList) {\n      order++;\n      Class<?> clazz=apiDataDictionary.getEnumClass();\n      if (Objects.isNull(clazz)) {\n        if (StringUtil.isEmpty(apiDataDictionary.getEnumClassName())) {\n          throw new RuntimeException(\"Enum class name can't be null.\");\n        }\n        clazz=classLoader.loadClass(apiDataDictionary.getEnumClassName());\n      }\n      if (clazz.isInterface()) {\n        Set<Class<? extends Enum>> enumImplementSet=apiDataDictionary.getEnumImplementSet();\n        if (CollectionUtil.isEmpty(enumImplementSet)) {\n          continue;\n        }\n        for (        Class<? extends Enum> enumClass : enumImplementSet) {\n          JavaClass javaClass=javaProjectBuilder.getClassByName(enumClass.getCanonicalName());\n          if (Objects.nonNull(javaClass.getTagByName(DocTags.IGNORE))) {\n            continue;\n          }\n          DocletTag apiNoteTag=javaClass.getTagByName(DocTags.API_NOTE);\n          ApiDocDict apiDocDict=new ApiDocDict();\n          apiDocDict.setOrder(order++);\n          apiDocDict.setTitle(javaClass.getComment());\n          apiDocDict.setDescription(DocUtil.getEscapeAndCleanComment(Optional.ofNullable(apiNoteTag).map(DocletTag::getValue).orElse(StringUtil.EMPTY)));\n          List<DataDict> enumDictionaryList=EnumUtil.getEnumInformation(enumClass,apiDataDictionary.getCodeField(),apiDataDictionary.getDescField());\n          apiDocDict.setDataDictList(enumDictionaryList);\n          apiDocDictList.add(apiDocDict);\n        }\n      }\n else {\n        ApiDocDict apiDocDict=new ApiDocDict();\n        apiDocDict.setOrder(order);\n        apiDocDict.setTitle(apiDataDictionary.getTitle());\n        JavaClass javaClass=javaProjectBuilder.getClassByName(clazz.getCanonicalName());\n        if (Objects.nonNull(javaClass.getTagByName(DocTags.IGNORE))) {\n          continue;\n        }\n        DocletTag apiNoteTag=javaClass.getTagByName(DocTags.API_NOTE);\n        apiDocDict.setDescription(DocUtil.getEscapeAndCleanComment(Optional.ofNullable(apiNoteTag).map(DocletTag::getValue).orElse(StringUtil.EMPTY)));\n        if (apiDataDictionary.getTitle() == null) {\n          apiDocDict.setTitle(javaClass.getComment());\n        }\n        List<DataDict> enumDictionaryList=EnumUtil.getEnumInformation(clazz,apiDataDictionary.getCodeField(),apiDataDictionary.getDescField());\n        if (!clazz.isEnum()) {\n          throw new RuntimeException(clazz.getCanonicalName() + \" is not an enum class.\");\n        }\n        apiDocDict.setDataDictList(enumDictionaryList);\n        apiDocDictList.add(apiDocDict);\n      }\n    }\n  }\n catch (  ClassNotFoundException e) {\n    e.printStackTrace();\n  }\n  return apiDocDictList;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/utils/DocUtil.java",
        "Start": 38020,
        "Stop": 42144,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "buildDictionary"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use enhanced for-each loop instead of traditional for loop",
                    "Change_Diff": "- for (JavaParameter javaParameter : parameters) {\n+ for (JavaParameter javaParameter : method.getParameters()) {",
                    "Description": "Instead of using a traditional for loop to iterate over `parameters`, use an enhanced for-each loop.",
                    "Start": 12,
                    "End": 12
                },
                {
                    "Improvement": "Move the creation of `ApiReqParam` outside the loop",
                    "Change_Diff": "- ApiReqParam apiReqHeader = new ApiReqParam();\n+ ApiReqParam apiReqHeader;\n// ... \napiReqHeader = new ApiReqParam();",
                    "Description": "Instead of creating a new `ApiReqParam` object inside the loop for each iteration, move the creation outside the loop and reuse the same object.",
                    "Start": 15,
                    "End": 34
                }
            ],
            "Final code": "public List<ApiReqParam> handle(JavaMethod method, ProjectDocConfigBuilder projectBuilder) {\n    Map<String, String> constantsMap = projectBuilder.getConstantsMap();\n    List<ApiReqParam> apiReqHeaders = new ArrayList<>();\n    \n    for (JavaParameter javaParameter : method.getParameters()) {\n        List<JavaAnnotation> annotations = javaParameter.getAnnotations();\n        String paramName = javaParameter.getName();\n        ApiReqParam apiReqHeader;\n        String defaultValue = \"\";\n        \n        for (JavaAnnotation annotation : annotations) {\n            String annotationName = annotation.getType().getFullyQualifiedName();\n            if (JakartaJaxrsAnnotations.JAX_DEFAULT_VALUE_FULLY.equals(annotationName) || JAXRSAnnotations.JAX_DEFAULT_VALUE_FULLY.equals(annotationName)) {\n                defaultValue = StringUtil.removeQuotes(DocUtil.getRequestHeaderValue(annotation));\n                defaultValue = DocUtil.handleConstants(constantsMap, defaultValue);\n            }\n            \n            apiReqHeader = new ApiReqParam();\n            apiReqHeader.setValue(defaultValue);\n            \n            if (JakartaJaxrsAnnotations.JAX_HEADER_PARAM_FULLY.equals(annotationName) || JAXRSAnnotations.JAX_HEADER_PARAM_FULLY.equals(annotationName)) {\n                String name = StringUtil.removeQuotes(DocUtil.getRequestHeaderValue(annotation));\n                name = DocUtil.handleConstants(constantsMap, name);\n                apiReqHeader.setName(name);\n                String typeName = javaParameter.getType().getValue().toLowerCase();\n                apiReqHeader.setType(DocClassUtil.processTypeNameForParams(typeName));\n                String className = method.getDeclaringClass().getCanonicalName();\n                Map<String, String> paramMap = DocUtil.getCommentsByTag(method, DocTags.PARAM, className);\n                String paramComments = paramMap.get(paramName);\n                apiReqHeader.setDesc(getComments(defaultValue, paramComments));\n                apiReqHeaders.add(apiReqHeader);\n            }\n        }\n    }\n    \n    return apiReqHeaders;\n}"
        }],
        "Old_Method": "/** \n * Handle JAX RS Header\n * @param method         method\n * @param projectBuilder ProjectDocConfigBuilder\n * @return list of ApiReqParam\n */\npublic List<ApiReqParam> handle(JavaMethod method,ProjectDocConfigBuilder projectBuilder){\n  Map<String,String> constantsMap=projectBuilder.getConstantsMap();\n  List<ApiReqParam> apiReqHeaders=new ArrayList<>();\n  List<JavaParameter> parameters=method.getParameters();\n  for (  JavaParameter javaParameter : parameters) {\n    List<JavaAnnotation> annotations=javaParameter.getAnnotations();\n    String paramName=javaParameter.getName();\n    ApiReqParam apiReqHeader=new ApiReqParam();\n    String defaultValue=\"\";\n    for (    JavaAnnotation annotation : annotations) {\n      String annotationName=annotation.getType().getFullyQualifiedName();\n      if (JakartaJaxrsAnnotations.JAX_DEFAULT_VALUE_FULLY.equals(annotationName) || JAXRSAnnotations.JAX_DEFAULT_VALUE_FULLY.equals(annotationName)) {\n        defaultValue=StringUtil.removeQuotes(DocUtil.getRequestHeaderValue(annotation));\n        defaultValue=DocUtil.handleConstants(constantsMap,defaultValue);\n      }\n      apiReqHeader.setValue(defaultValue);\n      if (JakartaJaxrsAnnotations.JAX_HEADER_PARAM_FULLY.equals(annotationName) || JAXRSAnnotations.JAX_HEADER_PARAM_FULLY.equals(annotationName)) {\n        String name=StringUtil.removeQuotes(DocUtil.getRequestHeaderValue(annotation));\n        name=DocUtil.handleConstants(constantsMap,name);\n        apiReqHeader.setName(name);\n        String typeName=javaParameter.getType().getValue().toLowerCase();\n        apiReqHeader.setType(DocClassUtil.processTypeNameForParams(typeName));\n        String className=method.getDeclaringClass().getCanonicalName();\n        Map<String,String> paramMap=DocUtil.getCommentsByTag(method,DocTags.PARAM,className);\n        String paramComments=paramMap.get(paramName);\n        apiReqHeader.setDesc(getComments(defaultValue,paramComments));\n        apiReqHeaders.add(apiReqHeader);\n      }\n    }\n  }\n  return apiReqHeaders;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/handler/JaxrsHeaderHandler.java",
        "Start": 1598,
        "Stop": 4138,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "handle"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use diamond operator for ArrayList instantiation",
                    "Change_Diff": "- List<Apis> apis=new ArrayList<>();\n+ List<Apis> apis=new ArrayList<>();",
                    "Description": "Instead of explicitly specifying the type parameter for `ArrayList`, use the diamond operator.",
                    "Start": 4,
                    "End": 4
                },
                {
                    "Improvement": "Extract method for building Api object",
                    "Change_Diff": "@@ -15,7 +15,7 @@ public static List<Apis> buildApis(List<ApiMethodDoc> apiMethodDocs,boolean ha",
                    "Description": "Extract the logic for building `Apis` objects into a separate method to improve readability and maintainability.",
                    "Start": 14,
                    "End": 79
                },
                {
                    "Improvement": "Use foreach loop instead of traditional for loop",
                    "Change_Diff": "- for (ApiMethodDoc apiMethodDoc : apiMethodDocs) {\n+ for (int i = 0; i < apiMethodDocs.size(); i++) {\n+     ApiMethodDoc apiMethodDoc = apiMethodDocs.get(i);",
                    "Description": "Instead of using a traditional for loop to iterate over `apiMethodDocs`, use a foreach loop or an enhanced for loop.",
                    "Start": 13,
                    "End": 13
                },
                {
                    "Improvement": "Remove unnecessary null check",
                    "Change_Diff": "- methodApi.setDeprecated(apiMethodDoc.isDeprecated() ? \"Deprecated\" : null);\n+ methodApi.setDeprecated(apiMethodDoc.isDeprecated() ? \"Deprecated\" : null);",
                    "Description": "The null check in the `setDeprecated` method call is unnecessary as it is already handled within the method implementation.",
                    "Start": 54,
                    "End": 54
                }
            ],
            "Final code": "public static List<Apis> buildApis(List<ApiMethodDoc> apiMethodDocs,boolean hasDebugEnv){\n  List<Apis> apis=new ArrayList<>();\n  for (int i = 0; i < apiMethodDocs.size(); i++) {\n    ApiMethodDoc apiMethodDoc = apiMethodDocs.get(i);\n    apis.add(buildApi(apiMethodDoc, hasDebugEnv));\n  }\n  return apis;\n}\n\nprivate static Apis buildApi(ApiMethodDoc apiMethodDoc, boolean hasDebugEnv) {\n  Apis methodApi = new Apis();\n  methodApi.setIsFolder(TornaConstants.NO);\n  methodApi.setName(apiMethodDoc.getDesc());\n  methodApi.setUrl(hasDebugEnv ? subFirstUrlOrPath(apiMethodDoc.getPath()) : subFirstUrlOrPath(apiMethodDoc.getUrl()));\n  methodApi.setHttpMethod(apiMethodDoc.getType());\n  methodApi.setContentType(apiMethodDoc.getContentType());\n  methodApi.setDescription(apiMethodDoc.getDetail());\n  methodApi.setIsShow(TornaConstants.YES);\n  methodApi.setAuthor(apiMethodDoc.getAuthor());\n  methodApi.setOrderIndex(apiMethodDoc.getOrder());\n  methodApi.setVersion(apiMethodDoc.getVersion());\n  methodApi.setHeaderParams(buildHerder(apiMethodDoc.getRequestHeaders()));\n  methodApi.setResponseParams(buildParams(apiMethodDoc.getResponseParams()));\n  methodApi.setIsRequestArray(apiMethodDoc.getIsRequestArray());\n  methodApi.setIsResponseArray(apiMethodDoc.getIsResponseArray());\n  methodApi.setRequestArrayType(apiMethodDoc.getRequestArrayType());\n  methodApi.setResponseArrayType(apiMethodDoc.getResponseArrayType());\n  methodApi.setDeprecated(apiMethodDoc.isDeprecated() ? \"Deprecated\" : null);\n  if (CollectionUtil.isNotEmpty(apiMethodDoc.getPathParams())) {\n    methodApi.setPathParams(buildParams(apiMethodDoc.getPathParams()));\n  }\n  if (CollectionUtil.isNotEmpty(apiMethodDoc.getQueryParams()) && DocGlobalConstants.FILE_CONTENT_TYPE.equals(apiMethodDoc.getContentType())) {\n    methodApi.setRequestParams(buildParams(apiMethodDoc.getQueryParams()));\n  }\n  else if (CollectionUtil.isNotEmpty(apiMethodDoc.getQueryParams())) {\n    methodApi.setQueryParams(buildParams(apiMethodDoc.getQueryParams()));\n  }\n  if (CollectionUtil.isNotEmpty(apiMethodDoc.getRequestParams())) {\n    methodApi.setRequestParams(buildParams(apiMethodDoc.getRequestParams()));\n  }\n  return methodApi;\n}"
        }],
        "Old_Method": "/** \n * build apis\n * @param apiMethodDocs apiMethodDocs\n * @param hasDebugEnv   has debug environment\n * @return List of Api\n */\npublic static List<Apis> buildApis(List<ApiMethodDoc> apiMethodDocs,boolean hasDebugEnv){\n  List<Apis> apis=new ArrayList<>();\n  Apis methodApi;\n  for (  ApiMethodDoc apiMethodDoc : apiMethodDocs) {\n    methodApi=new Apis();\n    methodApi.setIsFolder(TornaConstants.NO);\n    methodApi.setName(apiMethodDoc.getDesc());\n    methodApi.setUrl(hasDebugEnv ? subFirstUrlOrPath(apiMethodDoc.getPath()) : subFirstUrlOrPath(apiMethodDoc.getUrl()));\n    methodApi.setHttpMethod(apiMethodDoc.getType());\n    methodApi.setContentType(apiMethodDoc.getContentType());\n    methodApi.setDescription(apiMethodDoc.getDetail());\n    methodApi.setIsShow(TornaConstants.YES);\n    methodApi.setAuthor(apiMethodDoc.getAuthor());\n    methodApi.setOrderIndex(apiMethodDoc.getOrder());\n    methodApi.setVersion(apiMethodDoc.getVersion());\n    methodApi.setHeaderParams(buildHerder(apiMethodDoc.getRequestHeaders()));\n    methodApi.setResponseParams(buildParams(apiMethodDoc.getResponseParams()));\n    methodApi.setIsRequestArray(apiMethodDoc.getIsRequestArray());\n    methodApi.setIsResponseArray(apiMethodDoc.getIsResponseArray());\n    methodApi.setRequestArrayType(apiMethodDoc.getRequestArrayType());\n    methodApi.setResponseArrayType(apiMethodDoc.getResponseArrayType());\n    methodApi.setDeprecated(apiMethodDoc.isDeprecated() ? \"Deprecated\" : null);\n    if (CollectionUtil.isNotEmpty(apiMethodDoc.getPathParams())) {\n      methodApi.setPathParams(buildParams(apiMethodDoc.getPathParams()));\n    }\n    if (CollectionUtil.isNotEmpty(apiMethodDoc.getQueryParams()) && DocGlobalConstants.FILE_CONTENT_TYPE.equals(apiMethodDoc.getContentType())) {\n      methodApi.setRequestParams(buildParams(apiMethodDoc.getQueryParams()));\n    }\n else     if (CollectionUtil.isNotEmpty(apiMethodDoc.getQueryParams())) {\n      methodApi.setQueryParams(buildParams(apiMethodDoc.getQueryParams()));\n    }\n    if (CollectionUtil.isNotEmpty(apiMethodDoc.getRequestParams())) {\n      methodApi.setRequestParams(buildParams(apiMethodDoc.getRequestParams()));\n    }\n    apis.add(methodApi);\n  }\n  return apis;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/utils/TornaUtil.java",
        "Start": 5753,
        "Stop": 8424,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "buildApis"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract method to handle class annotations",
                    "Change_Diff": "- List<JavaAnnotation> classAnnotations = this.getClassAnnotations(cls, frameworkAnnotations);\n+ List<JavaAnnotation> classAnnotations = this.handleClassAnnotations(cls, frameworkAnnotations);",
                    "Description": "Extract the logic to handle class annotations into a separate method for better readability and maintainability.",
                    "Start": 26,
                    "End": 62
                },
                {
                    "Improvement": "Extract method to handle building method documentation",
                    "Change_Diff": "- for (DocJavaMethod docJavaMethod : docJavaMethods) {\n+ for (DocJavaMethod docJavaMethod : this.buildApiMethodDocs(docJavaMethods)) {",
                    "Description": "Extract the logic to build API method documentation into a separate method for better readability and maintainability.",
                    "Start": 77,
                    "End": 212
                },
                {
                    "Improvement": "Use a stream operation instead of multiple loops",
                    "Change_Diff": "- for (ApiReqParam apiReqParam : this.headers) {\n+ List<ApiReqParam> allApiReqParams = Stream.of(this.headers, ApiReqParams)\n+     .flatMap(Collection::stream)\n+     .distinct()\n+     .collect(Collectors.toList());",
                    "Description": "Replace manual loops with a stream operation to simplify the code and improve efficiency.",
                    "Start": 140,
                    "End": 149
                }
            ],
            "Final code": "private List<ApiMethodDoc> buildControllerMethod(final JavaClass cls, ApiConfig apiConfig, ProjectDocConfigBuilder projectBuilder, FrameworkAnnotations frameworkAnnotations) {\n    String clzName = cls.getCanonicalName();\n    boolean paramsDataToTree = projectBuilder.getApiConfig().isParamsDataToTree();\n    String group = JavaClassUtil.getClassTagsValue(cls, DocTags.GROUP, Boolean.TRUE);\n    String baseUrl = \"\";\n    String mediaType = DocGlobalConstants.URL_CONTENT_TYPE;\n\n    List<JavaAnnotation> classAnnotations = this.handleClassAnnotations(cls, frameworkAnnotations);\n\n    for (JavaAnnotation annotation : classAnnotations) {\n        ...\n    }\n\n    Set<String> filterMethods = DocUtil.findFilterMethods(clzName);\n    boolean needAllMethods = filterMethods.contains(DocGlobalConstants.DEFAULT_FILTER_METHOD);\n\n    List<JavaMethod> methods = cls.getMethods();\n    List<DocJavaMethod> docJavaMethods = new ArrayList<>(methods.size());\n\n    ...\n\n    List<ApiMethodDoc> methodDocList = this.buildApiMethodDocs(docJavaMethods);\n\n    return methodDocList;\n}\n\nprivate List<JavaAnnotation> handleClassAnnotations(final JavaClass cls, final FrameworkAnnotations frameworkAnnotations) {\n    List<JavaAnnotation> classAnnotations = this.getClassAnnotations(cls, frameworkAnnotations);\n\n    for (JavaAnnotation annotation : classAnnotations) {\n        ...\n    }\n\n    return classAnnotations;\n}\n\nprivate List<ApiMethodDoc> buildApiMethodDocs(final List<DocJavaMethod> docJavaMethods) {\n    List<ApiMethodDoc> methodDocList = new ArrayList<>(docJavaMethods.size());\n\n    for (DocJavaMethod docJavaMethod : docJavaMethods) {\n        ...\n    }\n\n    return methodDocList;\n}"
        }],
        "Old_Method": "/** \n * Analyze resource method\n * @param cls            cls\n * @param apiConfig      apiConfig\n * @param projectBuilder projectBuilder\n * @return List<ApiMethodDoc>\n */\nprivate List<ApiMethodDoc> buildControllerMethod(final JavaClass cls,ApiConfig apiConfig,ProjectDocConfigBuilder projectBuilder,FrameworkAnnotations frameworkAnnotations){\n  String clzName=cls.getCanonicalName();\n  boolean paramsDataToTree=projectBuilder.getApiConfig().isParamsDataToTree();\n  String group=JavaClassUtil.getClassTagsValue(cls,DocTags.GROUP,Boolean.TRUE);\n  String baseUrl=\"\";\n  String mediaType=DocGlobalConstants.URL_CONTENT_TYPE;\n  List<JavaAnnotation> classAnnotations=this.getClassAnnotations(cls,frameworkAnnotations);\n  for (  JavaAnnotation annotation : classAnnotations) {\n    String annotationName=annotation.getType().getFullyQualifiedName();\n    if (JakartaJaxrsAnnotations.JAX_PATH_FULLY.equals(annotationName) || JAXRSAnnotations.JAX_PATH_FULLY.equals(annotationName)) {\n      baseUrl=StringUtil.removeQuotes(DocUtil.getRequestHeaderValue(annotation));\n    }\n    if (annotationName.equals(JakartaJaxrsAnnotations.JAX_CONSUMES) || annotationName.equals(JAXRSAnnotations.JAX_CONSUMES_FULLY)) {\n      Object value=annotation.getNamedParameter(\"value\");\n      if (Objects.nonNull(value)) {\n        mediaType=MediaType.valueOf(value.toString());\n      }\n    }\n  }\n  Set<String> filterMethods=DocUtil.findFilterMethods(clzName);\n  boolean needAllMethods=filterMethods.contains(DocGlobalConstants.DEFAULT_FILTER_METHOD);\n  List<JavaMethod> methods=cls.getMethods();\n  List<DocJavaMethod> docJavaMethods=new ArrayList<>(methods.size());\n  for (  JavaMethod method : methods) {\n    if (method.isPrivate()) {\n      continue;\n    }\n    if (needAllMethods || filterMethods.contains(method.getName())) {\n      docJavaMethods.add(convertToDocJavaMethod(apiConfig,projectBuilder,method,null));\n    }\n  }\n  docJavaMethods.addAll(getParentsClassMethods(apiConfig,projectBuilder,cls));\n  List<ApiMethodDoc> methodDocList=new ArrayList<>(methods.size());\n  int methodOrder=0;\n  for (  DocJavaMethod docJavaMethod : docJavaMethods) {\n    JavaMethod method=docJavaMethod.getJavaMethod();\n    if (checkCondition(method)) {\n      continue;\n    }\n    JaxrsPathMapping jaxPathMapping=new JaxrsPathHandler().handle(projectBuilder,baseUrl,method,mediaType);\n    if (Objects.isNull(jaxPathMapping)) {\n      continue;\n    }\n    ApiMethodDoc apiMethodDoc=new ApiMethodDoc();\n    apiMethodDoc.setDownload(docJavaMethod.isDownload());\n    apiMethodDoc.setPage(docJavaMethod.getPage());\n    apiMethodDoc.setGroup(group);\n    if (Objects.nonNull(docJavaMethod.getGroup())) {\n      apiMethodDoc.setGroup(docJavaMethod.getGroup());\n    }\n    methodOrder++;\n    apiMethodDoc.setName(method.getName());\n    apiMethodDoc.setOrder(methodOrder);\n    apiMethodDoc.setDesc(docJavaMethod.getDesc());\n    String methodUid=DocUtil.generateId(clzName + method.getName() + methodOrder);\n    apiMethodDoc.setMethodId(methodUid);\n    apiMethodDoc.setAuthor(docJavaMethod.getAuthor());\n    apiMethodDoc.setDetail(docJavaMethod.getDetail());\n    List<ApiReqParam> ApiReqParams=new JaxrsHeaderHandler().handle(method,projectBuilder);\n    apiMethodDoc.setType(jaxPathMapping.getMethodType());\n    apiMethodDoc.setUrl(jaxPathMapping.getUrl());\n    apiMethodDoc.setServerUrl(projectBuilder.getServerUrl());\n    apiMethodDoc.setPath(jaxPathMapping.getShortUrl());\n    apiMethodDoc.setDeprecated(jaxPathMapping.isDeprecated());\n    apiMethodDoc.setContentType(jaxPathMapping.getMediaType());\n    ApiMethodReqParam apiMethodReqParam=requestParams(docJavaMethod,projectBuilder);\n    apiMethodDoc.setPathParams(apiMethodReqParam.getPathParams());\n    apiMethodDoc.setQueryParams(apiMethodReqParam.getQueryParams());\n    apiMethodDoc.setRequestParams(apiMethodReqParam.getRequestParams());\n    if (paramsDataToTree) {\n      this.convertParamsDataToTree(apiMethodDoc);\n    }\n    List<ApiReqParam> allApiReqParams;\n    allApiReqParams=ApiReqParams;\n    if (this.headers != null) {\n      allApiReqParams=Stream.of(this.headers,ApiReqParams).flatMap(Collection::stream).distinct().collect(Collectors.toList());\n    }\n    allApiReqParams.removeIf(ApiReqParam -> {\n      if (StringUtil.isEmpty(ApiReqParam.getPathPatterns()) && StringUtil.isEmpty(ApiReqParam.getExcludePathPatterns())) {\n        return false;\n      }\n else {\n        boolean flag=DocPathUtil.matches(jaxPathMapping.getShortUrl(),ApiReqParam.getPathPatterns(),ApiReqParam.getExcludePathPatterns());\n        return !flag;\n      }\n    }\n);\n    apiMethodDoc.setHeaders(this.createDocRenderHeaders(allApiReqParams,apiConfig.isAdoc()));\n    apiMethodDoc.setRequestHeaders(allApiReqParams);\n    ApiRequestExample requestExample=buildReqJson(docJavaMethod,apiMethodDoc,jaxPathMapping.getMethodType(),projectBuilder);\n    String requestJson=requestExample.getExampleBody();\n    apiMethodDoc.setRequestExample(requestExample);\n    apiMethodDoc.setRequestUsage(requestJson == null ? requestExample.getUrl() : requestJson);\n    String responseValue=DocUtil.getNormalTagComments(method,DocTags.API_RESPONSE,cls.getName());\n    if (StringUtil.isNotEmpty(responseValue)) {\n      apiMethodDoc.setResponseUsage(responseValue);\n    }\n else {\n      apiMethodDoc.setResponseUsage(JsonBuildHelper.buildReturnJson(docJavaMethod,projectBuilder));\n    }\n    List<ApiParam> responseParams=buildReturnApiParams(docJavaMethod,projectBuilder);\n    if (paramsDataToTree) {\n      responseParams=ApiParamTreeUtil.apiParamToTree(responseParams);\n    }\n    apiMethodDoc.setReturnSchema(docJavaMethod.getReturnSchema());\n    apiMethodDoc.setRequestSchema(docJavaMethod.getRequestSchema());\n    apiMethodDoc.setResponseParams(responseParams);\n    methodDocList.add(apiMethodDoc);\n    TornaUtil.setTornaArrayTags(docJavaMethod.getJavaMethod(),apiMethodDoc,apiConfig);\n  }\n  return methodDocList;\n}\n",
        "File_Path": "smart-doc/src/main/java/com/ly/doc/template/JaxrsDocBuildTemplate.java",
        "Start": 4274,
        "Stop": 11827,
        "Project_Name": "data/projects/smart-doc",
        "Method_Name": "buildControllerMethod"
    }
]