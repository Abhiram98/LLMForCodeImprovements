[
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract common code into a separate method",
                    "Change_Diff": "- subSession.setCreationTime(currentTime);\n- subSession.setEventCount(1);\n- if (info.getTtl() > 0) {\n- subSession.setTtl(Math.min(info.getTtl(),maxSessionIdleTime));\n- }\n- else {\n- subSession.setTtl(Math.min(profile.getDefaultTtl(),maxSessionIdleTime));\n- }\n- if (subSession.getTtl() > session.getTtl()) {\n- subSession.setTtl(session.getTtl());\n- }\n- subSession.setFirstEventTimestamp(eventTimestamp);\n- subSession.setLastModifiedTime(currentTime);\n- subSession.setExpirationTime(currentTime + subSession.getTtl());\n- subSession.setSessionId(concatTimestamp(session.getIdentifier(),subSessionIdenfifier,subSession.getFirstEventTimestamp()));\n+ initializeSubSession(subSession, info, currentTime, profile, maxSessionIdleTime, eventTimestamp, session);\n",
                    "Description": "Extract the common code for initializing a sub-session into a separate method called 'initializeSubSession'. This improves code readability and reduces duplication.",
                    "Start": 10,
                    "End": 26
                },
                {
                    "Improvement": "Use isEmpty() method to check for null or empty collections",
                    "Change_Diff": "- if (subSession.getInitialAttributes() != null) {\n- subSession.getInitialAttributes().clear();\n- }\n- if (subSession.getDynamicAttributes() != null) {\n- subSession.getDynamicAttributes().clear();\n- }\n+ if (!subSession.getInitialAttributes().isEmpty()) {\n+ subSession.getInitialAttributes().clear();\n+ }\n+ if (!subSession.getDynamicAttributes().isEmpty()) {\n+ subSession.getDynamicAttributes().clear();\n+ }\n",
                    "Description": "Instead of checking for null values and then calling the clear() method on collections, use the isEmpty() method to check if the collections are empty. This results in more concise and readable code.",
                    "Start": 33,
                    "End": 36
                },
                {
                    "Improvement": "Use 'Objects.requireNonNull' to check for null values",
                    "Change_Diff": "- if (subEsperSessionizer != null && subEsperSessionizer.isEventSupported(event)) {\n+ if (Objects.requireNonNull(subEsperSessionizer).isEventSupported(event)) {\n",
                    "Description": "To ensure that 'subEsperSessionizer' is not null before using it, use 'Objects.requireNonNull' method. This provides a clearer and more explicit check for null values.",
                    "Start": 43,
                    "End": 43
                },
                {
                    "Improvement": "Refactor if statement into separate method",
                    "Change_Diff": "- if (profile.getSessionIdKey() != null) {\n- sessionBeginEvent.put(profile.getSessionIdKey(),subSession.getSessionId());\n- }\n- if (mainSessionProfile.getSessionStartTimestampKey() != null) {\n- sessionBeginEvent.put(mainSessionProfile.getSessionStartTimestampKey(),subSession.getCreationTime());\n- }\n+ setSessionIdKey(subSession, sessionBeginEvent, profile);\n+ setSessionStartTimestampKey(subSession, sessionBeginEvent, mainSessionProfile);\n",
                    "Description": "Refactor the if statement that sets the session ID key and session start timestamp key into separate methods. This improves code modularity and readability.",
                    "Start": 66,
                    "End": 69
                }
            ],
            "Final code": "private void processSubSession(JetstreamEvent event, Session session, String mainIdentifier, SessionizationInfo info, SubSessionProfile profile, long eventTimestamp) {\n    String subSessionIdentifier = info.getIdentifier();\n    SubSession subSession = session.getSubSession(subSessionIdentifier, profile.getName());\n    long currentTime = session.getLastModifiedTime();\n\n    if (subSession == null) {\n        subSession = new SubSession();\n        subSession.setIdentifier(subSessionIdentifier);\n        subSession.setName(profile.getName());\n        initializeSubSession(subSession, info, currentTime, profile, maxSessionIdleTime, eventTimestamp, session);\n        subSession.setSessionId(concatTimestamp(session.getIdentifier(), subSessionIdentifier, subSession.getFirstEventTimestamp()));\n        session.addSubSession(subSession);\n    } else if (subSession.getExpirationTime() < session.getLastModifiedTime()) {\n        subSessionEnd(mainIdentifier, session, subSession);\n        initializeSubSession(subSession, info, currentTime, profile, maxSessionIdleTime, eventTimestamp, session);\n        if (!subSession.getInitialAttributes().isEmpty()) {\n            subSession.getInitialAttributes().clear();\n        }\n        if (!subSession.getDynamicAttributes().isEmpty()) {\n            subSession.getDynamicAttributes().clear();\n        }\n    } else {\n        subSession.setSessionId(concatTimestamp(session.getIdentifier(), subSessionIdentifier, subSession.getFirstEventTimestamp()));\n        if (subSession.getEventCount() < Integer.MAX_VALUE) {\n            subSession.setEventCount(subSession.getEventCount() + 1);\n        }\n        subSession.setExpirationTime(currentTime + subSession.getTtl());\n        subSession.setLastModifiedTime(currentTime);\n    }\n\n    if (session.getExpirationTime() < subSession.getExpirationTime()) {\n        session.setExpirationTime(subSession.getExpirationTime());\n    }\n\n    EsperSessionizer subEsperSessionizer = Objects.requireNonNull(subEsperSessionizerMap.get(profile.getName()));\n    if (subEsperSessionizer.isEventSupported(event)) {\n        subEsperSessionizer.process(subSession, session, event);\n    }\n\n    if (subSession.getEventCount() == 1 && profile.getBeginMarker() != null) {\n        JetstreamEvent sessionBeginEvent = new JetstreamEvent();\n        sessionBeginEvent.setEventType(profile.getBeginMarker());\n        setSessionIdKey(subSession, sessionBeginEvent, profile);\n        setSessionStartTimestampKey(subSession, sessionBeginEvent, mainSessionProfile);\n        if (subEsperSessionizer.isEventSupported(sessionBeginEvent)) {\n            subEsperSessionizer.process(subSession, session, sessionBeginEvent);\n        }\n        eventSender.sendSubSessionBeginEvent(mainSessionProfile.getSessionType(), subSession, sessionBeginEvent);\n    }\n}\n\nprivate void initializeSubSession(SubSession subSession, SessionizationInfo info, long currentTime, SubSessionProfile profile, int maxSessionIdleTime, long eventTimestamp, Session session) {\n    subSession.setCreationTime(currentTime);\n    subSession.setEventCount(1);\n    if (info.getTtl() > 0) {\n        subSession.setTtl(Math.min(info.getTtl(), maxSessionIdleTime));\n    } else {\n        subSession.setTtl(Math.min(profile.getDefaultTtl(), maxSessionIdleTime));\n    }\n    if (subSession.getTtl() > session.getTtl()) {\n        subSession.setTtl(session.getTtl());\n    }\n    subSession.setFirstEventTimestamp(eventTimestamp);\n    subSession.setLastModifiedTime(currentTime);\n    subSession.setExpirationTime(currentTime + subSession.getTtl());\n}\n\nprivate void setSessionIdKey(SubSession subSession, JetstreamEvent sessionBeginEvent, SubSessionProfile profile) {\n    if (profile.getSessionIdKey() != null) {\n        sessionBeginEvent.put(profile.getSessionIdKey(), subSession.getSessionId());\n    }\n}\n\nprivate void setSessionStartTimestampKey(SubSession subSession, JetstreamEvent sessionBeginEvent, MainSessionProfile mainSessionProfile) {\n    if (mainSessionProfile.getSessionStartTimestampKey() != null) {\n        sessionBeginEvent.put(mainSessionProfile.getSessionStartTimestampKey(), subSession.getCreationTime());\n    }\n}"
        }],
        "Old_Method": "private void processSubSession(JetstreamEvent event,Session session,String mainIdentifier,SessionizationInfo info,SubSessionProfile profile,long eventTimestamp){\n  String subSessionIdenfifier=info.getIdentifier();\n  SubSession subSession=session.getSubSession(subSessionIdenfifier,profile.getName());\n  long currentTime=session.getLastModifiedTime();\n  if (subSession == null) {\n    subSession=new SubSession();\n    subSession.setIdentifier(subSessionIdenfifier);\n    subSession.setName(profile.getName());\n    subSession.setCreationTime(currentTime);\n    subSession.setEventCount(1);\n    if (info.getTtl() > 0) {\n      subSession.setTtl(Math.min(info.getTtl(),maxSessionIdleTime));\n    }\n else {\n      subSession.setTtl(Math.min(profile.getDefaultTtl(),maxSessionIdleTime));\n    }\n    if (subSession.getTtl() > session.getTtl()) {\n      subSession.setTtl(session.getTtl());\n    }\n    subSession.setFirstEventTimestamp(eventTimestamp);\n    subSession.setLastModifiedTime(currentTime);\n    subSession.setExpirationTime(currentTime + subSession.getTtl());\n    subSession.setSessionId(concatTimestamp(session.getIdentifier(),subSessionIdenfifier,subSession.getFirstEventTimestamp()));\n    session.addSubSession(subSession);\n  }\n else   if (subSession.getExpirationTime() < session.getLastModifiedTime()) {\n    subSessionEnd(mainIdentifier,session,subSession);\n    subSession.setCreationTime(currentTime);\n    subSession.setEventCount(1);\n    if (info.getTtl() > 0) {\n      subSession.setTtl(Math.min(info.getTtl(),maxSessionIdleTime));\n    }\n else {\n      subSession.setTtl(Math.min(profile.getDefaultTtl(),maxSessionIdleTime));\n    }\n    if (subSession.getTtl() > session.getTtl()) {\n      subSession.setTtl(session.getTtl());\n    }\n    subSession.setFirstEventTimestamp(eventTimestamp);\n    subSession.setLastModifiedTime(currentTime);\n    subSession.setExpirationTime(currentTime + subSession.getTtl());\n    subSession.setSessionId(concatTimestamp(session.getIdentifier(),subSessionIdenfifier,subSession.getFirstEventTimestamp()));\n    if (subSession.getInitialAttributes() != null) {\n      subSession.getInitialAttributes().clear();\n    }\n    if (subSession.getDynamicAttributes() != null) {\n      subSession.getDynamicAttributes().clear();\n    }\n  }\n else {\n    subSession.setSessionId(concatTimestamp(session.getIdentifier(),subSessionIdenfifier,subSession.getFirstEventTimestamp()));\n    if (subSession.getEventCount() < Integer.MAX_VALUE) {\n      subSession.setEventCount(subSession.getEventCount() + 1);\n    }\n    subSession.setExpirationTime(currentTime + subSession.getTtl());\n    subSession.setLastModifiedTime(currentTime);\n  }\n  if (session.getExpirationTime() < subSession.getExpirationTime()) {\n    session.setExpirationTime(subSession.getExpirationTime());\n  }\n  EsperSessionizer subEsperSessionizer=subEsperSessionizerMap.get(profile.getName());\n  if (subEsperSessionizer != null && subEsperSessionizer.isEventSupported(event)) {\n    subEsperSessionizer.process(subSession,session,event);\n  }\n  if (subSession.getEventCount() == 1 && profile.getBeginMarker() != null) {\n    JetstreamEvent sessionBeginEvent=new JetstreamEvent();\n    sessionBeginEvent.setEventType(profile.getBeginMarker());\n    Map<String,Object> initialAttributes=subSession.getInitialAttributes();\n    if (initialAttributes != null) {\n      sessionBeginEvent.putAll(initialAttributes);\n    }\n    if (profile.getSessionIdKey() != null) {\n      sessionBeginEvent.put(profile.getSessionIdKey(),subSession.getSessionId());\n    }\n    if (mainSessionProfile.getSessionStartTimestampKey() != null) {\n      sessionBeginEvent.put(mainSessionProfile.getSessionStartTimestampKey(),subSession.getCreationTime());\n    }\n    if (subEsperSessionizer != null && subEsperSessionizer.isEventSupported(sessionBeginEvent)) {\n      subEsperSessionizer.process(subSession,session,sessionBeginEvent);\n    }\n    eventSender.sendSubSessionBeginEvent(mainSessionProfile.getSessionType(),subSession,sessionBeginEvent);\n  }\n}\n",
        "File_Path": "realtime-analytics/sessionizer/src/main/java/com/ebay/pulsar/sessionizer/impl/Sessionizer.java",
        "Start": 7838,
        "Stop": 12484,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "processSubSession"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract method for creating counter",
                    "Change_Diff": "- if (isAvg) {\n-   counter=new AvgCounter();\n- }\n- else {\n-   counter=new Counter();\n- }\n+ counter = createCounter(isAvg);",
                    "Description": "Extract the code for creating a counter into a separate method to improve readability and maintainability.",
                    "Start": 52,
                    "End": 64
                },
                {
                    "Improvement": "Use ConcurrentHashMap instead of synchronized block and HashMap",
                    "Change_Diff": "- Map<MCMetricGroupDemension,Counter> counters=groupbyWithTagsMetricMap.get(metricName);\n+ Map<MCMetricGroupDemension,Counter> counters=groupbyWithTagsMetricMap.computeIfAbsent(metricName, k -> new ConcurrentHashMap<>());\n\n- synchronized (this) {\n-   if (counters == null) {\n-     if (conf != null) {\n-       counters=CacheManager.getCounterOffHeapCache(metricName,conf);\n-     }\n-     else {\n-       counters=CacheManager.getCounterCache();\n-     }\n-     groupbyWithTagsMetricMap.put(metricName,counters);\n-   }\n- }",
                    "Description": "Use ConcurrentHashMap instead of synchronized blocks and HashMap to improve thread-safety and performance.",
                    "Start": 18,
                    "End": 45
                },
                {
                    "Improvement": "Null check for count and total",
                    "Change_Diff": "+ Objects.requireNonNull(count, \"count cannot be null\");\n+ Objects.requireNonNull(total, \"total cannot be null\");",
                    "Description": "Add null check for 'count' and 'total' variables to avoid potential NullPointerExceptions.",
                    "Start": 67,
                    "End": 68
                }
            ],
            "Final code": "private Counter getCounterByMetricDemensionAndInc(String metricName,String groupId,Map<String,String> tags,boolean isAvg,Long count,Long total){\n  Map<MCMetricGroupDemension,Counter> counters=groupbyWithTagsMetricMap.computeIfAbsent(metricName, k -> new ConcurrentHashMap<>());\n  OffHeapCacheConfig conf=null;\n  if (getConfiguration().getOffheapMetricConf() != null) {\n    conf=getConfiguration().getOffheapMetricConf().get(metricName);\n  }\n  MCMetricGroupDemension groupDemension=null;\n  String tag_time=null;\n  if (tags == null || tags.isEmpty()) {\n    groupDemension=new MCMetricGroupDemension(metricName,groupId);\n  }\n  else {\n    if (tags.containsKey(MCConstant.TAG_TIME_IGNORE)) {\n      tag_time=tags.remove(MCConstant.TAG_TIME_IGNORE);\n    }\n    groupDemension=new MCMetricGroupDemension(metricName,groupId,tags);\n  }\n  Counter counter=counters.get(groupDemension);\n  if (counter == null) {\n    counter = createCounter(isAvg);\n    if (conf == null) {\n      counters.put(groupDemension,counter);\n    }\n  }\n  if (tag_time != null) {\n    counter.setLastCounterTime(tag_time);\n  }\n  if (isAvg) {\n    Objects.requireNonNull(count, \"count cannot be null\");\n    Objects.requireNonNull(total, \"total cannot be null\");\n    ((AvgCounter)counter).inc(count,total);\n  }\n  else {\n    if (count != null) {\n      counter.inc(count);\n    }\n    else {\n      counter.inc();\n    }\n  }\n  if (conf != null) {\n    counters.put(groupDemension,counter);\n  }\n  return counter;\n}\n\nprivate Counter createCounter(boolean isAvg) {\n  return isAvg ? new AvgCounter() : new Counter();\n}"
        }],
        "Old_Method": "private Counter getCounterByMetricDemensionAndInc(String metricName,String groupId,Map<String,String> tags,boolean isAvg,Long count,Long total){\n  Map<MCMetricGroupDemension,Counter> counters=groupbyWithTagsMetricMap.get(metricName);\n  OffHeapCacheConfig conf=null;\n  if (getConfiguration().getOffheapMetricConf() != null) {\n    conf=getConfiguration().getOffheapMetricConf().get(metricName);\n  }\n  if (counters == null) {\nsynchronized (this) {\n      if (counters == null) {\n        if (conf != null) {\n          counters=CacheManager.getCounterOffHeapCache(metricName,conf);\n        }\n else {\n          counters=CacheManager.getCounterCache();\n        }\n        groupbyWithTagsMetricMap.put(metricName,counters);\n      }\n    }\n  }\n  MCMetricGroupDemension groupDemension=null;\n  String tag_time=null;\n  if (tags == null || tags.isEmpty()) {\n    groupDemension=new MCMetricGroupDemension(metricName,groupId);\n  }\n else {\n    if (tags.containsKey(MCConstant.TAG_TIME_IGNORE)) {\n      tag_time=tags.remove(MCConstant.TAG_TIME_IGNORE);\n    }\n    groupDemension=new MCMetricGroupDemension(metricName,groupId,tags);\n  }\n  Counter counter=counters.get(groupDemension);\n  if (counter == null) {\n    if (isAvg) {\n      counter=new AvgCounter();\n    }\n else {\n      counter=new Counter();\n    }\n    if (conf == null) {\n      counters.put(groupDemension,counter);\n    }\n  }\n  if (tag_time != null) {\n    counter.setLastCounterTime(tag_time);\n  }\n  if (isAvg) {\n    ((AvgCounter)counter).inc(count,total);\n  }\n else {\n    if (count != null) {\n      counter.inc(count);\n    }\n else {\n      counter.inc();\n    }\n  }\n  if (conf != null) {\n    counters.put(groupDemension,counter);\n  }\n  return counter;\n}\n",
        "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MCSummingProcessor.java",
        "Start": 9927,
        "Stop": 12300,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "getCounterByMetricDemensionAndInc"
    },
    {
        "Method_Improvements": [{
            "Improvements": [{
                "Improvement": "Use try-with-resources statement",
                "Change_Diff": "- SessionizerConfigValidator validator = new SessionizerConfigValidator(config, newBean);\n+ try (SessionizerConfigValidator validator = new SessionizerConfigValidator(config, newBean)) {",
                "Description": "Instead of manually closing the SessionizerConfigValidator, use a try-with-resources statement to ensure it is automatically closed.",
                "Start": 16,
                "End": 16
            }],
            "Final code": "@Override\nprotected void processApplicationEvent(ApplicationEvent event) {\n  if (event instanceof ContextBeanChangedEvent) {\n    ContextBeanChangedEvent bcInfo = (ContextBeanChangedEvent) event;\n    SessionizerConfig newBean = (SessionizerConfig) (bcInfo.getApplicationContext().getBean(config.getBeanName()));\n    if (newBean != lastConfig) {\n      lastConfig = newBean;\n      try (SessionizerConfigValidator validator = new SessionizerConfigValidator(config, newBean)) {\n        List<String> errors = validator.validate();\n        if (!errors.isEmpty()) {\n          throw new IllegalArgumentException(\"Config error: \" + errors);\n        }\n        int readQueryTimeout = config.getReadQueryTimeout();\n        boolean enableReadOptimization = config.getEnableReadOptimization();\n        int maxIdleTime = config.getMaxIdleTime();\n        List<SessionProfile> mainSessionProfiles = config.getMainSessionProfiles();\n        EPL epl = config.getEpl();\n        List<String> imports = config.getImports();\n        EsperDeclaredEvents rawEventDefinition = config.getRawEventDefinition();\n        config.setReadQueryTimeout(newBean.getReadQueryTimeout();\n        config.setEnableReadOptimization(newBean.getEnableReadOptimization();\n        config.setMaxIdleTime(newBean.getMaxIdleTime();\n        config.setMainSessionProfiles(newBean.getMainSessionProfiles();\n        config.setEpl(newBean.getEpl();\n        config.setImports(newBean.getImports();\n        config.setRawEventDefinition(newBean.getRawEventDefinition();\n        boolean isSuccess = false;\n        try {\n          for (SessionizerRunnable task : tasks) {\n            task.newCompiledConfig = new CompiledConfig(config, task);\n          }\n          isSuccess = true;\n        } finally {\n          if (!isSuccess) {\n            for (SessionizerRunnable task : tasks) {\n              if (task.newCompiledConfig != null) {\n                task.newCompiledConfig.destroy();\n                task.newCompiledConfig = null;\n              }\n            }\n            config.setReadQueryTimeout(readQueryTimeout);\n            config.setEnableReadOptimization(enableReadOptimization);\n            config.setMaxIdleTime(maxIdleTime);\n            config.setMainSessionProfiles(mainSessionProfiles);\n            config.setEpl(epl);\n            config.setImports(imports);\n            config.setRawEventDefinition(rawEventDefinition);\n          }\n        }\n        refreshConfig();\n      }\n    }\n  }\n}"
        }],
        "Old_Method": "@Override protected void processApplicationEvent(ApplicationEvent event){\n  if (event instanceof ContextBeanChangedEvent) {\n    ContextBeanChangedEvent bcInfo=(ContextBeanChangedEvent)event;\n    SessionizerConfig newBean=(SessionizerConfig)(bcInfo.getApplicationContext().getBean(config.getBeanName()));\n    if (newBean != lastConfig) {\n      lastConfig=newBean;\n      SessionizerConfigValidator validator=new SessionizerConfigValidator(config,newBean);\n      List<String> errors=validator.validate();\n      if (!errors.isEmpty()) {\n        throw new IllegalArgumentException(\"Config error: \" + errors);\n      }\n      int readQueryTimeout=config.getReadQueryTimeout();\n      boolean enableReadOptimization=config.getEnableReadOptimization();\n      int maxIdleTime=config.getMaxIdleTime();\n      List<SessionProfile> mainSessionProfiles=config.getMainSessionProfiles();\n      EPL epl=config.getEpl();\n      List<String> imports=config.getImports();\n      EsperDeclaredEvents rawEventDefinition=config.getRawEventDefinition();\n      config.setReadQueryTimeout(newBean.getReadQueryTimeout());\n      config.setEnableReadOptimization(newBean.getEnableReadOptimization());\n      config.setMaxIdleTime(newBean.getMaxIdleTime());\n      config.setMainSessionProfiles(newBean.getMainSessionProfiles());\n      config.setEpl(newBean.getEpl());\n      config.setImports(newBean.getImports());\n      config.setRawEventDefinition(newBean.getRawEventDefinition());\n      boolean isSuccess=false;\n      try {\n        for (        SessionizerRunnable task : tasks) {\n          task.newCompiledConfig=new CompiledConfig(config,task);\n        }\n        isSuccess=true;\n      }\n  finally {\n        if (!isSuccess) {\n          for (          SessionizerRunnable task : tasks) {\n            if (task.newCompiledConfig != null) {\n              task.newCompiledConfig.destroy();\n              task.newCompiledConfig=null;\n            }\n          }\n          config.setReadQueryTimeout(readQueryTimeout);\n          config.setEnableReadOptimization(enableReadOptimization);\n          config.setMaxIdleTime(maxIdleTime);\n          config.setMainSessionProfiles(mainSessionProfiles);\n          config.setEpl(epl);\n          config.setImports(imports);\n          config.setRawEventDefinition(rawEventDefinition);\n        }\n      }\n      refreshConfig();\n    }\n  }\n}\n",
        "File_Path": "realtime-analytics/sessionizer/src/main/java/com/ebay/pulsar/sessionizer/impl/SessionizerProcessor.java",
        "Start": 70925,
        "Stop": 73856,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "processApplicationEvent"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Separate the code into smaller methods",
                    "Change_Diff": "- private void publishAsync(final JetstreamEvent event){\n+ private void publishAsync(final JetstreamEvent event){\n+   if (config.getEnableCassandra()) {\n+     worker.submit(new Runnable(){\n+       @Override public void run(){\n+         try {\n+           processEvent(event);\n+         }\ncatch (Exception ex) {\n+           handleException(event, ex);\n+         }\n+       }\n+     });\n+   }\n}",
                    "Description": "The current method is quite long and contains multiple tasks. It would be better to separate these tasks into smaller methods, each with a specific responsibility. This will improve code readability and maintainability.",
                    "Start": 1,
                    "End": 95
                },
                {
                    "Improvement": "Extract event processing logic into a separate method",
                    "Change_Diff": "-            } \ncatch (Exception ex) {\n-              LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n-              cassandraErrorCount.increment();\n-              if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n-                event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n-              }\n-              getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n-              eventSentToAdviceListener.increment();\n-              registerError(ex);\n-            }",
                    "Description": "Extract the logic for processing the event into a separate method. This will make the code more modular and easier to understand.",
                    "Start": 43,
                    "Final Code": "private void processEvent(final JetstreamEvent event) {\n  try {\n    // event processing logic goes here\n  }\ncatch (Exception ex) {\n  LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n  cassandraErrorCount.increment();\n  if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n    event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n  }\n  getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n  eventSentToAdviceListener.increment();\n  registerError(ex);\n}",
                    "End": 95
                },
                {
                    "Improvement": "Extract metric specific logic into separate methods",
                    "Change_Diff": "-          boolean counterTable=columnFamilyName.contains(COUNTER_TABLE);\n+          boolean counterTable=isCounterTable(columnFamilyName);\n\n-          if (counterTable) {\n-            if (tags == null) {\n-              tags=new HashMap<String,String>();\n-              tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n-            }\n-            Calendar c=Calendar.getInstance();\n-            c.setTimeInMillis(metricTime);\n-          }\n+          if (counterTable) {\n+            processCounterTable(event, tags, metricTime);\n+          }\n",
                    "Description": "There is logic specific to metrics and counter tables that can be extracted into separate methods. This will make the code more organized and easier to maintain.",
                    "Start": 36,
                    "Final Code": "private boolean isCounterTable(String columnFamilyName) {\n  return columnFamilyName.contains(COUNTER_TABLE);\n}\n\nprivate void processCounterTable(final JetstreamEvent event, Map<String,String> tags, long metricTime) {\n  if (tags == null) {\n    tags=new HashMap<String,String>();\n    tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n  }\n  Calendar c=Calendar.getInstance();\n  c.setTimeInMillis(metricTime);\n}",
                    "End": 95
                }
            ],
            "Final code": "private void publishAsync(final JetstreamEvent event){\n  if (config.getEnableCassandra()) {\n    worker.submit(new Runnable(){\n      @Override public void run(){\n        try {\n          processEvent(event);\n        }\ncatch (Exception ex) {\n  handleException(event, ex);\n}\n}\n});\n}\n}\n\nprivate void processEvent(final JetstreamEvent event) {\n  try {\n    String metricName=(String)event.get(MCConstant.METRIC_NAME);\n    String columnFamilyName=event.getEventType().toLowerCase();\n    String groupId=null;\n    Map<String,String> tags=null;\n    if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n      MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n      groupId=groupDemension.getGroupId();\n      if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n        tags=new HashMap<String,String>(groupDemension.getDimensions());\n        tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n      }\n      else {\n        tags=groupDemension.getDimensions();\n      }\n    }\n    if (groupId == null) {\n      if (event.get(MCConstant.GROUP_ID) != null) {\n        groupId=(String)event.get(MCConstant.GROUP_ID);\n      }\n      else {\n        groupId=metricName;\n      }\n    }\n    long count=0;\n    if (event.get(MCConstant.AGGREGATED_COUNT) != null) {\n      count=(Long)event.get(MCConstant.AGGREGATED_COUNT);\n    }\n    else {\n      count=(Long)event.get(MCConstant.METRIC_COUNT);\n    }\n    long metricTime=(Long)event.get(MCConstant.METRIC_TIME);\n    if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && (event.get(MCConstant.FIRST_FLUSH) == null)) {\n      metricTime=(metricTime / 60000) * 60000;\n    }\n    boolean counterTable=isCounterTable(columnFamilyName);\n    if (counterTable) {\n      processCounterTable(event, tags, metricTime);\n    }\n    if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n      if (counterTable) {\n        if (updatestmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatementsForUpdate(columnFamilyName,tags);\n          }\n          else {\n            prepareStatementsForUpdate(columnFamilyName,null);\n          }\n        }\n      }\n      else {\n        if (stmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatements(columnFamilyName,tags);\n          }\n          else {\n            prepareStatements(columnFamilyName,null);\n          }\n        }\n      }\n      metricColumnFamily.put(metricName,columnFamilyName);\n    }\n    if (config.getBatchSize() > 1) {\n      MetricCounter metric=new MetricCounter(metricName,groupId,tags,count,metricTime);\n      meticCounters.add(metric);\n      int counterSize=meticCounters.size();\n      if (counterSize >= config.getBatchSize()) {\n        publishToCassandraInBatch();\n      }\n      else if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n        publishToCassandraInBatch();\n      }\n    }\n    else {\n      if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n      }\n      int parameterSize=4;\n      if (tags != null) {\n        parameterSize=4 + tags.size();\n      }\n      Object[] paramterValues=new Object[parameterSize];\n      if (counterTable) {\n        paramterValues[0]=count;\n        paramterValues[1]=metricName;\n        paramterValues[2]=groupId;\n        paramterValues[3]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[3 + i]=entry.getValue();\n            i++;\n          }\n        }\n      }\n      else {\n        paramterValues[0]=metricName;\n        paramterValues[1]=groupId;\n        paramterValues[2]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[2 + i]=entry.getValue();\n            i++;\n          }\n        }\n        paramterValues[parameterSize - 1]=Long.valueOf(count).intValue();\n      }\n      publishToCassandra(paramterValues,event);\n    }\n  }\ncatch (Exception ex) {\n  handleException(event, ex);\n}\n}\n\nprivate boolean isCounterTable(String columnFamilyName) {\n  return columnFamilyName.contains(COUNTER_TABLE);\n}\n\nprivate void processCounterTable(final JetstreamEvent event, Map<String,String> tags, long metricTime) {\n  if (tags == null) {\n    tags=new HashMap<String,String>();\n    tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n  }\n  Calendar c=Calendar.getInstance();\n  c.setTimeInMillis(metricTime);\n}\n\nprivate void handleException(final JetstreamEvent event, Exception ex) {\n  LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n  cassandraErrorCount.increment();\n  if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n    event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n  }\n  getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n  eventSentToAdviceListener.increment();\n  registerError(ex);\n}"
        }],
        "Old_Method": "private void publishAsync(final JetstreamEvent event){\n  if (config.getEnableCassandra()) {\n    worker.submit(new Runnable(){\n      @Override public void run(){\n        try {\n          String metricName=(String)event.get(MCConstant.METRIC_NAME);\n          String columnFamilyName=event.getEventType().toLowerCase();\n          String groupId=null;\n          Map<String,String> tags=null;\n          if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n            MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n            groupId=groupDemension.getGroupId();\n            if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n              tags=new HashMap<String,String>(groupDemension.getDimensions());\n              tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n            }\n else {\n              tags=groupDemension.getDimensions();\n            }\n          }\n          if (groupId == null) {\n            if (event.get(MCConstant.GROUP_ID) != null) {\n              groupId=(String)event.get(MCConstant.GROUP_ID);\n            }\n else {\n              groupId=metricName;\n            }\n          }\n          long count=0;\n          if (event.get(MCConstant.AGGREGATED_COUNT) != null) {\n            count=(Long)event.get(MCConstant.AGGREGATED_COUNT);\n          }\n else {\n            count=(Long)event.get(MCConstant.METRIC_COUNT);\n          }\n          long metricTime=(Long)event.get(MCConstant.METRIC_TIME);\n          if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && (event.get(MCConstant.FIRST_FLUSH) == null)) {\n            metricTime=(metricTime / 60000) * 60000;\n          }\n          boolean counterTable=columnFamilyName.contains(COUNTER_TABLE);\n          if (counterTable) {\n            if (tags == null) {\n              tags=new HashMap<String,String>();\n              tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n            }\n            Calendar c=Calendar.getInstance();\n            c.setTimeInMillis(metricTime);\n          }\n          if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n            if (counterTable) {\n              if (updatestmtMap.get(columnFamilyName) == null) {\n                if (tags != null && tags.size() > 0) {\n                  prepareStatementsForUpdate(columnFamilyName,tags);\n                }\n else {\n                  prepareStatementsForUpdate(columnFamilyName,null);\n                }\n              }\n            }\n else {\n              if (stmtMap.get(columnFamilyName) == null) {\n                if (tags != null && tags.size() > 0) {\n                  prepareStatements(columnFamilyName,tags);\n                }\n else {\n                  prepareStatements(columnFamilyName,null);\n                }\n              }\n            }\n            metricColumnFamily.put(metricName,columnFamilyName);\n          }\n          if (config.getBatchSize() > 1) {\n            MetricCounter metric=new MetricCounter(metricName,groupId,tags,count,metricTime);\n            meticCounters.add(metric);\n            int counterSize=meticCounters.size();\n            if (counterSize >= config.getBatchSize()) {\n              publishToCassandraInBatch();\n            }\n else             if (event.get(LASTEVENTINBATCH) != null) {\n              ePLBatchCount.increment();\n              publishToCassandraInBatch();\n            }\n          }\n else {\n            if (event.get(LASTEVENTINBATCH) != null) {\n              ePLBatchCount.increment();\n            }\n            int parameterSize=4;\n            if (tags != null) {\n              parameterSize=4 + tags.size();\n            }\n            Object[] paramterValues=new Object[parameterSize];\n            if (counterTable) {\n              paramterValues[0]=count;\n              paramterValues[1]=metricName;\n              paramterValues[2]=groupId;\n              paramterValues[3]=new Date(metricTime);\n              int i=1;\n              if (tags != null) {\n                for (                Map.Entry<String,String> entry : tags.entrySet()) {\n                  paramterValues[3 + i]=entry.getValue();\n                  i++;\n                }\n              }\n            }\n else {\n              paramterValues[0]=metricName;\n              paramterValues[1]=groupId;\n              paramterValues[2]=new Date(metricTime);\n              int i=1;\n              if (tags != null) {\n                for (                Map.Entry<String,String> entry : tags.entrySet()) {\n                  paramterValues[2 + i]=entry.getValue();\n                  i++;\n                }\n              }\n              paramterValues[parameterSize - 1]=Long.valueOf(count).intValue();\n            }\n            publishToCassandra(paramterValues,event);\n          }\n        }\n catch (        Exception ex) {\n          LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n          cassandraErrorCount.increment();\n          if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n            event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n          }\n          getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n          eventSentToAdviceListener.increment();\n          registerError(ex);\n        }\n      }\n    }\n);\n  }\n}\n",
        "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MetricCassandraCollector.java",
        "Start": 10804,
        "Stop": 19857,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "publishAsync"
    },
    {
        "Method_Improvements": [{
            "details": "Expected a ',' or '}' at 994 [character 69 line 18]",
            "error": "An unexpected error occurred"
        }],
        "Old_Method": "private GeoInfo _getGeoInfo(String ipAddress){\n  GeoInfo geoInfo=new GeoInfo();\n  if (ipAddress == null) {\n    return geoInfo;\n  }\n  try {\n    InetAddress inetAddress=InetAddress.getByName(ipAddress);\n    CityResponse response=reader.city(inetAddress);\n    Country country=response.getCountry();\n    Continent continent=response.getContinent();\n    City city=response.getCity();\n    Postal postal=response.getPostal();\n    Location location=response.getLocation();\n    Subdivision subdivision=response.getMostSpecificSubdivision();\n    geoInfo.setRegion(subdivision.getName());\n    geoInfo.setCountryIsoCode(country.getIsoCode());\n    geoInfo.setCountry(country.getName());\n    geoInfo.setContinent(continent.getCode());\n    geoInfo.setCity(city.getName());\n    geoInfo.setPostalCode(postal.getCode());\n    geoInfo.setLatitude(location.getLatitude());\n    geoInfo.setLongitude(location.getLongitude());\n    return geoInfo;\n  }\n catch (  Exception ex) {\n    return null;\n  }\n}\n",
        "File_Path": "realtime-analytics/collector/src/main/java/com/ebay/pulsar/collector/udf/GeoEnrichmentUtil.java",
        "Start": 1289,
        "Stop": 2470,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "_getGeoInfo"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use a StringBuilder instead of concatenating strings",
                    "Change_Diff": "- builder.append(\"MemoryManager-\");\n- builder.append(entry.getKey());\n- builder.append(\":\");\n+ builder.append(\"MemoryManager-\").append(entry.getKey()).append(\":\");",
                    "Description": "Instead of concatenating strings using the '+' operator, use a StringBuilder to improve performance and memory usage.",
                    "Start": 6,
                    "End": 6
                },
                {
                    "Improvement": "Use an enhanced for loop instead of an iterator",
                    "Change_Diff": "- for (Map.Entry<String, OffHeapMemoryManager> entry : memoryManagers.entrySet()) {\n+ for (String key : memoryManagers.keySet()) {\n+     Map.Entry<String, OffHeapMemoryManager> entry = memoryManagers.get(key);",
                    "Description": "Instead of using the entry set iterator, use an enhanced for loop with just the keys to simplify the loop and improve readability.",
                    "Start": 7,
                    "End": 7
                },
                {
                    "Improvement": "Reuse the StringBuilder object to avoid creating new instances",
                    "Change_Diff": "- StringBuilder builder = new StringBuilder();\n+ StringBuilder builder = new StringBuilder(\"InternalOffHeapManagerInfo:\");",
                    "Description": "Initialize the StringBuilder with the initial string to avoid creating a new instance and improve performance.",
                    "Start": 1,
                    "End": 1
                }
            ],
            "Final code": "public String getInternalOffHeapManagerInfo() {\n  StringBuilder builder = new StringBuilder(\"InternalOffHeapManagerInfo:\");\n  Map<String, OffHeapMemoryManager> memoryManagers = OffHeapMemoryManagerRegistry.getInstance().getMemoryManagers();\n  for (String key : memoryManagers.keySet()) {\n    Map.Entry<String, OffHeapMemoryManager> entry = memoryManagers.get(key);\n    builder.append(\"MemoryManager-\").append(entry.getKey()).append(\":\");\n    OffHeapMemoryManager manager = entry.getValue();\n    if (manager != null) {\n      builder.append(\"[\");\n      builder.append(\"FreeMemory:\").append(manager.getFreeMemory()).append(\";\");\n      builder.append(\"MaxMemory:\").append(manager.getMaxMemory()).append(\";\");\n      builder.append(\"ReservedMemory:\").append(manager.getReservedMemory()).append(\";\");\n      builder.append(\"UsedMemory:\").append(manager.getUsedMemory()).append(\";\");\n      builder.append(\"OutOfMeomoryErrorCount:\").append(manager.getOOMErrorCount()).append(\"]\");\n    }\n  }\n  return builder.toString();\n}"
        }],
        "Old_Method": "public String getInternalOffHeapManagerInfo(){\n  StringBuilder builder=new StringBuilder();\n  builder.append(\"InternalOffHeapManagerInfo:\");\n  Map<String,OffHeapMemoryManager> memoryManagers=OffHeapMemoryManagerRegistry.getInstance().getMemoryManagers();\n  for (  Map.Entry<String,OffHeapMemoryManager> entry : memoryManagers.entrySet()) {\n    builder.append(\"MemoryManager-\");\n    builder.append(entry.getKey());\n    builder.append(\":\");\n    OffHeapMemoryManager manager=entry.getValue();\n    if (manager != null) {\n      builder.append(\"[\");\n      builder.append(\"FreeMemory:\");\n      builder.append(manager.getFreeMemory());\n      builder.append(\";\");\n      builder.append(\"MaxMemory:\");\n      builder.append(manager.getMaxMemory());\n      builder.append(\";\");\n      builder.append(\"ReservedMemory:\");\n      builder.append(manager.getReservedMemory());\n      builder.append(\";\");\n      builder.append(\"UsedMemory:\");\n      builder.append(manager.getUsedMemory());\n      builder.append(\";\");\n      builder.append(\"OutOfMeomoryErrorCount:\");\n      builder.append(manager.getOOMErrorCount());\n      builder.append(\"]\");\n    }\n  }\n  return builder.toString();\n}\n",
        "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MCSummingProcessor.java",
        "Start": 27123,
        "Stop": 28572,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "getInternalOffHeapManagerInfo"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use for-each loop instead of while loop",
                    "Change_Diff": "- while ((event=localQueue.poll()) != null) {\n+ for (JetstreamEvent event : localQueue) {",
                    "Description": "Instead of using a while loop to iterate over `localQueue`, use a for-each loop.",
                    "Start": 9,
                    "End": 9
                },
                {
                    "Improvement": "Use switch statement instead of multiple if-else statements",
                    "Change_Diff": "- if (REFRESH_EVENT == event) {\n+ switch (event) {\n+     case REFRESH_EVENT:",
                    "Description": "Replace multiple if-else statements to check different event types with a switch statement.",
                    "Start": 24,
                    "End": 26
                }
            ],
            "Final code": "@Override\npublic void run() {\n    while (running) {\n        for (JetstreamEvent event : localQueue) {\n            @SuppressWarnings(\"unchecked\") LinkedList<SessionizationInfo> pendingSessionizers=(LinkedList<SessionizationInfo>)event.get(SESSIONIZER_LIST);\n            SessionizationInfo next=pendingSessionizers.removeFirst();\n            if (pendingSessionizers.isEmpty()) {\n                event.remove(SESSIONIZER_LIST);\n            }\n            processSessionizableEvent(event,sessionizerMap.get(next.getName()),next);\n        }\n        try {\n            event=responseQueue.poll();\n            if (event == null) {\n                event=requestQueue.take();\n            }\n        } catch (InterruptedException e) {\n            continue;\n        }\n        switch (event) {\n            case REFRESH_EVENT:\n                refreshCounter.incrementAndGet();\n                continue;\n            case RESET_EVENT:\n                resetHighWaterMark();\n                continue;\n            case CONFIG_REFRESH_EVENT:\n                try {\n                    updateConfig(config);\n                } catch (Throwable ex) {\n                    exceptionCounter.incrementAndGet();\n                    errorManager.registerError(ex,ErrorType.Unexpected);\n                }\n                continue;\n        }\n        try {\n            if (TIMER_EVENT == event || event == CONTINUE_EXPIRATION_EVENT) {\n                expiredTimeoutSessions(event);\n            } else {\n                String eventType=(String)event.get(JS_EVENT_TYPE);\n                if (!interEventTypes.contains(eventType)) {\n                    eventCounters[taskId]++;\n                    Map<String,SessionizationInfo> m=selector.process(event);\n                    if (m == null || m.isEmpty()) {\n                        bypassEventCounter++;\n                        sendRawEvent(event);\n                    } else if (m.size() == 1) {\n                        Entry<String,SessionizationInfo> entry=m.entrySet().iterator().next();\n                        event.put(CURRENT_SESSIOIZERINFO,entry.getValue());\n                        processSessionizableEvent(event,sessionizerMap.get(entry.getKey()),entry.getValue());\n                    } else {\n                        LinkedList<SessionizationInfo> slist=new LinkedList<SessionizationInfo>(m.values());\n                        event.put(SESSIONIZER_LIST,slist);\n                        SessionizationInfo sessionizationInfo=slist.removeFirst();\n                        event.put(CURRENT_SESSIOIZERINFO,sessionizationInfo);\n                        processSessionizableEvent(event,sessionizerMap.get(sessionizationInfo.getName()),sessionizationInfo);\n                    }\n                } else {\n                    handleInternalEvent(event,eventType);\n                }\n            }\n        } catch (Throwable ex) {\n            exceptionCounter.incrementAndGet();\n            errorManager.registerError(ex,event,ErrorType.Unexpected);\n        }\n    }\n}"
        }],
        "Old_Method": "@Override public void run(){\n  while (running) {\n    JetstreamEvent event;\n    while ((event=localQueue.poll()) != null) {\n      @SuppressWarnings(\"unchecked\") LinkedList<SessionizationInfo> pendingSessionizers=(LinkedList<SessionizationInfo>)event.get(SESSIONIZER_LIST);\n      SessionizationInfo next=pendingSessionizers.removeFirst();\n      if (pendingSessionizers.isEmpty()) {\n        event.remove(SESSIONIZER_LIST);\n      }\n      processSessionizableEvent(event,sessionizerMap.get(next.getName()),next);\n    }\n    try {\n      event=responseQueue.poll();\n      if (event == null) {\n        event=requestQueue.take();\n      }\n    }\n catch (    InterruptedException e) {\n      continue;\n    }\n    if (REFRESH_EVENT == event) {\n      refreshCounter.incrementAndGet();\n      continue;\n    }\n else     if (RESET_EVENT == event) {\n      resetHighWaterMark();\n      continue;\n    }\n else     if (CONFIG_REFRESH_EVENT == event) {\n      try {\n        updateConfig(config);\n      }\n catch (      Throwable ex) {\n        exceptionCounter.incrementAndGet();\n        errorManager.registerError(ex,ErrorType.Unexpected);\n      }\n      continue;\n    }\n    try {\n      if (TIMER_EVENT == event || event == CONTINUE_EXPIRATION_EVENT) {\n        expiredTimeoutSessions(event);\n      }\n else {\n        String eventType=(String)event.get(JS_EVENT_TYPE);\n        if (!interEventTypes.contains(eventType)) {\n          eventCounters[taskId]++;\n          Map<String,SessionizationInfo> m=selector.process(event);\n          if (m == null || m.isEmpty()) {\n            bypassEventCounter++;\n            sendRawEvent(event);\n          }\n else           if (m.size() == 1) {\n            Entry<String,SessionizationInfo> entry=m.entrySet().iterator().next();\n            event.put(CURRENT_SESSIOIZERINFO,entry.getValue());\n            processSessionizableEvent(event,sessionizerMap.get(entry.getKey()),entry.getValue());\n          }\n else {\n            LinkedList<SessionizationInfo> slist=new LinkedList<SessionizationInfo>(m.values());\n            event.put(SESSIONIZER_LIST,slist);\n            SessionizationInfo sessionizationInfo=slist.removeFirst();\n            event.put(CURRENT_SESSIOIZERINFO,sessionizationInfo);\n            processSessionizableEvent(event,sessionizerMap.get(sessionizationInfo.getName()),sessionizationInfo);\n          }\n        }\n else {\n          handleInternalEvent(event,eventType);\n        }\n      }\n    }\n catch (    Throwable ex) {\n      exceptionCounter.incrementAndGet();\n      errorManager.registerError(ex,event,ErrorType.Unexpected);\n    }\n  }\n}\n",
        "File_Path": "realtime-analytics/sessionizer/src/main/java/com/ebay/pulsar/sessionizer/impl/SessionizerProcessor.java",
        "Start": 32821,
        "Stop": 36449,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "run"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use diamond operator in declaration",
                    "Change_Diff": "- private List<JetstreamEvent> createJetStreamGroupbyCountEventsWithTags(String metricName){\n+ private List<JetstreamEvent> createJetStreamGroupbyCountEventsWithTags(String metricName){",
                    "Description": "Use diamond operator (`<>`) in declarations to infer generic types instead of explicitly writing them.",
                    "Start": 2,
                    "End": 2
                },
                {
                    "Improvement": "Use isEmpty() method to check for empty maps",
                    "Change_Diff": "- if (counterMap == null)   return Collections.emptyList();\n+ if (counterMap.isEmpty())   return Collections.emptyList();",
                    "Description": "Use the `isEmpty()` method to check if a map is empty instead of comparing it with `null`.",
                    "Start": 4,
                    "End": 4
                },
                {
                    "Improvement": "Use try-with-resources for synchronized block",
                    "Change_Diff": "- synchronized (this) {\n+ try (CacheManager cm = new CacheManager()) {",
                    "Description": "Use `try-with-resources` statement when using `synchronized` block to automatically close the resource after it is no longer needed.",
                    "Start": 15,
                    "End": 16
                },
                {
                    "Improvement": "Use ternary operator instead of if-else",
                    "Change_Diff": "- if (threshold != null) {\n-   _threshold = threshold.intValue();\n- }\n+ _threshold = (threshold != null) ? threshold.intValue() : 0;",
                    "Description": "Use ternary operator instead of if-else statement to simplify the code and make it more concise.",
                    "Start": 21,
                    "End": 21
                },
                {
                    "Improvement": "Use Map.putAll() instead of individual put() calls",
                    "Change_Diff": "- groupbyWithTagsMetricMap.put(metricName,newCounterMap);\n+ groupbyWithTagsMetricMap.putAll(newCounterMap);",
                    "Description": "Use the `putAll()` method to add all elements from one map to another instead of individually calling the `put()` method.",
                    "Start": 30,
                    "End": 31
                },
                {
                    "Improvement": "Use List.copyOf() to create an immutable list",
                    "Change_Diff": "- List<JetstreamEvent> result = new ArrayList<JetstreamEvent>(counterMap.size());\n+ List<JetstreamEvent> result = List.copyOf(counterMap.size());",
                    "Description": "Use the `List.copyOf()` method to create an immutable copy of the list instead of creating a new ArrayList and copying the elements.",
                    "Start": 42,
                    "End": 42
                },
                {
                    "Improvement": "Use System.nanoTime() instead of System.currentTimeMillis()",
                    "Change_Diff": "- long now = System.currentTimeMillis();\n+ long now = System.nanoTime();",
                    "Description": "Use the `System.nanoTime()` method instead of `System.currentTimeMillis()` to get a more accurate measure of time.",
                    "Start": 44,
                    "End": 44
                },
                {
                    "Improvement": "Use entrySet() to iterate over map entries",
                    "Change_Diff": "- for (Map.Entry<MCMetricGroupDemension, Counter> entry : counterMap.entrySet()) {\n-   MCMetricGroupDemension groupDemension = entry.getKey();\n-   Counter counter = entry.getValue();\n+ for (Map.Entry<MCMetricGroupDemension, Counter> entry : counterMap.entrySet()) {\n+   MCMetricGroupDemension groupDemension = entry.getKey();\n+   Counter counter = entry.getValue();",
                    "Description": "Use the `entrySet()` method to get a set view of the map entries and iterate over them instead of using `keySet()` and retrieving the value for each key.",
                    "Start": 47,
                    "End": 54
                },
                {
                    "Improvement": "Use removeIf() to remove entries from a map",
                    "Change_Diff": "- if (timeBasedMetric && counter.getLastDeltaValue() == 0) {\n-   counterMap.remove(groupDemension);\n- }\n+ counterMap.entrySet().removeIf(entry -> entry.getKey().getDimensions() != null && entry.getKey().getDimensions().get(MCCounterHelper.TAG_METRICTIME) != null && entry.getValue().getLastDeltaValue() == 0);",
                    "Description": "Use the `removeIf()` method to remove entries from a map that satisfy a given condition instead of manually iterating over the map entries and removing them.",
                    "Start": 80,
                    "End": 80
                },
                {
                    "Improvement": "Use Map.put() instead of put() followed by putAll()",
                    "Change_Diff": "- internalMap.put(MCConstant.METRIC_FREQUENCY, getFrequencyByMetricName(metricName));\n+ internalMap.put(MCConstant.METRIC_FREQUENCY, getFrequencyByMetricName(metricName));\n+ internalMap.putAll(groupDemension);",
                    "Description": "Use the `put()` method to add an entry to a map instead of calling `putAll()` after calling `put()`.",
                    "Start": 92,
                    "End": 93
                },
                {
                    "Improvement": "Use put() instead of putIfAbsent()",
                    "Change_Diff": "- if ((metricCollectionCounts.get(metricName) != null) && metricCollectionCounts.get(metricName).get() == 1) {\n-   internalMap.putIfAbsent(MCConstant.FIRST_FLUSH, MCConstant.FIRST_FLUSH);\n- }\n+ if ((metricCollectionCounts.get(metricName) != null) && metricCollectionCounts.get(metricName).get() == 1) {\n+   internalMap.put(MCConstant.FIRST_FLUSH, MCConstant.FIRST_FLUSH);\n+ }",
                    "Description": "Use the `put()` method instead of `putIfAbsent()` as the `put()` method can be used for both adding a new entry and updating an existing entry.",
                    "Start": 99,
                    "End": 99
                },
                {
                    "Improvement": "Use Map.isEmpty() instead of checking size()",
                    "Change_Diff": "- if (result.size() > 0) {\n+ if (!result.isEmpty()) {",
                    "Description": "Use the `isEmpty()` method to check if a map is empty instead of comparing its size with zero.",
                    "Start": 105,
                    "End": 105
                },
                {
                    "Improvement": "Use clear() instead of assigning null to a map",
                    "Change_Diff": "- counterMap.clear();\n- counterMap = null;\n+ counterMap.clear();",
                    "Description": "Use the `clear()` method to remove all entries from a map instead of assigning `null` to the map.",
                    "Start": 110,
                    "End": 111
                }
            ],
            "Final code": "private List<JetstreamEvent> createJetStreamGroupbyCountEventsWithTags(String metricName) {\n  Map<MCMetricGroupDemension, Counter> counterMap = groupbyWithTagsMetricMap.get(metricName);\n  if (counterMap.isEmpty())\n    return Collections.emptyList();\n\n  OffHeapCacheConfig conf = null;\n  if (getConfiguration().getOffheapMetricConf() != null) {\n    conf = getConfiguration().getOffheapMetricConf().get(metricName);\n  }\n\n  Integer threshold = getConfiguration().getMetricsThreshold().get(metricName);\n  int _threshold = (threshold != null) ? threshold.intValue() : 0;\n\n  boolean mapClear = false;\n  if (conf != null) {\n    synchronized (this) {\n      try (CacheManager cm = new CacheManager()) {\n        Map<MCMetricGroupDemension, Counter> newCounterMap = cm.getCounterOffHeapCache(metricName, conf);\n        groupbyWithTagsMetricMap.putAll(newCounterMap);\n      }\n    }\n    mapClear = true;\n  } else if (conf == null && counterMap.size() > getConfiguration().getGroupCounterMax()) {\n    synchronized (this) {\n      try (CacheManager cm = new CacheManager()) {\n        Map<MCMetricGroupDemension, Counter> newCounterMap = cm.getCounterCache();\n        groupbyWithTagsMetricMap.putAll(newCounterMap);\n      }\n    }\n    mapClear = true;\n  }\n\n  List<JetstreamEvent> result = List.copyOf(counterMap.size());\n  long now = System.nanoTime();\n\n  for (Map.Entry<MCMetricGroupDemension, Counter> entry : counterMap.entrySet()) {\n    MCMetricGroupDemension groupDemension = entry.getKey();\n    Counter counter = entry.getValue();\n    counter.mark();\n\n    boolean timeBasedMetric = (groupDemension.getDimensions() != null && groupDemension.getDimensions().get(MCCounterHelper.TAG_METRICTIME) != null);\n\n    if (counter.getLastDeltaValue() > _threshold) {\n      Map<String, Object> internalMap = new LinkedHashMap<>();\n\n      if (timeBasedMetric) {\n        internalMap.put(MCConstant.METRIC_TIME, Long.valueOf(groupDemension.getDimensions().get(MCCounterHelper.TAG_METRICTIME)));\n      } else {\n        internalMap.put(MCConstant.METRIC_TIME, now);\n      }\n\n      if (counter instanceof AvgCounter) {\n        internalMap.put(MCConstant.AGGREGATED_COUNT, ((AvgCounter) counter).getLatestAvgValue());\n      } else {\n        internalMap.put(MCConstant.AGGREGATED_COUNT, counter.getLastDeltaValue());\n      }\n\n      internalMap.put(MCConstant.METRIC_NAME, metricName);\n      internalMap.put(MCConstant.METRIC_FREQUENCY, getFrequencyByMetricName(metricName));\n      internalMap.putAll(groupDemension);\n\n      if (counter.getLastCounterTime() != null) {\n        internalMap.put(MCConstant.TAG_TIME_IGNORE, counter.getLastCounterTime());\n      }\n\n      if (shutdownFlag.get()) {\n        internalMap.put(MCConstant.SHUTDOWN_FLUSH, MCConstant.SHUTDOWN_FLUSH);\n      }\n\n      if ((metricCollectionCounts.get(metricName) != null) && metricCollectionCounts.get(metricName).get() == 1) {\n        internalMap.put(MCConstant.FIRST_FLUSH, MCConstant.FIRST_FLUSH);\n      }\n\n      JetstreamEvent event = new JetstreamEvent(metricTables.get(metricName), null, internalMap);\n      result.add(event);\n    }\n    \n    if (timeBasedMetric && counter.getLastDeltaValue() == 0) {\n      counterMap.entrySet().removeIf(entry -> entry.getKey().getDimensions() != null && entry.getKey().getDimensions().get(MCCounterHelper.TAG_METRICTIME) != null && entry.getValue().getLastDeltaValue() == 0);\n    }\n  }\n\n  if (!result.isEmpty()) {\n    JetstreamEvent lastEvent = result.get(result.size() - 1);\n    lastEvent.put(\"LastEventInBatch\", \"true\");\n  }\n\n  if (mapClear) {\n    counterMap.clear();\n    mapClearCount.increment();\n  }\n  \n  return result;\n}"
        }],
        "Old_Method": "private List<JetstreamEvent> createJetStreamGroupbyCountEventsWithTags(String metricName){\n  Map<MCMetricGroupDemension,Counter> counterMap=groupbyWithTagsMetricMap.get(metricName);\n  if (counterMap == null)   return Collections.emptyList();\n  OffHeapCacheConfig conf=null;\n  if (getConfiguration().getOffheapMetricConf() != null) {\n    conf=getConfiguration().getOffheapMetricConf().get(metricName);\n  }\n  Integer threshold=getConfiguration().getMetricsThreshold().get(metricName);\n  int _threshold=0;\n  if (threshold != null) {\n    _threshold=threshold.intValue();\n  }\n  boolean mapClear=false;\n  if (conf != null) {\nsynchronized (this) {\n      Map<MCMetricGroupDemension,Counter> newCounterMap=CacheManager.getCounterOffHeapCache(metricName,conf);\n      groupbyWithTagsMetricMap.put(metricName,newCounterMap);\n    }\n    mapClear=true;\n  }\n else   if (conf == null && counterMap.size() > getConfiguration().getGroupCounterMax()) {\nsynchronized (this) {\n      Map<MCMetricGroupDemension,Counter> newCounterMap=CacheManager.getCounterCache();\n      groupbyWithTagsMetricMap.put(metricName,newCounterMap);\n    }\n    mapClear=true;\n  }\n  List<JetstreamEvent> result=new ArrayList<JetstreamEvent>(counterMap.size());\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<MCMetricGroupDemension,Counter> entry : counterMap.entrySet()) {\n    MCMetricGroupDemension groupDemension=entry.getKey();\n    Counter counter=entry.getValue();\n    counter.mark();\n    boolean timeBasedMetric=false;\n    if (groupDemension.getDimensions() != null && groupDemension.getDimensions().get(MCCounterHelper.TAG_METRICTIME) != null) {\n      timeBasedMetric=true;\n    }\n    if (counter.getLastDeltaValue() > _threshold) {\n      Map<String,Object> internalMap=new LinkedHashMap<String,Object>();\n      if (timeBasedMetric) {\n        internalMap.put(MCConstant.METRIC_TIME,Long.valueOf(groupDemension.getDimensions().get(MCCounterHelper.TAG_METRICTIME)));\n      }\n else {\n        internalMap.put(MCConstant.METRIC_TIME,now);\n      }\n      if (counter instanceof AvgCounter) {\n        internalMap.put(MCConstant.AGGREGATED_COUNT,((AvgCounter)counter).getLatestAvgValue());\n      }\n else {\n        internalMap.put(MCConstant.AGGREGATED_COUNT,counter.getLastDeltaValue());\n      }\n      internalMap.put(MCConstant.METRIC_NAME,metricName);\n      internalMap.put(MCConstant.METRIC_FREQUENCY,getFrequencyByMetricName(metricName));\n      internalMap.put(MCConstant.METRIC_DEMENSION,groupDemension);\n      if (counter.getLastCounterTime() != null) {\n        internalMap.put(MCConstant.TAG_TIME_IGNORE,counter.getLastCounterTime());\n      }\n      if (shutdownFlag.get()) {\n        internalMap.put(MCConstant.SHUTDOWN_FLUSH,MCConstant.SHUTDOWN_FLUSH);\n      }\n      if ((metricCollectionCounts.get(metricName) != null) && metricCollectionCounts.get(metricName).get() == 1) {\n        internalMap.put(MCConstant.FIRST_FLUSH,MCConstant.FIRST_FLUSH);\n      }\n      JetstreamEvent event=new JetstreamEvent(metricTables.get(metricName),null,internalMap);\n      result.add(event);\n    }\n    if (timeBasedMetric && counter.getLastDeltaValue() == 0) {\n      counterMap.remove(groupDemension);\n    }\n  }\n  if (result.size() > 0) {\n    JetstreamEvent lastEvent=result.get(result.size() - 1);\n    lastEvent.put(\"LastEventInBatch\",\"true\");\n  }\n  if (mapClear) {\n    counterMap.clear();\n    counterMap=null;\n    mapClearCount.increment();\n  }\n  return result;\n}\n",
        "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MCSummingProcessor.java",
        "Start": 13857,
        "Stop": 18700,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "createJetStreamGroupbyCountEventsWithTags"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use early return to avoid unnecessary code execution",
                    "Change_Diff": "- if (transferInSession == null) {\n-   return;\n- }\n+ if (transferInSession == null) return;",
                    "Description": "Instead of using an if-else statement to return early if `transferInSession` is null, use an early return statement.",
                    "Start": 6,
                    "End": 6
                },
                {
                    "Improvement": "Extract method for handling remote session load",
                    "Change_Diff": "- if (remoteDAO != null && remoteDAO.asyncLoadSupport()) {\n-   asyncLoadFromRemoteStore(event,uid,remoteDAO,ak);\n- }\n- else if (remoteDAO != null) {\n-   Session session=remoteDAO.load(uid);\n-   if (session == null) {\n-     session=transferInSession;\n-     if (session != null) {\n-       updateRemoteSession(uid,identifier,session,sessionizer);\n-     }\n-   }\n-   else {\n-     if (session.getFirstEventTimestamp() != transferInSession.getFirstEventTimestamp()) {\n-       transferInSession.setIdentifier(identifier);\n-       transferInSession.setType(sessionizer.getType());\n-       fireSessionEndMarkerEvent(transferInSession,sessionizer);\n-     }\n-   }\n- }\n- else {\n-   updateRemoteSession(uid,identifier,transferInSession,sessionizer);\n- }",
                    "Description": "Extract the code inside the if-else statement into a separate method for better modularity and readability.",
                    "Start": 40,
                    "End": 73
                },
                {
                    "Improvement": "Use localSession variable directly instead of checking for null",
                    "Change_Diff": "- if (localSession == null && !pendingReadEvents.containsKey(uid)) {\n-   ...\n- }\n- else if (localSession != null) {\n-   if (transferInSession.getFirstEventTimestamp() != localSession.getFirstEventTimestamp()) {\n-     ...\n-   }\n- }",
                    "Description": "Instead of checking if `localSession` is null and using the opposite condition in the else block, use the `localSession` variable directly in the condition.",
                    "Start": 76,
                    "End": 89
                }
            ],
            "Final code": "private void handleTransferedSession(String identifier, String uid, JetstreamEvent event, Sessionizer sessionizer) {\n  String ak = (String) event.get(AFFINITY_KEY);\n  Session transferInSession = reconstructSession(event, uid);\n  if (transferInSession == null) return;\n  event.put(Constants.EVENT_PAYLOAD_SESSION_OBJ, transferInSession);\n  sessionizer.updateSessionId(transferInSession);\n  if (transferInSession.getExpirationTime() <= System.currentTimeMillis() && recentlyExpiredSessions.containsKey(transferInSession.getSessionId())) {\n    String s = recentlyExpiredSessions.get(transferInSession.getSessionId());\n    if (Long.parseLong(s.split(\":\")[1]) == transferInSession.getExpirationTime()) {\n      return;\n    }\n  }\n  Session localSession = localSessionCache.get(uid);\n  if (localSession == null && !pendingReadEvents.containsKey(uid)) {\n    handleRemoteSessionLoad(uid, identifier, transferInSession, sessionizer, ak);\n  }\n  else if (localSession != null) {\n    if (transferInSession.getFirstEventTimestamp() != localSession.getFirstEventTimestamp()) {\n      transferInSession.setIdentifier(identifier);\n      transferInSession.setType(sessionizer.getType());\n      fireSessionEndMarkerEvent(transferInSession, sessionizer);\n    }\n  }\n}"
        }],
        "Old_Method": "private void handleTransferedSession(String identifier,String uid,JetstreamEvent event,Sessionizer sessionizer){\n  String ak=(String)event.get(AFFINITY_KEY);\n  Session transferInSession=reconstructSession(event,uid);\n  if (transferInSession == null) {\n    return;\n  }\n  event.put(Constants.EVENT_PAYLOAD_SESSION_OBJ,transferInSession);\n  sessionizer.updateSessionId(transferInSession);\n  if (transferInSession.getExpirationTime() <= System.currentTimeMillis() && recentlyExpiredSessions.containsKey(transferInSession.getSessionId())) {\n    String s=recentlyExpiredSessions.get(transferInSession.getSessionId());\n    if (Long.parseLong(s.split(\":\")[1]) == transferInSession.getExpirationTime()) {\n      return;\n    }\n  }\n  Session localSession=localSessionCache.get(uid);\n  if (localSession == null && !pendingReadEvents.containsKey(uid)) {\n    RemoteStoreProvider remoteDAO=provider;\n    if (remoteDAO != null && remoteDAO.asyncLoadSupport()) {\n      asyncLoadFromRemoteStore(event,uid,remoteDAO,ak);\n    }\n else     if (remoteDAO != null) {\n      Session session=remoteDAO.load(uid);\n      if (session == null) {\n        session=transferInSession;\n        if (session != null) {\n          updateRemoteSession(uid,identifier,session,sessionizer);\n        }\n      }\n else {\n        if (session.getFirstEventTimestamp() != transferInSession.getFirstEventTimestamp()) {\n          transferInSession.setIdentifier(identifier);\n          transferInSession.setType(sessionizer.getType());\n          fireSessionEndMarkerEvent(transferInSession,sessionizer);\n        }\n      }\n    }\n else {\n      updateRemoteSession(uid,identifier,transferInSession,sessionizer);\n    }\n  }\n else   if (localSession != null) {\n    if (transferInSession.getFirstEventTimestamp() != localSession.getFirstEventTimestamp()) {\n      transferInSession.setIdentifier(identifier);\n      transferInSession.setType(sessionizer.getType());\n      fireSessionEndMarkerEvent(transferInSession,sessionizer);\n    }\n  }\n}\n",
        "File_Path": "realtime-analytics/sessionizer/src/main/java/com/ebay/pulsar/sessionizer/impl/SessionizerProcessor.java",
        "Start": 28078,
        "Stop": 31334,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "handleTransferedSession"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use method chaining",
                    "Change_Diff": "- Builder builder = Cluster.builder();\n+ Builder builder = Cluster.builder()\n            .addContactPoints(contactPoints)\n            .withCompression(compression)",
                    "Description": "Use method chaining to simplify the code and improve readability",
                    "Start": 1,
                    "End": 3
                },
                {
                    "Improvement": "Use StringUtils.isNotBlank instead of null check",
                    "Change_Diff": "- if (username != null && password != null) {\n+ if (StringUtils.isNotBlank(username) && StringUtils.isNotBlank(password)) {",
                    "Description": "Use StringUtils.isNotBlank from Apache Commons Lang library to simplify the null check",
                    "Start": 11,
                    "End": 11
                },
                {
                    "Improvement": "Use Objects.nonNull instead of null check",
                    "Change_Diff": "- if (reconnectionPolicy != null) {\n+ if (Objects.nonNull(reconnectionPolicy)) {",
                    "Description": "Use Objects.nonNull from Java 8 to simplify the null check",
                    "Start": 14,
                    "End": 14
                },
                {
                    "Improvement": "Use optional with method chaining instead of null check",
                    "Change_Diff": "- if (retryPolicy != null) {\n+ Optional.ofNullable(retryPolicy).ifPresent(builder::withRetryPolicy);",
                    "Description": "Use Optional.ofNullable with method chaining to simplify the null check",
                    "Start": 17,
                    "End": 17
                },
                {
                    "Improvement": "Use try-with-resources for SocketOptions",
                    "Change_Diff": "- SocketOptions opts = new SocketOptions();\n+ try (SocketOptions opts = new SocketOptions()) {",
                    "Description": "Use try-with-resources to automatically close SocketOptions",
                    "Start": 23,
                    "End": 23
                }
            ],
            "Final code": "public Builder createBuilder(){\n  Builder builder = Cluster.builder()\n            .addContactPoints(contactPoints)\n            .withCompression(compression);\n\n  if (StringUtils.isNotBlank(username) && StringUtils.isNotBlank(password)) {\n    builder.withCredentials(username,password);\n  }\n\n  if (Objects.nonNull(reconnectionPolicy)) {\n    builder.withReconnectionPolicy(reconnectionPolicy);\n  }\n\n  Optional.ofNullable(retryPolicy).ifPresent(builder::withRetryPolicy);\n\n  builder.withPort(port);\n\n  if (!jmxEnabled) {\n    builder.withoutJMXReporting();\n  }\n\n  if (!metricsEnabled) {\n    builder.withoutMetrics();\n  }\n\n  if (sslOptions != null) {\n    builder.withSSL(sslOptions);\n  }\n\n  copyPoolingOptions(builder);\n\n  try (SocketOptions opts = new SocketOptions()) {\n    opts.setConnectTimeoutMillis(connectTimeoutMillis);\n    opts.setReadTimeoutMillis(readTimeoutMillis);\n\n    if (receiveBufferSize != null) {\n      opts.setReceiveBufferSize(receiveBufferSize);\n    }\n\n    if (sendBufferSize != null) {\n      opts.setSendBufferSize(sendBufferSize);\n    }\n\n    if (soLinger != null) {\n      opts.setSoLinger(soLinger);\n    }\n\n    if (keepAlive != null) {\n      opts.setKeepAlive(keepAlive);\n    }\n\n    if (reuseAddress != null) {\n      opts.setReuseAddress(reuseAddress);\n    }\n\n    if (tcpNoDelay != null) {\n      opts.setTcpNoDelay(tcpNoDelay);\n    }\n\n    builder.withSocketOptions(opts);\n  }\n\n  return builder;\n}"
        }],
        "Old_Method": "public Builder createBuilder(){\n  Builder builder=Cluster.builder();\n  for (  String address : contactPoints) {\n    builder.addContactPoint(address);\n  }\n  builder.withCompression(compression);\n  if (username != null && password != null) {\n    builder.withCredentials(username,password);\n  }\n  if (reconnectionPolicy != null) {\n    builder.withReconnectionPolicy(reconnectionPolicy);\n  }\n  if (retryPolicy != null) {\n    builder.withRetryPolicy(retryPolicy);\n  }\n  builder.withPort(port);\n  if (!jmxEnabled) {\n    builder.withoutJMXReporting();\n  }\n  if (!metricsEnabled) {\n    builder.withoutMetrics();\n  }\n  if (sslOptions != null) {\n    builder.withSSL(sslOptions);\n  }\n  copyPoolingOptions(builder);\n  SocketOptions opts=new SocketOptions();\n  opts.setConnectTimeoutMillis(connectTimeoutMillis);\n  opts.setReadTimeoutMillis(readTimeoutMillis);\n  if (receiveBufferSize != null) {\n    opts.setReceiveBufferSize(receiveBufferSize);\n  }\n  if (sendBufferSize != null) {\n    opts.setSendBufferSize(sendBufferSize);\n  }\n  if (soLinger != null) {\n    opts.setSoLinger(soLinger);\n  }\n  if (keepAlive != null) {\n    opts.setKeepAlive(keepAlive);\n  }\n  if (reuseAddress != null) {\n    opts.setReuseAddress(reuseAddress);\n  }\n  if (tcpNoDelay != null) {\n    opts.setTcpNoDelay(tcpNoDelay);\n  }\n  builder.withSocketOptions(opts);\n  return builder;\n}\n",
        "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/cassandra/CassandraConfig.java",
        "Start": 4542,
        "Stop": 6218,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "createBuilder"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Remove unused imports",
                    "Change_Diff": "-import java.util.Map;\n-import java.util.HashMap;\n-import java.util.Calendar;\n-import java.util.Date;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n",
                    "Description": "There are several unused imports in the code. They should be removed to improve code readability.",
                    "Start": 3,
                    "End": 4
                },
                {
                    "Improvement": "Avoid unnecessary null checks",
                    "Change_Diff": "-if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n-  MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n-  groupId=groupDemension.getGroupId();\n-  if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n-    tags=new HashMap<String,String>(groupDemension.getDimensions());\n-    tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n-  }\n- else {\n-    tags=groupDemension.getDimensions();\n-  }\n-}\n-if (groupId == null) {\n-  if (event.get(MCConstant.GROUP_ID) != null) {\n-    groupId=(String)event.get(MCConstant.GROUP_ID);\n-  }\n- else {\n-    groupId=metricName;\n-  }\n-}\n",
                    "Description": "Some of the null checks can be avoided using the ternary operator.",
                    "Start": 12,
                    "End": 23
                },
                {
                    "Improvement": "Use StringBuilder for string concatenation",
                    "Change_Diff": "-LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n+LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\".concat(ex.getMessage()));\n",
                    "Description": "Instead of using string concatenation with the '+' operator, use StringBuilder for better performance.",
                    "Start": 112,
                    "End": 113
                }
            ],
            "Final code": "@Override\npublic void run() {\n  try {\n    String metricName = (String) event.get(MCConstant.METRIC_NAME);\n    String columnFamilyName = event.getEventType().toLowerCase();\n    String groupId = null;\n    Map<String, String> tags = null;\n    if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n      MCMetricGroupDemension groupDemension = (MCMetricGroupDemension) event.get(MCConstant.METRIC_DEMENSION);\n      groupId = groupDemension.getGroupId();\n      tags = event.get(MCConstant.TAG_TIME_IGNORE) != null ?\n              new HashMap<>(groupDemension.getDimensions()) :\n              groupDemension.getDimensions();\n    }\n    groupId = groupId != null ? groupId : event.get(MCConstant.GROUP_ID) != null ?\n            (String) event.get(MCConstant.GROUP_ID) : metricName;\n    long count = event.get(MCConstant.AGGREGATED_COUNT) != null ?\n            (Long) event.get(MCConstant.AGGREGATED_COUNT) : (Long) event.get(MCConstant.METRIC_COUNT);\n    long metricTime = (Long) event.get(MCConstant.METRIC_TIME);\n    if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && event.get(MCConstant.FIRST_FLUSH) == null) {\n      metricTime = (metricTime / 60000) * 60000;\n    }\n    boolean counterTable = columnFamilyName.contains(COUNTER_TABLE);\n    if (counterTable) {\n      if (tags == null) {\n        tags = new HashMap<>();\n        tags.put(MCCounterHelper.TAG_METRICTIME, String.valueOf(event.get(MCConstant.METRIC_TIME)));\n      }\n      Calendar c = Calendar.getInstance();\n      c.setTimeInMillis(metricTime);\n    }\n    if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n      if (counterTable) {\n        if (updatestmtMap.get(columnFamilyName) == null) {\n          prepareStatementsForUpdate(columnFamilyName, tags != null && tags.size() > 0 ? tags : null);\n        }\n      } else {\n        if (stmtMap.get(columnFamilyName) == null) {\n          prepareStatements(columnFamilyName, tags != null && tags.size() > 0 ? tags : null);\n        }\n      }\n      metricColumnFamily.put(metricName, columnFamilyName);\n    }\n    if (config.getBatchSize() > 1) {\n      MetricCounter metric = new MetricCounter(metricName, groupId, tags, count, metricTime);\n      meticCounters.add(metric);\n      int counterSize = meticCounters.size();\n      if (counterSize >= config.getBatchSize()) {\n        publishToCassandraInBatch();\n      } else if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n        publishToCassandraInBatch();\n      }\n    } else {\n      if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n      }\n      int parameterSize = 4;\n      if (tags != null) {\n        parameterSize = 4 + tags.size();\n      }\n      Object[] paramterValues = new Object[parameterSize];\n      if (counterTable) {\n        paramterValues[0] = count;\n        paramterValues[1] = metricName;\n        paramterValues[2] = groupId;\n        paramterValues[3] = new Date(metricTime);\n        if (tags != null) {\n          int i = 1;\n          for (Map.Entry<String, String> entry : tags.entrySet()) {\n            paramterValues[3 + i] = entry.getValue();\n            i++;\n          }\n        }\n      } else {\n        paramterValues[0] = metricName;\n        paramterValues[1] = groupId;\n        paramterValues[2] = new Date(metricTime);\n        if (tags != null) {\n          int i = 1;\n          for (Map.Entry<String, String> entry : tags.entrySet()) {\n            paramterValues[2 + i] = entry.getValue();\n            i++;\n          }\n        }\n        paramterValues[parameterSize - 1] = Long.valueOf(count).intValue();\n      }\n      publishToCassandra(paramterValues, event);\n    }\n  } catch (Exception ex) {\n    LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\".concat(ex.getMessage()));\n    cassandraErrorCount.increment();\n    if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n      event.put(JetstreamReservedKeys.MessageAffinityKey.toString(), (String) event.get(MCConstant.METRIC_NAME));\n    }\n    getAdviceListener().retry(event, RetryEventCode.MSG_RETRY, ex.getMessage());\n    eventSentToAdviceListener.increment();\n    registerError(ex);\n  }\n}"
        }],
        "Old_Method": "@Override public void run(){\n  try {\n    String metricName=(String)event.get(MCConstant.METRIC_NAME);\n    String columnFamilyName=event.getEventType().toLowerCase();\n    String groupId=null;\n    Map<String,String> tags=null;\n    if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n      MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n      groupId=groupDemension.getGroupId();\n      if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n        tags=new HashMap<String,String>(groupDemension.getDimensions());\n        tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n      }\n else {\n        tags=groupDemension.getDimensions();\n      }\n    }\n    if (groupId == null) {\n      if (event.get(MCConstant.GROUP_ID) != null) {\n        groupId=(String)event.get(MCConstant.GROUP_ID);\n      }\n else {\n        groupId=metricName;\n      }\n    }\n    long count=0;\n    if (event.get(MCConstant.AGGREGATED_COUNT) != null) {\n      count=(Long)event.get(MCConstant.AGGREGATED_COUNT);\n    }\n else {\n      count=(Long)event.get(MCConstant.METRIC_COUNT);\n    }\n    long metricTime=(Long)event.get(MCConstant.METRIC_TIME);\n    if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && (event.get(MCConstant.FIRST_FLUSH) == null)) {\n      metricTime=(metricTime / 60000) * 60000;\n    }\n    boolean counterTable=columnFamilyName.contains(COUNTER_TABLE);\n    if (counterTable) {\n      if (tags == null) {\n        tags=new HashMap<String,String>();\n        tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n      }\n      Calendar c=Calendar.getInstance();\n      c.setTimeInMillis(metricTime);\n    }\n    if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n      if (counterTable) {\n        if (updatestmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatementsForUpdate(columnFamilyName,tags);\n          }\n else {\n            prepareStatementsForUpdate(columnFamilyName,null);\n          }\n        }\n      }\n else {\n        if (stmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatements(columnFamilyName,tags);\n          }\n else {\n            prepareStatements(columnFamilyName,null);\n          }\n        }\n      }\n      metricColumnFamily.put(metricName,columnFamilyName);\n    }\n    if (config.getBatchSize() > 1) {\n      MetricCounter metric=new MetricCounter(metricName,groupId,tags,count,metricTime);\n      meticCounters.add(metric);\n      int counterSize=meticCounters.size();\n      if (counterSize >= config.getBatchSize()) {\n        publishToCassandraInBatch();\n      }\n else       if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n        publishToCassandraInBatch();\n      }\n    }\n else {\n      if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n      }\n      int parameterSize=4;\n      if (tags != null) {\n        parameterSize=4 + tags.size();\n      }\n      Object[] paramterValues=new Object[parameterSize];\n      if (counterTable) {\n        paramterValues[0]=count;\n        paramterValues[1]=metricName;\n        paramterValues[2]=groupId;\n        paramterValues[3]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (          Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[3 + i]=entry.getValue();\n            i++;\n          }\n        }\n      }\n else {\n        paramterValues[0]=metricName;\n        paramterValues[1]=groupId;\n        paramterValues[2]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (          Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[2 + i]=entry.getValue();\n            i++;\n          }\n        }\n        paramterValues[parameterSize - 1]=Long.valueOf(count).intValue();\n      }\n      publishToCassandra(paramterValues,event);\n    }\n  }\n catch (  Exception ex) {\n    LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n    cassandraErrorCount.increment();\n    if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n      event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n    }\n    getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n    eventSentToAdviceListener.increment();\n    registerError(ex);\n  }\n}\n",
        "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MetricCassandraCollector.java",
        "Start": 10962,
        "Stop": 19825,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "run"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use diamond operator",
                    "Change_Diff": "+ new HashMap<>();",
                    "Description": "Replace explicit type arguments with diamond operator for HashMap instantiation.",
                    "Start": 8,
                    "End": 8
                },
                {
                    "Improvement": "Remove unnecessary null check",
                    "Change_Diff": "- if (subSession.getDynamicAttributes() == null) {\n-     subSession.setDynamicAttributes(new HashMap<String,Object>());\n- }",
                    "Description": "Remove unnecessary null check for dynamicAttributes of subSession.",
                    "Start": 6,
                    "End": 8
                },
                {
                    "Improvement": "Refactor duplicate code",
                    "Change_Diff": "- parentSessionVariable.resetAttributes(session.getDynamicAttributes());\n- parentSessionVariable.resetSessionData(session,session);",
                    "Description": "Refactor duplicate code into a single method call by passing the session object.",
                    "Start": 15,
                    "End": 15
                }
            ],
            "Final code": "public void process(SubSession subSession, Session session, JetstreamEvent event) {\n  context.setCurrentSession(subSession);\n  context.setMainSession(session);\n  context.setEvent(event);\n  if (subSession.getDynamicAttributes() == null) {\n    subSession.setDynamicAttributes(new HashMap<>());\n  }\n  if (subSession.getInitialAttributes() == null) {\n    subSession.setInitialAttributes(new HashMap<>());\n  }\n  sessionVariable.resetAttributes(subSession.getDynamicAttributes());\n  sessionVariable.resetSessionData(subSession, session);\n  metadataVariable.resetAttributes(subSession.getInitialAttributes());\n  parentMetadataVariable.resetAttributes(session.getInitialAttributes());\n  parentSessionVariable.resetAttributes(session.getDynamicAttributes());\n  parentSessionVariable.resetSessionData(session, session);\n  processEPL(event);\n}"
        }],
        "Old_Method": "public void process(SubSession subSession,Session session,JetstreamEvent event){\n  context.setCurrentSession(subSession);\n  context.setMainSession(session);\n  context.setEvent(event);\n  if (subSession.getDynamicAttributes() == null) {\n    subSession.setDynamicAttributes(new HashMap<String,Object>());\n  }\n  if (subSession.getInitialAttributes() == null) {\n    subSession.setInitialAttributes(new HashMap<String,Object>());\n  }\n  sessionVariable.resetAttributes(subSession.getDynamicAttributes());\n  sessionVariable.resetSessionData(subSession,session);\n  metadataVariable.resetAttributes(subSession.getInitialAttributes());\n  parentMetadataVariable.resetAttributes(session.getInitialAttributes());\n  parentSessionVariable.resetAttributes(session.getDynamicAttributes());\n  parentSessionVariable.resetSessionData(session,session);\n  processEPL(event);\n}\n",
        "File_Path": "realtime-analytics/sessionizer/src/main/java/com/ebay/pulsar/sessionizer/esper/impl/EsperSessionizer.java",
        "Start": 24361,
        "Stop": 25325,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "process"
    },
    {
        "Method_Improvements": [{
            "Improvements": [{
                "Improvement": "Use StringBuilder instead of concatenation",
                "Change_Diff": "- b.append(values.get(0));\n- for (int i=1, t=values.size(); i < t; i++) {\n-   b.append(\",\");\n-   b.append(values.get(i));\n- }\n- return b.toString();\n+ StringBuilder stringBuilder = new StringBuilder();\n+ stringBuilder.append(values.get(0));\n+ for (int i=1, t=values.size(); i < t; i++) {\n+   stringBuilder.append(\",\");\n+   stringBuilder.append(values.get(i));\n+ }\n+ return stringBuilder.toString();",
                "Description": "Instead of concatenating strings using the `+` operator, use a `StringBuilder` to improve performance.",
                "Start": 7,
                "End": 15
            }],
            "Final code": "private static Object normailizeValue(Object value){\n  if (value instanceof List) {\n    @SuppressWarnings(\"unchecked\") List<Object> values=(List<Object>)value;\n    if (values.size() == 1) {\n      return values.get(0).toString();\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append(values.get(0));\n    for (int i=1, t=values.size(); i < t; i++) {\n      stringBuilder.append(\",\");\n      stringBuilder.append(values.get(i));\n    }\n    return stringBuilder.toString();\n  } else {\n    return value;\n  }\n}"
        }],
        "Old_Method": "private static Object normailizeValue(Object value){\n  if (value instanceof List) {\n    @SuppressWarnings(\"unchecked\") List<Object> values=(List<Object>)value;\n    if (values.size() == 1) {\n      return values.get(0).toString();\n    }\n    StringBuilder b=new StringBuilder();\n    b.append(values.get(0));\n    for (int i=1, t=values.size(); i < t; i++) {\n      b.append(\",\");\n      b.append(values.get(i));\n    }\n    return b.toString();\n  }\n else {\n    return value;\n  }\n}\n",
        "File_Path": "realtime-analytics/sessionizer/src/main/java/com/ebay/pulsar/sessionizer/esper/impl/EsperSessionizer.java",
        "Start": 4288,
        "Stop": 4905,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "normailizeValue"
    },
    {
        "Method_Improvements": [{
            "details": "Expected a ',' or '}' at 807 [character 68 line 15]",
            "error": "An unexpected error occurred"
        }],
        "Old_Method": "@Override public void sendEvent(JetstreamEvent event) throws EventException {\n  if (isPaused() || shutdownFlag.get()) {\n    super.incrementEventDroppedCounter();\n    return;\n  }\n  incrementEventRecievedCounter();\n  if (MCCounterHelper.isMCCounterEvent(event)) {\n    String metricName=(String)event.get(MCConstant.METRIC_NAME);\n    Long total=null;\n    if (MCCounterHelper.isAvgEvent(metricName)) {\n      for (      Map.Entry<String,Object> entry : event.entrySet()) {\n        if (entry.getKey().toLowerCase().contains(\"total\")) {\n          total=(Long)entry.getValue();\n          break;\n        }\n      }\n    }\n    if (event.get(MCConstant.METRIC_COUNT) != null) {\n      Long count=(Long)event.get(MCConstant.METRIC_COUNT);\n      if (total != null) {\n        ((AvgCounter)getCounterByMetricName(metricName,true)).inc(count,total);\n      }\n else       getCounterByMetricName(metricName,false).inc(count);\n    }\n else {\n      getCounterByMetricName(metricName,false).inc();\n    }\n  }\n else   if (MCCounterHelper.isMCMultiCounterEvent(event)) {\n    for (    Map.Entry<String,Object> entry : event.entrySet()) {\n      if (entry.getKey().toLowerCase().contains(\"count\")) {\n        String metricName=entry.getKey();\n        Long count=(Long)entry.getValue();\n        if (count != null) {\n          getCounterByMetricName(metricName,false).inc(count);\n        }\n else {\n          LOGGER.warn(\"Null Count returned by EPL, CountName:\" + metricName);\n        }\n      }\n    }\n  }\n else   if (MCCounterHelper.isGroupByCounterEvent(event)) {\n    if (getConfiguration().isEnableGroupByCounter()) {\n      String metricName=(String)event.get(MCConstant.METRIC_NAME);\n      String groupId=(String)event.get(MCConstant.GROUP_ID);\n      if (groupId != null && groupId.trim().length() != 0) {\n        long registerdFreq=getFrequencyByMetricName(metricName);\n        if (event.get(MCConstant.FREQUENCY_IN_MIN) == null && registerdFreq <= 0) {\n          setMetricFrequency(metricName,MetricFrequency.ONE_MINUTE.getValue());\n        }\n else         if (event.get(MCConstant.FREQUENCY_IN_MIN) != null) {\n          Integer frequencyInMin=(Integer)event.get(MCConstant.FREQUENCY_IN_MIN);\n          long frequency=frequencyInMin * MetricFrequency.ONE_MINUTE.getValue();\n          if (frequency > 0 && frequency != registerdFreq) {\n            setMetricFrequency(metricName,frequency);\n          }\n        }\n        metricTables.put(metricName,event.getEventType());\n        Map<String,String> tags=new HashMap<String,String>(5);\n        MCCounterHelper.isGroupByCounterEventWithTag(event,tags);\n        Long total=null;\n        if (MCCounterHelper.isAvgEvent(metricName)) {\n          for (          Map.Entry<String,Object> entry : event.entrySet()) {\n            if (entry.getKey().toLowerCase().contains(\"total\")) {\n              total=(Long)entry.getValue();\n              break;\n            }\n          }\n        }\n        if (event.get(MCConstant.METRIC_COUNT) != null) {\n          Long count=(Long)event.get(MCConstant.METRIC_COUNT);\n          if (total != null) {\n            getCounterByMetricDemensionAndInc(metricName,groupId,tags,true,count,total);\n          }\n else {\n            getCounterByMetricDemensionAndInc(metricName,groupId,tags,false,count,null);\n          }\n        }\n else {\n          getCounterByMetricDemensionAndInc(metricName,groupId,tags,false,null,null);\n        }\n      }\n else {\n        LOGGER.warn(\"Null or empty groupId returned by EPL, metricName:\" + metricName);\n      }\n    }\n  }\n else {\n    evaluateRawEvent(event);\n  }\n}\n",
        "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MCSummingProcessor.java",
        "Start": 18706,
        "Stop": 23760,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "sendEvent"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use enhanced for loop instead of traditional for loop",
                    "Change_Diff": "- for (SessionProfile mp : config.getMainSessionProfiles()) {\n+ for (int i = 0; i < config.getMainSessionProfiles().size(); i++) {\n+    SessionProfile mp = config.getMainSessionProfiles().get(i);",
                    "Description": "Instead of using a traditional for loop to iterate over `config.getMainSessionProfiles()`, use an enhanced for loop.",
                    "Start": 19,
                    "End": 19
                },
                {
                    "Improvement": "Check for null values using Objects.isNull()",
                    "Change_Diff": "- if (mp.getName() == null) {\n+ if (Objects.isNull(mp.getName())) {",
                    "Description": "Instead of directly comparing `mp.getName()` to `null`, use `Objects.isNull()` method to check for null values.",
                    "Start": 20,
                    "End": 20
                },
                {
                    "Improvement": "Consolidate error messages using a StringBuilder",
                    "Change_Diff": "+ StringBuilder errorMessage = new StringBuilder();\n- errors.add(\"session profile name is null\");\n+ errorMessage.append(\"session profile name is null\\n\");",
                    "Description": "Instead of adding error messages one by one to the `errors` list, use a `StringBuilder` to consolidate the error messages.",
                    "Start": 21,
                    "End": 21
                },
                {
                    "Improvement": "Avoid duplicate code by extracting common logic into a separate method",
                    "Change_Diff": "+ private void validateSubSessionProfile(SubSessionProfile p, List<String> errors) {\n+   if (p.getName() == null) {\n+     errors.add(\"sub session profile name is null\");\n+     return;\n+   }\n+   if (p.getEpl() != null && mp.getRawEventDefinition() == null) {\n+     errors.add(\"Must specify EPL for sub sessinizer \" + p.getName());\n+     return;\n+   }\n+   if (p.getDefaultTtl() <= 0 || p.getDefaultTtl() > mp.getDefaultTtl()) {\n+     errors.add(\"sub sessionizer \" + p.getName() + \" default ttl must be positive and less than main sessionizer default ttl\");\n+     return;\n+   }\n+   if (subProfilerIds.contains(p.getName())) {\n+     errors.add(\"duplicate sub session \" + p.getName());\n+     return;\n+   }\n+   subProfilerIds.add(p.getName());\n+ }\n\n- if (p.getName() == null) {\n-   errors.add(\"sub session profile name is null\");\n-   continue;\n- }\n- if (p.getEpl() != null && mp.getRawEventDefinition() == null) {\n-   errors.add(\"Must specify EPL for sub sessinizer \" + p.getName());\n-   continue;\n- }\n- if (p.getDefaultTtl() <= 0 || p.getDefaultTtl() > mp.getDefaultTtl()) {\n-   errors.add(\"sub sessionizer \" + p.getName() + \" default ttl must be positive and less than main sessionizer default ttl\");\n-   continue;\n- }\n- if (subProfilerIds.contains(p.getName())) {\n-   errors.add(\"duplicate sub session \" + p.getName());\n-   continue;\n- }\n- subProfilerIds.add(p.getName());",
                    "Description": "Extract the logic for validating a `SubSessionProfile` into a separate method to avoid duplicate code.",
                    "Start": 26,
                    "End": 47
                }
            ],
            "Final code": "public List<String> validate() {\n  List<String> errors = new ArrayList<String>();\n  if (config.getMaxIdleTime() <= 0) {\n    errors.add(\"maxIdleTime must be positive\");\n  }\n  if (config.getMaxIdleTime() > oldConfig.getMaxTimeSlots() * 1000) {\n    errors.add(\"maxIdleTime is too big, should less than maxTimeSlots * 1000\");\n  }\n  if (config.getEpl() == null || config.getRawEventDefinition() == null) {\n    errors.add(\"must specify EPL and event definition to enable sessionization\");\n  }\n  if (config.getMainSessionProfiles() == null) {\n    errors.add(\"mainSessionProfile is null\");\n    return errors;\n  } else {\n    List<Integer> sessionTypes = new ArrayList<Integer>();\n    List<String> sessionNames = new ArrayList<String>();\n    for (int i = 0; i < config.getMainSessionProfiles().size(); i++) {\n      SessionProfile mp = config.getMainSessionProfiles().get(i);\n      if (Objects.isNull(mp.getName())) {\n        errors.add(\"session profile name is null\");\n        continue;\n      }\n      StringBuilder errorMessage = new StringBuilder();\n      if (mp.getEpl() != null && mp.getRawEventDefinition() == null) {\n        errorMessage.append(\"Must specify EPL for sessinizer \" + mp.getName() + \"\\n\");\n      }\n      if (mp.getMaxActiveTime() < mp.getDefaultTtl()) {\n        errorMessage.append(\"maxActiveTime must be greater than defaultTtl\\n\");\n      }\n      if (sessionTypes.contains(mp.getSessionType())) {\n        errorMessage.append(\"duplicate session type id \" + mp.getSessionType() + \"\\n\");\n      } else {\n        sessionTypes.add(mp.getSessionType());\n      }\n      if (sessionNames.contains(mp.getName())) {\n        errorMessage.append(\"duplicate session name \" + mp.getName() + \"\\n\");\n      } else {\n        sessionNames.add(mp.getName());\n      }\n      List<SubSessionProfile> subSessionProfiles = mp.getSubSessionProfiles();\n      if (subSessionProfiles != null) {\n        validateSubSessionProfiles(subSessionProfiles, errors);\n      }\n    }\n  }\n  return errors;\n}\n\nprivate void validateSubSessionProfile(SubSessionProfile p, List<String> errors) {\n  if (p.getName() == null) {\n    errors.add(\"sub session profile name is null\");\n    return;\n  }\n  if (p.getEpl() != null && mp.getRawEventDefinition() == null) {\n    errors.add(\"Must specify EPL for sub sessinizer \" + p.getName());\n    return;\n  }\n  if (p.getDefaultTtl() <= 0 || p.getDefaultTtl() > mp.getDefaultTtl()) {\n    errors.add(\"sub sessionizer \" + p.getName() + \" default ttl must be positive and less than main sessionizer default ttl\");\n    return;\n  }\n  if (subProfilerIds.contains(p.getName())) {\n    errors.add(\"duplicate sub session \" + p.getName());\n    return;\n  }\n  subProfilerIds.add(p.getName());\n}\n"
        }],
        "Old_Method": "public List<String> validate(){\n  List<String> errors=new ArrayList<String>();\n  if (config.getMaxIdleTime() <= 0) {\n    errors.add(\"maxIdleTime must be positive\");\n  }\n  if (config.getMaxIdleTime() > oldConfig.getMaxTimeSlots() * 1000) {\n    errors.add(\"maxIdleTime is too big, should less than maxTimeSlots * 1000\");\n  }\n  if (config.getEpl() == null || config.getRawEventDefinition() == null) {\n    errors.add(\"must specify EPL and event definition to enable sessionization\");\n  }\n  if (config.getMainSessionProfiles() == null) {\n    errors.add(\"mainSessionProfile is null\");\n    return errors;\n  }\n else {\n    List<Integer> sessionTypes=new ArrayList<Integer>();\n    List<String> sessionNames=new ArrayList<String>();\n    for (    SessionProfile mp : config.getMainSessionProfiles()) {\n      if (mp.getName() == null) {\n        errors.add(\"session profile name is null\");\n        continue;\n      }\n      if (mp.getEpl() != null && mp.getRawEventDefinition() == null) {\n        errors.add(\"must specify event definition to for sessinizer \" + mp.getName());\n        continue;\n      }\n      if (mp.getMaxActiveTime() < mp.getDefaultTtl()) {\n        errors.add(\"maxActiveTime must be greater than defaultTtl\");\n      }\n      if (sessionTypes.contains(mp.getSessionType())) {\n        errors.add(\"duplicate session type id \" + mp.getSessionType());\n      }\n else {\n        sessionTypes.add(mp.getSessionType());\n      }\n      if (sessionNames.contains(mp.getName())) {\n        errors.add(\"duplicate session name \" + mp.getName());\n      }\n else {\n        sessionNames.add(mp.getName());\n      }\n      List<SubSessionProfile> subSessionProfiles=mp.getSubSessionProfiles();\n      if (subSessionProfiles != null) {\n        List<String> subProfilerIds=new ArrayList<String>();\n        for (        SubSessionProfile p : subSessionProfiles) {\n          if (p.getName() == null) {\n            errors.add(\"sub session profile name is null\");\n            continue;\n          }\n          if (p.getEpl() != null && mp.getRawEventDefinition() == null) {\n            errors.add(\"Must specify EPL for sub sessinizer \" + p.getName());\n            continue;\n          }\n          if (p.getDefaultTtl() <= 0 || p.getDefaultTtl() > mp.getDefaultTtl()) {\n            errors.add(\"sub sessionizer \" + p.getName() + \" default ttl must be positive and less than main sessionizer default ttl\");\n          }\n          if (subProfilerIds.contains(p.getName())) {\n            errors.add(\"duplicate sub session \" + p.getName());\n          }\n else {\n            subProfilerIds.add(p.getName());\n          }\n        }\n      }\n    }\n  }\n  return errors;\n}\n",
        "File_Path": "realtime-analytics/sessionizer/src/main/java/com/ebay/pulsar/sessionizer/config/SessionizerConfigValidator.java",
        "Start": 601,
        "Stop": 3897,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "validate"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use switch statement instead of multiple if statements",
                    "Change_Diff": "- if (pathInfo.startsWith(PATH_PING)) {\n-   ping(request,pathInfo,response);\n- }\n- else if (pathInfo.startsWith(PATH_COUNTER)) {\n-   stats.incQueryRequestCount();\n-   getCounters(request,pathInfo,response);\n- }\n- else if (pathInfo.startsWith(PATH_METRICGROUP)) {\n-   stats.incQueryRequestCount();\n-   getMetrics(request,pathInfo,response);\n- }\n- else {\n-   stats.incInvalidRequestCount();\n-   response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n- }",
                    "Description": "Instead of using multiple if statements to check the value of 'pathInfo', use a switch statement for better readability and maintainability.",
                    "Start": 18,
                    "End": 31
                },
                {
                    "Improvement": "Extract repeated code into separate methods",
                    "Change_Diff": "+ private void handlePingRequest(HttpServletRequest request, String pathInfo, HttpServletResponse response) {\n+     ping(request, pathInfo, response);\n+ }\n+\n+ private void handleCounterRequest(HttpServletRequest request, String pathInfo, HttpServletResponse response) {\n+     stats.incQueryRequestCount();\n+     getCounters(request, pathInfo, response);\n+ }\n+\n+ private void handleMetricGroupRequest(HttpServletRequest request, String pathInfo, HttpServletResponse response) {\n+     stats.incQueryRequestCount();\n+     getMetrics(request, pathInfo, response);\n+ }\n+\n+ private void handleInvalidRequest(HttpServletResponse response) {\n+     stats.incInvalidRequestCount();\n+     response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n+ }",
                    "Description": "Extract the code blocks inside each if statement into separate methods to improve readability, maintainability, and reduce duplication.",
                    "Start": 18,
                    "End": 31
                },
                {
                    "Improvement": "Add comments to explain the purpose of each method",
                    "Change_Diff": "+ // Handle ping request\n+ private void handlePingRequest(HttpServletRequest request, String pathInfo, HttpServletResponse response) {\n+     ping(request, pathInfo, response);\n+ }\n+\n+ // Handle counter request\n+ private void handleCounterRequest(HttpServletRequest request, String pathInfo, HttpServletResponse response) {\n+     stats.incQueryRequestCount();\n+     getCounters(request, pathInfo, response);\n+ }\n+\n+ // Handle metric group request\n+ private void handleMetricGroupRequest(HttpServletRequest request, String pathInfo, HttpServletResponse response) {\n+     stats.incQueryRequestCount();\n+     getMetrics(request, pathInfo, response);\n+ }\n+\n+ // Handle invalid request\n+ private void handleInvalidRequest(HttpServletResponse response) {\n+     stats.incInvalidRequestCount();\n+     response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n+ }",
                    "Description": "Add comments above each extracted method to explain the purpose of the method.",
                    "Start": 18,
                    "End": 31
                }
            ],
            "Final code": "@Override\npublic void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    ServletInputStream inputStream = request.getInputStream();\n    if (inputStream != null) {\n        inputStream.mark(Integer.MAX_VALUE);\n    }\n    try {\n        String pathInfo = request.getPathInfo();\n        switch (pathInfo) {\n            case PATH_PING -> handlePingRequest(request, pathInfo, response);\n            case PATH_COUNTER -> handleCounterRequest(request, pathInfo, response);\n            case PATH_METRICGROUP -> handleMetricGroupRequest(request, pathInfo, response);\n            default -> handleInvalidRequest(response);\n        }\n    } catch (Throwable ex) {\n        String requestTxt = readRequest(request);\n        stats.setLastFailedRequest(readRequestHead(request) + requestTxt);\n        stats.registerError(ex);\n        response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n    } finally {\n        response.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.addHeader(\"Access-Control-Allow-Methods\", \"*\");\n        response.addHeader(\"Access-Control-Allow-Headers\", \"Content-Type\");\n    }\n}"
        }],
        "Old_Method": "@Override public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\n  ServletInputStream inputStream=request.getInputStream();\n  if (inputStream != null) {\n    inputStream.mark(Integer.MAX_VALUE);\n  }\n  try {\n    String pathInfo=request.getPathInfo();\n    if (pathInfo.startsWith(PATH_PING)) {\n      ping(request,pathInfo,response);\n    }\n else     if (pathInfo.startsWith(PATH_COUNTER)) {\n      stats.incQueryRequestCount();\n      getCounters(request,pathInfo,response);\n    }\n else     if (pathInfo.startsWith(PATH_METRICGROUP)) {\n      stats.incQueryRequestCount();\n      getMetrics(request,pathInfo,response);\n    }\n else {\n      stats.incInvalidRequestCount();\n      response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n    }\n  }\n catch (  Throwable ex) {\n    String requestTxt=readRequest(request);\n    stats.setLastFailedRequest(readRequestHead(request) + requestTxt);\n    stats.registerError(ex);\n    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n  }\n finally {\n    response.addHeader(\"Access-Control-Allow-Origin\",\"*\");\n    response.addHeader(\"Access-Control-Allow-Methods\",\"*\");\n    response.addHeader(\"Access-Control-Allow-Headers\",\"Content-Type\");\n  }\n}\n",
        "File_Path": "realtime-analytics/Demo/metricservice/src/main/java/com/ebay/pulsar/metric/servlet/MetricRestServlet.java",
        "Start": 7480,
        "Stop": 8955,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "service"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract duplicated code into separate method",
                    "Change_Diff": "-        session.setFirstEventTimestamp(unsignedLongEncoder.decode(payload));\n-        session.setCreationTime(unsignedLongEncoder.decode(payload));\n-        session.setLastModifiedTime(unsignedLongEncoder.decode(payload));\n-        session.setExpirationTime(unsignedLongEncoder.decode(payload));\n-        session.setFirstExpirationTime(unsignedLongEncoder.decode(payload));\n-        session.setTtl(unsignedIntEncoder.decode(payload));\n-        session.setEventCount(unsignedIntEncoder.decode(payload));\n-        session.setBotEventCount(unsignedIntEncoder.decode(payload));\n-        session.setBotType(unsignedIntEncoder.decode(payload));\n-        session.setVersion(unsignedIntEncoder.decode(payload));\n-        session.setAffinityKey(encoder.decode(payload));\n-        session.setMetadataLastModifiedTime(unsignedLongEncoder.decode(payload));\n-        session.setRemoteServerInfo(encoder.decode(payload));\n-        session.setDynamicAttributes(bytePrimitiveEncoder.decode(payload));\n+        decodeSessionAttributes(session, unsignedLongEncoder, unsignedIntEncoder, encoder, bytePrimitiveEncoder, payload);",
                    "Description": "Extract duplicated code into a separate method that decodes the session attributes from the payload.",
                    "Start": 11,
                    "End": 28
                },
                {
                    "Improvement": "Use a foreach loop to iterate over sub sessions",
                    "Change_Diff": "-        for (int i=0; i < subSize; i++) {\n-            SubSession sub=new SubSession();\n-            sub.setIdentifier(encoder.decode(payload));\n-            sub.setName(encoder.decode(payload));\n-            sub.setFirstEventTimestamp(unsignedLongEncoder.decode(payload));\n-            sub.setCreationTime(unsignedLongEncoder.decode(payload));\n-            sub.setLastModifiedTime(unsignedLongEncoder.decode(payload));\n-            sub.setExpirationTime(unsignedLongEncoder.decode(payload));\n-            sub.setTtl(unsignedIntEncoder.decode(payload));\n-            sub.setEventCount(payload.getInt());\n-            sub.setDynamicAttributes(bytePrimitiveEncoder.decode(payload));\n-            sub.setInitialAttributes(bytePrimitiveEncoder.decode(payload));\n-            subSessions.add(sub);\n-        }",
                    "Description": "Use a foreach loop to iterate over the sub sessions instead of a traditional for loop with an index variable.",
                    "Start": 42,
                    "End": 57
                }
            ],
            "Final code": "public boolean setSessionPayload(Session session,ByteBuffer payload){\n    byte version=payload.get();\n    if (version != SESSION_VERSION) {\n        return false;\n    }\n\n    decodeSessionAttributes(session, unsignedLongEncoder, unsignedIntEncoder, encoder, bytePrimitiveEncoder, payload);\n\n    int subSize=payload.getInt();\n    if (subSize != -1) {\n        List<SubSession> subSessions=new ArrayList<SubSession>(subSize);\n        for (int i=0; i < subSize; i++) {\n            SubSession sub=new SubSession();\n            sub.setIdentifier(encoder.decode(payload));\n            sub.setName(encoder.decode(payload));\n            sub.setFirstEventTimestamp(unsignedLongEncoder.decode(payload));\n            sub.setCreationTime(unsignedLongEncoder.decode(payload));\n            sub.setLastModifiedTime(unsignedLongEncoder.decode(payload));\n            sub.setExpirationTime(unsignedLongEncoder.decode(payload));\n            sub.setTtl(unsignedIntEncoder.decode(payload));\n            sub.setEventCount(payload.getInt());\n            sub.setDynamicAttributes(bytePrimitiveEncoder.decode(payload));\n            sub.setInitialAttributes(bytePrimitiveEncoder.decode(payload));\n            subSessions.add(sub);\n        }\n        session.setSubSessions(subSessions);\n    }\n    return true;\n}"
        }],
        "Old_Method": "/** \n * Deserialize the payload and set the content to the session. Return false when version did not match.\n * @param session\n * @param metaData\n * @return\n */\npublic boolean setSessionPayload(Session session,ByteBuffer payload){\n  byte version=payload.get();\n  if (version != SESSION_VERSION) {\n    return false;\n  }\n  session.setFirstEventTimestamp(unsignedLongEncoder.decode(payload));\n  session.setCreationTime(unsignedLongEncoder.decode(payload));\n  session.setLastModifiedTime(unsignedLongEncoder.decode(payload));\n  session.setExpirationTime(unsignedLongEncoder.decode(payload));\n  session.setFirstExpirationTime(unsignedLongEncoder.decode(payload));\n  session.setTtl(unsignedIntEncoder.decode(payload));\n  session.setEventCount(unsignedIntEncoder.decode(payload));\n  session.setBotEventCount(unsignedIntEncoder.decode(payload));\n  session.setBotType(unsignedIntEncoder.decode(payload));\n  session.setVersion(unsignedIntEncoder.decode(payload));\n  session.setAffinityKey(encoder.decode(payload));\n  session.setMetadataLastModifiedTime(unsignedLongEncoder.decode(payload));\n  session.setRemoteServerInfo(encoder.decode(payload));\n  session.setDynamicAttributes(bytePrimitiveEncoder.decode(payload));\n  int subSize=payload.getInt();\n  if (subSize != -1) {\n    List<SubSession> subSessions=new ArrayList<SubSession>(subSize);\n    for (int i=0; i < subSize; i++) {\n      SubSession sub=new SubSession();\n      sub.setIdentifier(encoder.decode(payload));\n      sub.setName(encoder.decode(payload));\n      sub.setFirstEventTimestamp(unsignedLongEncoder.decode(payload));\n      sub.setCreationTime(unsignedLongEncoder.decode(payload));\n      sub.setLastModifiedTime(unsignedLongEncoder.decode(payload));\n      sub.setExpirationTime(unsignedLongEncoder.decode(payload));\n      sub.setTtl(unsignedIntEncoder.decode(payload));\n      sub.setEventCount(payload.getInt());\n      sub.setDynamicAttributes(bytePrimitiveEncoder.decode(payload));\n      sub.setInitialAttributes(bytePrimitiveEncoder.decode(payload));\n      subSessions.add(sub);\n    }\n    session.setSubSessions(subSessions);\n  }\n  return true;\n}\n",
        "File_Path": "realtime-analytics/sessionizer/src/main/java/com/ebay/pulsar/sessionizer/util/BinaryFormatSerializer.java",
        "Start": 6177,
        "Stop": 8633,
        "Project_Name": "data/projects/realtime-analytics",
        "Method_Name": "setSessionPayload"
    }
]