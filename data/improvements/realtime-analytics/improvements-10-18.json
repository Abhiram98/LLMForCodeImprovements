{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Use constants for repeated string values",
                "Change_Diff": "- \"MCConstant.METRIC_NAME\"\n+ final String METRIC_NAME = \"MCConstant.METRIC_NAME\";\n\n- \"MCConstant.METRIC_DEMENSION\"\n+ final String METRIC_DEMENSION = \"MCConstant.METRIC_DEMENSION\";\n\n- \"MCConstant.TAG_TIME_IGNORE\"\n+ final String TAG_TIME_IGNORE = \"MCConstant.TAG_TIME_IGNORE\";\n\n- \"MCConstant.GROUP_ID\"\n+ final String GROUP_ID = \"MCConstant.GROUP_ID\";\n\n- \"MCConstant.AGGREGATED_COUNT\"\n+ final String AGGREGATED_COUNT = \"MCConstant.AGGREGATED_COUNT\";\n\n- \"MCConstant.METRIC_COUNT\"\n+ final String METRIC_COUNT = \"MCConstant.METRIC_COUNT\";\n\n- \"MCConstant.METRIC_TIME\"\n+ final String METRIC_TIME = \"MCConstant.METRIC_TIME\";\n\n- \"MCConstant.SHUTDOWN_FLUSH\"\n+ final String SHUTDOWN_FLUSH = \"MCConstant.SHUTDOWN_FLUSH\";\n\n- \"MCConstant.FIRST_FLUSH\"\n+ final String FIRST_FLUSH = \"MCConstant.FIRST_FLUSH\";\n\n- \"MCConstant.METRIC_NAME\"\n+ final String METRIC_NAME = \"MCConstant.METRIC_NAME\";\n\n- \"JetstreamReservedKeys.MessageAffinityKey.toString()\"\n+ final String MESSAGE_AFFINITY_KEY = \"JetstreamReservedKeys.MessageAffinityKey.toString()\";",
                "Description": "There are some string values that are used more than once in the code. It is better to define them as constants at the beginning of the code, improving readability and maintainability.",
                "Start": 1,
                "End": 79
            },
            {
                "Improvement": "Extract repeated code into a method",
                "Change_Diff": "- if (updatestmtMap.get(columnFamilyName) == null) {\n-   if (tags != null && tags.size() > 0) {\n-     prepareStatementsForUpdate(columnFamilyName,tags);\n-   } else {\n-     prepareStatementsForUpdate(columnFamilyName,null);\n-   }\n- }\n+ prepareStatementsForUpdateIfNeeded(columnFamilyName, tags);\n\n- if (stmtMap.get(columnFamilyName) == null) {\n-   if (tags != null && tags.size() > 0) {\n-     prepareStatements(columnFamilyName,tags);\n-   } else {\n-     prepareStatements(columnFamilyName,null);\n-   }\n- }\n+ prepareStatementsIfNeeded(columnFamilyName, tags);",
                "Description": "There is a code block that is repeated. This block checks if a map's key is null and then prepares statements based on the condition. This block can be extracted into a separate method, improving maintainability and readability.",
                "Start": 47,
                "End": 53
            }
        ],
        "Final code": "final String METRIC_NAME = \"MCConstant.METRIC_NAME\";\nfinal String METRIC_DEMENSION = \"MCConstant.METRIC_DEMENSION\";\nfinal String TAG_TIME_IGNORE = \"MCConstant.TAG_TIME_IGNORE\";\nfinal String GROUP_ID = \"MCConstant.GROUP_ID\";\nfinal String AGGREGATED_COUNT = \"MCConstant.AGGREGATED_COUNT\";\nfinal String METRIC_COUNT = \"MCConstant.METRIC_COUNT\";\nfinal String METRIC_TIME = \"MCConstant.METRIC_TIME\";\nfinal String SHUTDOWN_FLUSH = \"MCConstant.SHUTDOWN_FLUSH\";\nfinal String FIRST_FLUSH = \"MCConstant.FIRST_FLUSH\";\nfinal String MESSAGE_AFFINITY_KEY = \"JetstreamReservedKeys.MessageAffinityKey.toString()\";\n\n@Override public void run(){\n  try {\n    String metricName=(String)event.get(METRIC_NAME);\n    String columnFamilyName=event.getEventType().toLowerCase();\n    String groupId=null;\n    Map<String,String> tags=null;\n    if (event.get(METRIC_DEMENSION) != null) {\n      MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(METRIC_DEMENSION);\n      groupId=groupDemension.getGroupId();\n      if (event.get(TAG_TIME_IGNORE) != null) {\n        tags=new HashMap<String,String>(groupDemension.getDimensions());\n        tags.put(TAG_TIME_IGNORE,(String)event.get(TAG_TIME_IGNORE));\n      } else {\n        tags=groupDemension.getDimensions();\n      }\n    }\n    if (groupId == null) {\n      if (event.get(GROUP_ID) != null) {\n        groupId=(String)event.get(GROUP_ID);\n      } else {\n        groupId=metricName;\n      }\n    }\n    long count=0;\n    if (event.get(AGGREGATED_COUNT) != null) {\n      count=(Long)event.get(AGGREGATED_COUNT);\n    } else {\n      count=(Long)event.get(METRIC_COUNT);\n    }\n    long metricTime=(Long)event.get(METRIC_TIME);\n    if (event.get(SHUTDOWN_FLUSH) == null && (event.get(FIRST_FLUSH) == null)) {\n      metricTime=(metricTime / 60000) * 60000;\n    }\n    boolean counterTable=columnFamilyName.contains(COUNTER_TABLE);\n    if (counterTable) {\n      if (tags == null) {\n        tags=new HashMap<String,String>();\n        tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(METRIC_TIME)));\n      }\n      Calendar c=Calendar.getInstance();\n      c.setTimeInMillis(metricTime);\n    }\n    if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n      prepareStatementsForUpdateIfNeeded(columnFamilyName, tags);\n      prepareStatementsIfNeeded(columnFamilyName, tags);\n      metricColumnFamily.put(metricName,columnFamilyName);\n    }\n    // Rest of the code remains the same...\n  } catch (Exception ex) {\n    LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n    cassandraErrorCount.increment();\n    if (event.get(MESSAGE_AFFINITY_KEY) == null) {\n      event.put(MESSAGE_AFFINITY_KEY,(String)event.get(METRIC_NAME));\n    }\n    getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n    eventSentToAdviceListener.increment();\n    registerError(ex);\n  }\n}\n\nprivate void prepareStatementsForUpdateIfNeeded(String columnFamilyName, Map<String, String> tags) {\n  if (updatestmtMap.get(columnFamilyName) == null) {\n    if (tags != null && tags.size() > 0) {\n      prepareStatementsForUpdate(columnFamilyName,tags);\n    } else {\n      prepareStatementsForUpdate(columnFamilyName,null);\n    }\n  }\n}\n\nprivate void prepareStatementsIfNeeded(String columnFamilyName, Map<String, String> tags) {\n  if (stmtMap.get(columnFamilyName) == null) {\n    if (tags != null && tags.size() > 0) {\n      prepareStatements(columnFamilyName,tags);\n    } else {\n      prepareStatements(columnFamilyName,null);\n    }\n  }\n}"
    },
    "Old_Method": "@Override public void run(){\n  try {\n    String metricName=(String)event.get(MCConstant.METRIC_NAME);\n    String columnFamilyName=event.getEventType().toLowerCase();\n    String groupId=null;\n    Map<String,String> tags=null;\n    if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n      MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n      groupId=groupDemension.getGroupId();\n      if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n        tags=new HashMap<String,String>(groupDemension.getDimensions());\n        tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n      }\n else {\n        tags=groupDemension.getDimensions();\n      }\n    }\n    if (groupId == null) {\n      if (event.get(MCConstant.GROUP_ID) != null) {\n        groupId=(String)event.get(MCConstant.GROUP_ID);\n      }\n else {\n        groupId=metricName;\n      }\n    }\n    long count=0;\n    if (event.get(MCConstant.AGGREGATED_COUNT) != null) {\n      count=(Long)event.get(MCConstant.AGGREGATED_COUNT);\n    }\n else {\n      count=(Long)event.get(MCConstant.METRIC_COUNT);\n    }\n    long metricTime=(Long)event.get(MCConstant.METRIC_TIME);\n    if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && (event.get(MCConstant.FIRST_FLUSH) == null)) {\n      metricTime=(metricTime / 60000) * 60000;\n    }\n    boolean counterTable=columnFamilyName.contains(COUNTER_TABLE);\n    if (counterTable) {\n      if (tags == null) {\n        tags=new HashMap<String,String>();\n        tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n      }\n      Calendar c=Calendar.getInstance();\n      c.setTimeInMillis(metricTime);\n    }\n    if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n      if (counterTable) {\n        if (updatestmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatementsForUpdate(columnFamilyName,tags);\n          }\n else {\n            prepareStatementsForUpdate(columnFamilyName,null);\n          }\n        }\n      }\n else {\n        if (stmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatements(columnFamilyName,tags);\n          }\n else {\n            prepareStatements(columnFamilyName,null);\n          }\n        }\n      }\n      metricColumnFamily.put(metricName,columnFamilyName);\n    }\n    if (config.getBatchSize() > 1) {\n      MetricCounter metric=new MetricCounter(metricName,groupId,tags,count,metricTime);\n      meticCounters.add(metric);\n      int counterSize=meticCounters.size();\n      if (counterSize >= config.getBatchSize()) {\n        publishToCassandraInBatch();\n      }\n else       if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n        publishToCassandraInBatch();\n      }\n    }\n else {\n      if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n      }\n      int parameterSize=4;\n      if (tags != null) {\n        parameterSize=4 + tags.size();\n      }\n      Object[] paramterValues=new Object[parameterSize];\n      if (counterTable) {\n        paramterValues[0]=count;\n        paramterValues[1]=metricName;\n        paramterValues[2]=groupId;\n        paramterValues[3]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (          Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[3 + i]=entry.getValue();\n            i++;\n          }\n        }\n      }\n else {\n        paramterValues[0]=metricName;\n        paramterValues[1]=groupId;\n        paramterValues[2]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (          Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[2 + i]=entry.getValue();\n            i++;\n          }\n        }\n        paramterValues[parameterSize - 1]=Long.valueOf(count).intValue();\n      }\n      publishToCassandra(paramterValues,event);\n    }\n  }\n catch (  Exception ex) {\n    LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n    cassandraErrorCount.increment();\n    if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n      event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n    }\n    getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n    eventSentToAdviceListener.increment();\n    registerError(ex);\n  }\n}\n",
    "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MetricCassandraCollector.java",
    "Start": 10962,
    "Stop": 19825,
    "Project_Name": "data/projects/realtime-analytics",
    "Method_Name": "run"
}