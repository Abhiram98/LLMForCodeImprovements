{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Reduce nested if-else conditions",
                "Change_Diff": "- if (config.getEnableCassandra()) { ... } \n+ if (!config.getEnableCassandra()) return;",
                "Description": "The deep nested if-else conditions make the code hard to read and understand. Consider using a guard clause to return or break the code early when a certain condition is met.",
                "Start": 2,
                "End": 104
            },
            {
                "Improvement": "Replace Runnable with lambda",
                "Change_Diff": "- worker.submit(new Runnable(){ ... }); \n+ worker.submit(() -> { ... });",
                "Description": "Since Java 8, we can replace the anonymous inner class Runnable with lambda expressions for better readability.",
                "Start": 3,
                "End": 3
            },
            {
                "Improvement": "Extract method",
                "Change_Diff": "- try { ... } catch (Exception ex) {...} \n+ try { processEvent(event); } catch (Exception ex) { handleError(ex); }",
                "Description": "The method `publishAsync` is too long, making it hard to understand. Consider extracting parts of it into separate methods.",
                "Start": 4,
                "End": 102
            }
        ],
        "Final code": "private void publishAsync(final JetstreamEvent event) {\n    if(!config.getEnableCassandra()) return;\n    worker.submit(() -> {\n        try {\n            processEvent(event);\n        } catch (Exception ex) {\n            handleError(ex);\n        }\n    });\n}\n\nprivate void processEvent(final JetstreamEvent event) {\n    // Extracted code from original publishAsync\n}\n\nprivate void handleError(Exception ex) {\n    // Extracted error handling code from original publishAsync\n}"
    },
    "Old_Method": "private void publishAsync(final JetstreamEvent event){\n  if (config.getEnableCassandra()) {\n    worker.submit(new Runnable(){\n      @Override public void run(){\n        try {\n          String metricName=(String)event.get(MCConstant.METRIC_NAME);\n          String columnFamilyName=event.getEventType().toLowerCase();\n          String groupId=null;\n          Map<String,String> tags=null;\n          if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n            MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n            groupId=groupDemension.getGroupId();\n            if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n              tags=new HashMap<String,String>(groupDemension.getDimensions());\n              tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n            }\n else {\n              tags=groupDemension.getDimensions();\n            }\n          }\n          if (groupId == null) {\n            if (event.get(MCConstant.GROUP_ID) != null) {\n              groupId=(String)event.get(MCConstant.GROUP_ID);\n            }\n else {\n              groupId=metricName;\n            }\n          }\n          long count=0;\n          if (event.get(MCConstant.AGGREGATED_COUNT) != null) {\n            count=(Long)event.get(MCConstant.AGGREGATED_COUNT);\n          }\n else {\n            count=(Long)event.get(MCConstant.METRIC_COUNT);\n          }\n          long metricTime=(Long)event.get(MCConstant.METRIC_TIME);\n          if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && (event.get(MCConstant.FIRST_FLUSH) == null)) {\n            metricTime=(metricTime / 60000) * 60000;\n          }\n          boolean counterTable=columnFamilyName.contains(COUNTER_TABLE);\n          if (counterTable) {\n            if (tags == null) {\n              tags=new HashMap<String,String>();\n              tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n            }\n            Calendar c=Calendar.getInstance();\n            c.setTimeInMillis(metricTime);\n          }\n          if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n            if (counterTable) {\n              if (updatestmtMap.get(columnFamilyName) == null) {\n                if (tags != null && tags.size() > 0) {\n                  prepareStatementsForUpdate(columnFamilyName,tags);\n                }\n else {\n                  prepareStatementsForUpdate(columnFamilyName,null);\n                }\n              }\n            }\n else {\n              if (stmtMap.get(columnFamilyName) == null) {\n                if (tags != null && tags.size() > 0) {\n                  prepareStatements(columnFamilyName,tags);\n                }\n else {\n                  prepareStatements(columnFamilyName,null);\n                }\n              }\n            }\n            metricColumnFamily.put(metricName,columnFamilyName);\n          }\n          if (config.getBatchSize() > 1) {\n            MetricCounter metric=new MetricCounter(metricName,groupId,tags,count,metricTime);\n            meticCounters.add(metric);\n            int counterSize=meticCounters.size();\n            if (counterSize >= config.getBatchSize()) {\n              publishToCassandraInBatch();\n            }\n else             if (event.get(LASTEVENTINBATCH) != null) {\n              ePLBatchCount.increment();\n              publishToCassandraInBatch();\n            }\n          }\n else {\n            if (event.get(LASTEVENTINBATCH) != null) {\n              ePLBatchCount.increment();\n            }\n            int parameterSize=4;\n            if (tags != null) {\n              parameterSize=4 + tags.size();\n            }\n            Object[] paramterValues=new Object[parameterSize];\n            if (counterTable) {\n              paramterValues[0]=count;\n              paramterValues[1]=metricName;\n              paramterValues[2]=groupId;\n              paramterValues[3]=new Date(metricTime);\n              int i=1;\n              if (tags != null) {\n                for (                Map.Entry<String,String> entry : tags.entrySet()) {\n                  paramterValues[3 + i]=entry.getValue();\n                  i++;\n                }\n              }\n            }\n else {\n              paramterValues[0]=metricName;\n              paramterValues[1]=groupId;\n              paramterValues[2]=new Date(metricTime);\n              int i=1;\n              if (tags != null) {\n                for (                Map.Entry<String,String> entry : tags.entrySet()) {\n                  paramterValues[2 + i]=entry.getValue();\n                  i++;\n                }\n              }\n              paramterValues[parameterSize - 1]=Long.valueOf(count).intValue();\n            }\n            publishToCassandra(paramterValues,event);\n          }\n        }\n catch (        Exception ex) {\n          LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n          cassandraErrorCount.increment();\n          if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n            event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n          }\n          getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n          eventSentToAdviceListener.increment();\n          registerError(ex);\n        }\n      }\n    }\n);\n  }\n}\n",
    "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MetricCassandraCollector.java",
    "Start": 10804,
    "Stop": 19857,
    "Project_Name": "data/projects/realtime-analytics",
    "Method_Name": "publishAsync"
}