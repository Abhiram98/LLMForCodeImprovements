{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Extract repeated code into its own method",
                "Change_Diff": "- if (tags != null && tags.size() > 0) { \n- prepareStatementsForUpdate(columnFamilyName,tags); \n- } else { \n- prepareStatements(columnFamilyName,null); \n- } \n+ prepareStatementsForUpdate(columnFamilyName, tags);",
                "Description": "The code block responsible for the preparation of statements for update is duplicated. In order to adhere to the DRY (Don't Repeat Yourself) principle, it would be advisable to abstract this code into its own method. This would enhance the readability of the code and reduce the possibility of errors.",
                "Start": 54,
                "End": 63
            },
            {
                "Improvement": "Use Optional for null checks",
                "Change_Diff": "- if (event.get(MCConstant.METRIC_DEMENSION) != null) { \n- MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION); \n+ Optional<MCMetricGroupDemension> groupDemensionOptional = Optional.ofNullable((MCMetricGroupDemension) event.get(MCConstant.METRIC_DEMENSION)); \n+ if (groupDemensionOptional.isPresent()) { \n+ MCMetricGroupDemension groupDemension = groupDemensionOptional.get();",
                "Description": "Java 8 introduced the Optional class for handling null values. Instead of using null checks, you can use Optional, which provides a clear and functional approach to handling null values. This can help prevent NullPointerExceptions.",
                "Start": 12,
                "End": 25
            }
        ],
        "Final code": "public void run() {\n    try {\n        String metricName = (String) event.get(MCConstant.METRIC_NAME);\n        String columnFamilyName = event.getEventType().toLowerCase();\n        String groupId = null;\n        Map<String, String> tags = null;\n        Optional<MCMetricGroupDemension> groupDemensionOptional = Optional.ofNullable((MCMetricGroupDemension) event.get(MCConstant.METRIC_DEMENSION));\n        if (groupDemensionOptional.isPresent()) {\n            MCMetricGroupDemension groupDemension = groupDemensionOptional.get();\n            groupId = groupDemension.getGroupId();\n            if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n                tags = new HashMap<String, String>(groupDemension.getDimensions());\n                tags.put(MCConstant.TAG_TIME_IGNORE, (String) event.get(MCConstant.TAG_TIME_IGNORE));\n            } else {\n                tags = groupDemension.getDimensions();\n            }\n        }\n        // Rest of the code \n        prepareStatementsForUpdate(columnFamilyName, tags);\n        // Rest of the code \n    } catch (Exception ex) {\n        // Exception handling \n    }\n}"
    },
    "Old_Method": "@Override public void run(){\n  try {\n    String metricName=(String)event.get(MCConstant.METRIC_NAME);\n    String columnFamilyName=event.getEventType().toLowerCase();\n    String groupId=null;\n    Map<String,String> tags=null;\n    if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n      MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n      groupId=groupDemension.getGroupId();\n      if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n        tags=new HashMap<String,String>(groupDemension.getDimensions());\n        tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n      }\n else {\n        tags=groupDemension.getDimensions();\n      }\n    }\n    if (groupId == null) {\n      if (event.get(MCConstant.GROUP_ID) != null) {\n        groupId=(String)event.get(MCConstant.GROUP_ID);\n      }\n else {\n        groupId=metricName;\n      }\n    }\n    long count=0;\n    if (event.get(MCConstant.AGGREGATED_COUNT) != null) {\n      count=(Long)event.get(MCConstant.AGGREGATED_COUNT);\n    }\n else {\n      count=(Long)event.get(MCConstant.METRIC_COUNT);\n    }\n    long metricTime=(Long)event.get(MCConstant.METRIC_TIME);\n    if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && (event.get(MCConstant.FIRST_FLUSH) == null)) {\n      metricTime=(metricTime / 60000) * 60000;\n    }\n    boolean counterTable=columnFamilyName.contains(COUNTER_TABLE);\n    if (counterTable) {\n      if (tags == null) {\n        tags=new HashMap<String,String>();\n        tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n      }\n      Calendar c=Calendar.getInstance();\n      c.setTimeInMillis(metricTime);\n    }\n    if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n      if (counterTable) {\n        if (updatestmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatementsForUpdate(columnFamilyName,tags);\n          }\n else {\n            prepareStatementsForUpdate(columnFamilyName,null);\n          }\n        }\n      }\n else {\n        if (stmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatements(columnFamilyName,tags);\n          }\n else {\n            prepareStatements(columnFamilyName,null);\n          }\n        }\n      }\n      metricColumnFamily.put(metricName,columnFamilyName);\n    }\n    if (config.getBatchSize() > 1) {\n      MetricCounter metric=new MetricCounter(metricName,groupId,tags,count,metricTime);\n      meticCounters.add(metric);\n      int counterSize=meticCounters.size();\n      if (counterSize >= config.getBatchSize()) {\n        publishToCassandraInBatch();\n      }\n else       if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n        publishToCassandraInBatch();\n      }\n    }\n else {\n      if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n      }\n      int parameterSize=4;\n      if (tags != null) {\n        parameterSize=4 + tags.size();\n      }\n      Object[] paramterValues=new Object[parameterSize];\n      if (counterTable) {\n        paramterValues[0]=count;\n        paramterValues[1]=metricName;\n        paramterValues[2]=groupId;\n        paramterValues[3]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (          Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[3 + i]=entry.getValue();\n            i++;\n          }\n        }\n      }\n else {\n        paramterValues[0]=metricName;\n        paramterValues[1]=groupId;\n        paramterValues[2]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (          Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[2 + i]=entry.getValue();\n            i++;\n          }\n        }\n        paramterValues[parameterSize - 1]=Long.valueOf(count).intValue();\n      }\n      publishToCassandra(paramterValues,event);\n    }\n  }\n catch (  Exception ex) {\n    LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n    cassandraErrorCount.increment();\n    if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n      event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n    }\n    getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n    eventSentToAdviceListener.increment();\n    registerError(ex);\n  }\n}\n",
    "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MetricCassandraCollector.java",
    "Start": 10962,
    "Stop": 19825,
    "Project_Name": "data/projects/realtime-analytics",
    "Method_Name": "run"
}