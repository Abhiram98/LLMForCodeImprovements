{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Use Optional instead of null checking",
                "Change_Diff": "- Long total=null;\n+ Optional<Long> total = Optional.empty();\n- if (total != null) {\n+ if (total.isPresent()) {",
                "Description": "It is better to use Optional instead of null checking for values that may potentially be null. This makes the code more robust and less prone to NullPointerExceptions.",
                "Start": 10,
                "End": 35
            },
            {
                "Improvement": "Avoid hardcoding numbers",
                "Change_Diff": "- Map<String,String> tags=new HashMap<String,String>(5);\n+ final int INITIAL_TAGS_SIZE = 5;\n+ Map<String,String> tags=new HashMap<String,String>(INITIAL_TAGS_SIZE);",
                "Description": "Hardcoded numbers can be confusing and make the code less maintainable. Instead, use a well-named constant to make the code more readable and easier to maintain.",
                "Start": 42,
                "End": 42
            },
            {
                "Improvement": "Remove redundant else statement",
                "Change_Diff": "- else {\n-   evaluateRawEvent(event);\n- }",
                "Description": "The last else statement to call the method evaluateRawEvent(event) is redundant because if none of the previous if conditions are met, the method will be called anyway. Removing this will make the code cleaner.",
                "Start": 79,
                "End": 81
            }
        ],
        "Final code": "@Override public void sendEvent(JetstreamEvent event) throws EventException {\n  if (isPaused() || shutdownFlag.get()) {\n    super.incrementEventDroppedCounter();\n    return;\n  }\n  incrementEventRecievedCounter();\n  if (MCCounterHelper.isMCCounterEvent(event)) {\n    String metricName=(String)event.get(MCConstant.METRIC_NAME);\n    Optional<Long> total = Optional.empty();\n    if (MCCounterHelper.isAvgEvent(metricName)) {\n      for (Map.Entry<String,Object> entry : event.entrySet()) {\n        if (entry.getKey().toLowerCase().contains('total')) {\n          total= Optional.ofNullable((Long)entry.getValue());\n          break;\n        }\n      }\n    }\n    if (event.get(MCConstant.METRIC_COUNT) != null) {\n      Long count=(Long)event.get(MCConstant.METRIC_COUNT);\n      if (total.isPresent()) {\n        ((AvgCounter)getCounterByMetricName(metricName,true)).inc(count,total.get());\n      }\n else {\n        getCounterByMetricName(metricName,false).inc(count);\n      }\n    }\n else {\n      getCounterByMetricName(metricName,false).inc();\n    }\n  }\n else if (MCCounterHelper.isMCMultiCounterEvent(event)) {\n    for (Map.Entry<String,Object> entry : event.entrySet()) {\n      if (entry.getKey().toLowerCase().contains('count')) {\n        String metricName=entry.getKey();\n        Long count=(Long)entry.getValue();\n        if (count != null) {\n          getCounterByMetricName(metricName,false).inc(count);\n        }\n else {\n          LOGGER.warn('Null Count returned by EPL, CountName:' + metricName);\n        }\n      }\n    }\n  }\n else if (MCCounterHelper.isGroupByCounterEvent(event)) {\n    if (getConfiguration().isEnableGroupByCounter()) {\n      String metricName=(String)event.get(MCConstant.METRIC_NAME);\n      String groupId=(String)event.get(MCConstant.GROUP_ID);\n      if (groupId != null && groupId.trim().length() != 0) {\n        long registerdFreq=getFrequencyByMetricName(metricName);\n        if (event.get(MCConstant.FREQUENCY_IN_MIN) == null && registerdFreq <= 0) {\n          setMetricFrequency(metricName,MetricFrequency.ONE_MINUTE.getValue());\n        }\n else if (event.get(MCConstant.FREQUENCY_IN_MIN) != null) {\n          Integer frequencyInMin=(Integer)event.get(MCConstant.FREQUENCY_IN_MIN);\n          long frequency=frequencyInMin * MetricFrequency.ONE_MINUTE.getValue();\n          if (frequency > 0 && frequency != registerdFreq) {\n            setMetricFrequency(metricName,frequency);\n          }\n        }\n        metricTables.put(metricName,event.getEventType());\n        final int INITIAL_TAGS_SIZE = 5;\n        Map<String,String> tags=new HashMap<String,String>(INITIAL_TAGS_SIZE);\n        MCCounterHelper.isGroupByCounterEventWithTag(event,tags);\n        Optional<Long> total = Optional.empty();\n        if (MCCounterHelper.isAvgEvent(metricName)) {\n          for (Map.Entry<String,Object> entry : event.entrySet()) {\n            if (entry.getKey().toLowerCase().contains('total')) {\n              total= Optional.ofNullable((Long)entry.getValue());\n              break;\n            }\n          }\n        }\n        if (event.get(MCConstant.METRIC_COUNT) != null) {\n          Long count=(Long)event.get(MCConstant.METRIC_COUNT);\n          if (total.isPresent()) {\n            getCounterByMetricDemensionAndInc(metricName,groupId,tags,true,count,total.get());\n          }\n else {\n            getCounterByMetricDemensionAndInc(metricName,groupId,tags,false,count,null);\n          }\n        }\n else {\n          getCounterByMetricDemensionAndInc(metricName,groupId,tags,false,null,null);\n        }\n      }\n else {\n        LOGGER.warn('Null or empty groupId returned by EPL, metricName:' + metricName);\n      }\n    }\n  }\n  evaluateRawEvent(event);\n}"
    },
    "Old_Method": "@Override public void sendEvent(JetstreamEvent event) throws EventException {\n  if (isPaused() || shutdownFlag.get()) {\n    super.incrementEventDroppedCounter();\n    return;\n  }\n  incrementEventRecievedCounter();\n  if (MCCounterHelper.isMCCounterEvent(event)) {\n    String metricName=(String)event.get(MCConstant.METRIC_NAME);\n    Long total=null;\n    if (MCCounterHelper.isAvgEvent(metricName)) {\n      for (      Map.Entry<String,Object> entry : event.entrySet()) {\n        if (entry.getKey().toLowerCase().contains(\"total\")) {\n          total=(Long)entry.getValue();\n          break;\n        }\n      }\n    }\n    if (event.get(MCConstant.METRIC_COUNT) != null) {\n      Long count=(Long)event.get(MCConstant.METRIC_COUNT);\n      if (total != null) {\n        ((AvgCounter)getCounterByMetricName(metricName,true)).inc(count,total);\n      }\n else       getCounterByMetricName(metricName,false).inc(count);\n    }\n else {\n      getCounterByMetricName(metricName,false).inc();\n    }\n  }\n else   if (MCCounterHelper.isMCMultiCounterEvent(event)) {\n    for (    Map.Entry<String,Object> entry : event.entrySet()) {\n      if (entry.getKey().toLowerCase().contains(\"count\")) {\n        String metricName=entry.getKey();\n        Long count=(Long)entry.getValue();\n        if (count != null) {\n          getCounterByMetricName(metricName,false).inc(count);\n        }\n else {\n          LOGGER.warn(\"Null Count returned by EPL, CountName:\" + metricName);\n        }\n      }\n    }\n  }\n else   if (MCCounterHelper.isGroupByCounterEvent(event)) {\n    if (getConfiguration().isEnableGroupByCounter()) {\n      String metricName=(String)event.get(MCConstant.METRIC_NAME);\n      String groupId=(String)event.get(MCConstant.GROUP_ID);\n      if (groupId != null && groupId.trim().length() != 0) {\n        long registerdFreq=getFrequencyByMetricName(metricName);\n        if (event.get(MCConstant.FREQUENCY_IN_MIN) == null && registerdFreq <= 0) {\n          setMetricFrequency(metricName,MetricFrequency.ONE_MINUTE.getValue());\n        }\n else         if (event.get(MCConstant.FREQUENCY_IN_MIN) != null) {\n          Integer frequencyInMin=(Integer)event.get(MCConstant.FREQUENCY_IN_MIN);\n          long frequency=frequencyInMin * MetricFrequency.ONE_MINUTE.getValue();\n          if (frequency > 0 && frequency != registerdFreq) {\n            setMetricFrequency(metricName,frequency);\n          }\n        }\n        metricTables.put(metricName,event.getEventType());\n        Map<String,String> tags=new HashMap<String,String>(5);\n        MCCounterHelper.isGroupByCounterEventWithTag(event,tags);\n        Long total=null;\n        if (MCCounterHelper.isAvgEvent(metricName)) {\n          for (          Map.Entry<String,Object> entry : event.entrySet()) {\n            if (entry.getKey().toLowerCase().contains(\"total\")) {\n              total=(Long)entry.getValue();\n              break;\n            }\n          }\n        }\n        if (event.get(MCConstant.METRIC_COUNT) != null) {\n          Long count=(Long)event.get(MCConstant.METRIC_COUNT);\n          if (total != null) {\n            getCounterByMetricDemensionAndInc(metricName,groupId,tags,true,count,total);\n          }\n else {\n            getCounterByMetricDemensionAndInc(metricName,groupId,tags,false,count,null);\n          }\n        }\n else {\n          getCounterByMetricDemensionAndInc(metricName,groupId,tags,false,null,null);\n        }\n      }\n else {\n        LOGGER.warn(\"Null or empty groupId returned by EPL, metricName:\" + metricName);\n      }\n    }\n  }\n else {\n    evaluateRawEvent(event);\n  }\n}\n",
    "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MCSummingProcessor.java",
    "Start": 18706,
    "Stop": 23760,
    "Project_Name": "data/projects/realtime-analytics",
    "Method_Name": "sendEvent"
}