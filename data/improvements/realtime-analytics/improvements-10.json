{
    "Method_Improvements": [{
        "Improvements": [
            {
                "Improvement": "Remove unused imports",
                "Change_Diff": "-import java.util.Map;\n-import java.util.HashMap;\n-import java.util.Calendar;\n-import java.util.Date;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n",
                "Description": "There are several unused imports in the code. They should be removed to improve code readability.",
                "Start": 3,
                "End": 4
            },
            {
                "Improvement": "Avoid unnecessary null checks",
                "Change_Diff": "-if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n-  MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n-  groupId=groupDemension.getGroupId();\n-  if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n-    tags=new HashMap<String,String>(groupDemension.getDimensions());\n-    tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n-  }\n- else {\n-    tags=groupDemension.getDimensions();\n-  }\n-}\n-if (groupId == null) {\n-  if (event.get(MCConstant.GROUP_ID) != null) {\n-    groupId=(String)event.get(MCConstant.GROUP_ID);\n-  }\n- else {\n-    groupId=metricName;\n-  }\n-}\n",
                "Description": "Some of the null checks can be avoided using the ternary operator.",
                "Start": 12,
                "End": 23
            },
            {
                "Improvement": "Use StringBuilder for string concatenation",
                "Change_Diff": "-LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n+LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\".concat(ex.getMessage()));\n",
                "Description": "Instead of using string concatenation with the '+' operator, use StringBuilder for better performance.",
                "Start": 112,
                "End": 113
            }
        ],
        "Final code": "@Override\npublic void run() {\n  try {\n    String metricName = (String) event.get(MCConstant.METRIC_NAME);\n    String columnFamilyName = event.getEventType().toLowerCase();\n    String groupId = null;\n    Map<String, String> tags = null;\n    if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n      MCMetricGroupDemension groupDemension = (MCMetricGroupDemension) event.get(MCConstant.METRIC_DEMENSION);\n      groupId = groupDemension.getGroupId();\n      tags = event.get(MCConstant.TAG_TIME_IGNORE) != null ?\n              new HashMap<>(groupDemension.getDimensions()) :\n              groupDemension.getDimensions();\n    }\n    groupId = groupId != null ? groupId : event.get(MCConstant.GROUP_ID) != null ?\n            (String) event.get(MCConstant.GROUP_ID) : metricName;\n    long count = event.get(MCConstant.AGGREGATED_COUNT) != null ?\n            (Long) event.get(MCConstant.AGGREGATED_COUNT) : (Long) event.get(MCConstant.METRIC_COUNT);\n    long metricTime = (Long) event.get(MCConstant.METRIC_TIME);\n    if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && event.get(MCConstant.FIRST_FLUSH) == null) {\n      metricTime = (metricTime / 60000) * 60000;\n    }\n    boolean counterTable = columnFamilyName.contains(COUNTER_TABLE);\n    if (counterTable) {\n      if (tags == null) {\n        tags = new HashMap<>();\n        tags.put(MCCounterHelper.TAG_METRICTIME, String.valueOf(event.get(MCConstant.METRIC_TIME)));\n      }\n      Calendar c = Calendar.getInstance();\n      c.setTimeInMillis(metricTime);\n    }\n    if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n      if (counterTable) {\n        if (updatestmtMap.get(columnFamilyName) == null) {\n          prepareStatementsForUpdate(columnFamilyName, tags != null && tags.size() > 0 ? tags : null);\n        }\n      } else {\n        if (stmtMap.get(columnFamilyName) == null) {\n          prepareStatements(columnFamilyName, tags != null && tags.size() > 0 ? tags : null);\n        }\n      }\n      metricColumnFamily.put(metricName, columnFamilyName);\n    }\n    if (config.getBatchSize() > 1) {\n      MetricCounter metric = new MetricCounter(metricName, groupId, tags, count, metricTime);\n      meticCounters.add(metric);\n      int counterSize = meticCounters.size();\n      if (counterSize >= config.getBatchSize()) {\n        publishToCassandraInBatch();\n      } else if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n        publishToCassandraInBatch();\n      }\n    } else {\n      if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n      }\n      int parameterSize = 4;\n      if (tags != null) {\n        parameterSize = 4 + tags.size();\n      }\n      Object[] paramterValues = new Object[parameterSize];\n      if (counterTable) {\n        paramterValues[0] = count;\n        paramterValues[1] = metricName;\n        paramterValues[2] = groupId;\n        paramterValues[3] = new Date(metricTime);\n        if (tags != null) {\n          int i = 1;\n          for (Map.Entry<String, String> entry : tags.entrySet()) {\n            paramterValues[3 + i] = entry.getValue();\n            i++;\n          }\n        }\n      } else {\n        paramterValues[0] = metricName;\n        paramterValues[1] = groupId;\n        paramterValues[2] = new Date(metricTime);\n        if (tags != null) {\n          int i = 1;\n          for (Map.Entry<String, String> entry : tags.entrySet()) {\n            paramterValues[2 + i] = entry.getValue();\n            i++;\n          }\n        }\n        paramterValues[parameterSize - 1] = Long.valueOf(count).intValue();\n      }\n      publishToCassandra(paramterValues, event);\n    }\n  } catch (Exception ex) {\n    LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\".concat(ex.getMessage()));\n    cassandraErrorCount.increment();\n    if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n      event.put(JetstreamReservedKeys.MessageAffinityKey.toString(), (String) event.get(MCConstant.METRIC_NAME));\n    }\n    getAdviceListener().retry(event, RetryEventCode.MSG_RETRY, ex.getMessage());\n    eventSentToAdviceListener.increment();\n    registerError(ex);\n  }\n}"
    }],
    "Old_Method": "@Override public void run(){\n  try {\n    String metricName=(String)event.get(MCConstant.METRIC_NAME);\n    String columnFamilyName=event.getEventType().toLowerCase();\n    String groupId=null;\n    Map<String,String> tags=null;\n    if (event.get(MCConstant.METRIC_DEMENSION) != null) {\n      MCMetricGroupDemension groupDemension=(MCMetricGroupDemension)event.get(MCConstant.METRIC_DEMENSION);\n      groupId=groupDemension.getGroupId();\n      if (event.get(MCConstant.TAG_TIME_IGNORE) != null) {\n        tags=new HashMap<String,String>(groupDemension.getDimensions());\n        tags.put(MCConstant.TAG_TIME_IGNORE,(String)event.get(MCConstant.TAG_TIME_IGNORE));\n      }\n else {\n        tags=groupDemension.getDimensions();\n      }\n    }\n    if (groupId == null) {\n      if (event.get(MCConstant.GROUP_ID) != null) {\n        groupId=(String)event.get(MCConstant.GROUP_ID);\n      }\n else {\n        groupId=metricName;\n      }\n    }\n    long count=0;\n    if (event.get(MCConstant.AGGREGATED_COUNT) != null) {\n      count=(Long)event.get(MCConstant.AGGREGATED_COUNT);\n    }\n else {\n      count=(Long)event.get(MCConstant.METRIC_COUNT);\n    }\n    long metricTime=(Long)event.get(MCConstant.METRIC_TIME);\n    if (event.get(MCConstant.SHUTDOWN_FLUSH) == null && (event.get(MCConstant.FIRST_FLUSH) == null)) {\n      metricTime=(metricTime / 60000) * 60000;\n    }\n    boolean counterTable=columnFamilyName.contains(COUNTER_TABLE);\n    if (counterTable) {\n      if (tags == null) {\n        tags=new HashMap<String,String>();\n        tags.put(MCCounterHelper.TAG_METRICTIME,String.valueOf(event.get(MCConstant.METRIC_TIME)));\n      }\n      Calendar c=Calendar.getInstance();\n      c.setTimeInMillis(metricTime);\n    }\n    if (metricColumnFamily.get(metricName) == null || !metricColumnFamily.get(metricName).equals(columnFamilyName)) {\n      if (counterTable) {\n        if (updatestmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatementsForUpdate(columnFamilyName,tags);\n          }\n else {\n            prepareStatementsForUpdate(columnFamilyName,null);\n          }\n        }\n      }\n else {\n        if (stmtMap.get(columnFamilyName) == null) {\n          if (tags != null && tags.size() > 0) {\n            prepareStatements(columnFamilyName,tags);\n          }\n else {\n            prepareStatements(columnFamilyName,null);\n          }\n        }\n      }\n      metricColumnFamily.put(metricName,columnFamilyName);\n    }\n    if (config.getBatchSize() > 1) {\n      MetricCounter metric=new MetricCounter(metricName,groupId,tags,count,metricTime);\n      meticCounters.add(metric);\n      int counterSize=meticCounters.size();\n      if (counterSize >= config.getBatchSize()) {\n        publishToCassandraInBatch();\n      }\n else       if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n        publishToCassandraInBatch();\n      }\n    }\n else {\n      if (event.get(LASTEVENTINBATCH) != null) {\n        ePLBatchCount.increment();\n      }\n      int parameterSize=4;\n      if (tags != null) {\n        parameterSize=4 + tags.size();\n      }\n      Object[] paramterValues=new Object[parameterSize];\n      if (counterTable) {\n        paramterValues[0]=count;\n        paramterValues[1]=metricName;\n        paramterValues[2]=groupId;\n        paramterValues[3]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (          Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[3 + i]=entry.getValue();\n            i++;\n          }\n        }\n      }\n else {\n        paramterValues[0]=metricName;\n        paramterValues[1]=groupId;\n        paramterValues[2]=new Date(metricTime);\n        int i=1;\n        if (tags != null) {\n          for (          Map.Entry<String,String> entry : tags.entrySet()) {\n            paramterValues[2 + i]=entry.getValue();\n            i++;\n          }\n        }\n        paramterValues[parameterSize - 1]=Long.valueOf(count).intValue();\n      }\n      publishToCassandra(paramterValues,event);\n    }\n  }\n catch (  Exception ex) {\n    LOGGER.error(\"Error publising metrics in MetricCassandraCollector:\" + ex.getMessage());\n    cassandraErrorCount.increment();\n    if (event.get(JetstreamReservedKeys.MessageAffinityKey.toString()) == null) {\n      event.put(JetstreamReservedKeys.MessageAffinityKey.toString(),(String)event.get(MCConstant.METRIC_NAME));\n    }\n    getAdviceListener().retry(event,RetryEventCode.MSG_RETRY,ex.getMessage());\n    eventSentToAdviceListener.increment();\n    registerError(ex);\n  }\n}\n",
    "File_Path": "realtime-analytics/metriccalculator/src/main/java/com/ebay/pulsar/metriccalculator/processor/MetricCassandraCollector.java",
    "Start": 10962,
    "Stop": 19825,
    "Project_Name": "data/projects/realtime-analytics",
    "Method_Name": "run"
}