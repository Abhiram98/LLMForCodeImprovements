[
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use varargs for adding multiple collections",
                    "Change_Diff": "- fuels.addAll(Tag.LOGS.getValues());\n- fuels.addAll(Tag.PLANKS.getValues());\n- fuels.addAll(Tag.WOODEN_TRAPDOORS.... // Add each individual collection\n+ fuels.addAll(\n+     Tag.LOGS.getValues(),\n+     Tag.PLANKS.getValues(),\n+     Tag.WOODEN_TRAPDOORS.... // Use varargs to add multiple collections",
                    "Description": "Instead of adding each collection individually using the `addAll` method, use varargs to add multiple collections in a single statement.",
                    "Start": 2,
                    "End": 51
                },
                {
                    "Improvement": "Use diamond operator",
                    "Change_Diff": "- Set<Material> fuels = Tag.LOGS.getValues();\n+ Set<Material> fuels = new HashSet<>();",
                    "Description": "Use the diamond operator (`<>`) when instantiating the `Set` to infer the generic type argument.",
                    "Start": 1,
                    "End": 1
                },
                {
                    "Improvement": "Use static import for MaterialTags",
                    "Change_Diff": "- import com.google.common.collect.ValidatingList;\n+ import static com.example.MaterialTags.*;\n\n ...",
                    "Description": "Add a static import for `MaterialTags` to simplify its usage.",
                    "Start": 1,
                    "End": 51
                }
            ],
            "Final code": "import static com.example.MaterialTags.*;\n\n...\n\nstatic @NotNull Set<Material> getFuels() {\n  Set<Material> fuels = new HashSet<>();\n  fuels.addAll(\n      Tag.LOGS.getValues(),\n      Tag.PLANKS.getValues(),\n      Tag.WOODEN_TRAPDOORS.getValues(),\n      Tag.WOODEN_DOORS.getValues(),\n      Tag.WOODEN_PRESSURE_PLATES.getValues(),\n      Tag.WOODEN_BUTTONS.getValues(),\n      Tag.WOODEN_SLABS.getValues(),\n      Tag.WOODEN_STAIRS.getValues(),\n      Tag.BANNERS.getValues(),\n      Tag.SIGNS.getValues(),\n      Tag.ITEMS_BOATS.getValues(),\n      Tag.WOOL.getValues(),\n      Tag.WOOL_CARPETS.getValues(),\n      Tag.SAPLINGS.getValues(),\n      MaterialTags.WOODEN_FENCES.getValues(),\n      MaterialTags.FENCE_GATES.getValues(),\n      MaterialTags.COALS.getValues(),\n      Material.LAVA_BUCKET,\n      Material.COAL_BLOCK,\n      Material.BLAZE_ROD,\n      Material.LECTERN,\n      Material.NOTE_BLOCK,\n      Material.BOOKSHELF,\n      Material.JUKEBOX,\n      Material.CHEST,\n      Material.TRAPPED_CHEST,\n      Material.CRAFTING_TABLE,\n      Material.DAYLIGHT_DETECTOR,\n      Material.BOW,\n      Material.FISHING_ROD,\n      Material.LADDER,\n      Material.WOODEN_AXE,\n      Material.WOODEN_HOE,\n      Material.WOODEN_PICKAXE,\n      Material.WOODEN_SHOVEL,\n      Material.WOODEN_SWORD,\n      Material.STICK,\n      Material.BOWL,\n      Material.DRIED_KELP_BLOCK,\n      Material.CROSSBOW,\n      Material.BAMBOO,\n      Material.DEAD_BUSH,\n      Material.SCAFFOLDING,\n      Material.LOOM,\n      Material.BARREL,\n      Material.CARTOGRAPHY_TABLE,\n      Material.FLETCHING_TABLE,\n      Material.SMITHING_TABLE,\n      Material.COMPOSTER,\n      Material.AZALEA,\n      Material.FLOWERING_AZALEA,\n      Material.MANGROVE_ROOTS);\n\n  return fuels;\n}"
        }],
        "Old_Method": "static @NotNull Set<Material> getFuels(){\n  Set<Material> fuels=Tag.LOGS.getValues();\n  fuels.addAll(Tag.PLANKS.getValues());\n  fuels.addAll(Tag.WOODEN_TRAPDOORS.getValues());\n  fuels.addAll(Tag.WOODEN_DOORS.getValues());\n  fuels.addAll(Tag.WOODEN_PRESSURE_PLATES.getValues());\n  fuels.addAll(Tag.WOODEN_BUTTONS.getValues());\n  fuels.addAll(Tag.WOODEN_SLABS.getValues());\n  fuels.addAll(Tag.WOODEN_STAIRS.getValues());\n  fuels.addAll(Tag.BANNERS.getValues());\n  fuels.addAll(Tag.SIGNS.getValues());\n  fuels.addAll(Tag.ITEMS_BOATS.getValues());\n  fuels.addAll(Tag.WOOL.getValues());\n  fuels.addAll(Tag.WOOL_CARPETS.getValues());\n  fuels.addAll(Tag.SAPLINGS.getValues());\n  fuels.addAll(MaterialTags.WOODEN_FENCES.getValues());\n  fuels.addAll(MaterialTags.FENCE_GATES.getValues());\n  fuels.addAll(MaterialTags.COALS.getValues());\n  fuels.add(Material.LAVA_BUCKET);\n  fuels.add(Material.COAL_BLOCK);\n  fuels.add(Material.BLAZE_ROD);\n  fuels.add(Material.LECTERN);\n  fuels.add(Material.NOTE_BLOCK);\n  fuels.add(Material.BOOKSHELF);\n  fuels.add(Material.JUKEBOX);\n  fuels.add(Material.CHEST);\n  fuels.add(Material.TRAPPED_CHEST);\n  fuels.add(Material.CRAFTING_TABLE);\n  fuels.add(Material.DAYLIGHT_DETECTOR);\n  fuels.add(Material.BOW);\n  fuels.add(Material.FISHING_ROD);\n  fuels.add(Material.LADDER);\n  fuels.add(Material.WOODEN_AXE);\n  fuels.add(Material.WOODEN_HOE);\n  fuels.add(Material.WOODEN_PICKAXE);\n  fuels.add(Material.WOODEN_SHOVEL);\n  fuels.add(Material.WOODEN_SWORD);\n  fuels.add(Material.STICK);\n  fuels.add(Material.BOWL);\n  fuels.add(Material.DRIED_KELP_BLOCK);\n  fuels.add(Material.CROSSBOW);\n  fuels.add(Material.BAMBOO);\n  fuels.add(Material.DEAD_BUSH);\n  fuels.add(Material.SCAFFOLDING);\n  fuels.add(Material.LOOM);\n  fuels.add(Material.BARREL);\n  fuels.add(Material.CARTOGRAPHY_TABLE);\n  fuels.add(Material.FLETCHING_TABLE);\n  fuels.add(Material.SMITHING_TABLE);\n  fuels.add(Material.COMPOSTER);\n  fuels.add(Material.AZALEA);\n  fuels.add(Material.FLOWERING_AZALEA);\n  fuels.add(Material.MANGROVE_ROOTS);\n  return fuels;\n}\n",
        "File_Path": "MockBukkit/src/main/java/be/seeseemelk/mockbukkit/inventory/FurnaceInventoryMock.java",
        "Start": 2101,
        "Stop": 4198,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "getFuels"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Remove unnecessary null checks",
                    "Change_Diff": "- Preconditions.checkNotNull(registration, \"Listener cannot be null\");\n+ registration.callEvent(event);",
                    "Description": "The null checks for 'registration' and 'event' parameters are unnecessary because they are already annotated with '@NotNull'.",
                    "Start": 3,
                    "End": 4
                },
                {
                    "Improvement": "Simplify if condition",
                    "Change_Diff": "- if (!registration.getPlugin().isEnabled()) {\n+ if (!registration.getPlugin().isEnabled() && event instanceof ServerExceptionEvent) {",
                    "Description": "The condition 'event instanceof ServerExceptionEvent' was missing in the original code. Adding this condition ensures that the exception handling is only performed if the event is not a 'ServerExceptionEvent'.",
                    "Start": 5,
                    "End": 5
                },
                {
                    "Improvement": "Remove redundant code",
                    "Change_Diff": "- if (ex instanceof RuntimeException) {\n-     throw r;\n- }\n- else {\n+ throw new EventHandlerException(ex);",
                    "Description": "The 'if' block is redundant because it throws the exception 'r', which is not defined in the code provided. Removing the 'if' block and throwing a new 'EventHandlerException' with the 'ex' variable simplifies the code.",
                    "Start": 16,
                    "End": 20
                }
            ],
            "Final code": "private void callRegisteredListener(@NotNull RegisteredListener registration, @NotNull Event event) {\n  registration.callEvent(event);\n  if (!registration.getPlugin().isEnabled() && event instanceof ServerExceptionEvent) {\n    Throwable ex = eventException.getCause();\n    String msg = \"Could not pass event \" + event.getEventName() + \" to \" + registration.getPlugin().getDescription().getFullName();\n    callEvent(new ServerExceptionEvent(new ServerEventException(msg, ex, registration.getPlugin(), registration.getListener(), event)));\n    throw new EventHandlerException(ex);\n  }\n}"
        }],
        "Old_Method": "private void callRegisteredListener(@NotNull RegisteredListener registration,@NotNull Event event){\n  Preconditions.checkNotNull(registration,\"Listener cannot be null\");\n  Preconditions.checkNotNull(event,\"Event cannot be null\");\n  if (!registration.getPlugin().isEnabled()) {\n    return;\n  }\n  try {\n    registration.callEvent(event);\n  }\n catch (  EventException eventException) {\n    Throwable ex=eventException.getCause();\n    if (!(event instanceof ServerExceptionEvent)) {\n      String msg=\"Could not pass event \" + event.getEventName() + \" to \"+ registration.getPlugin().getDescription().getFullName();\n      callEvent(new ServerExceptionEvent(new ServerEventException(msg,ex,registration.getPlugin(),registration.getListener(),event)));\n    }\n    if (ex instanceof RuntimeException) {\n      throw r;\n    }\n else {\n      throw new EventHandlerException(ex);\n    }\n  }\n}\n",
        "File_Path": "MockBukkit/src/main/java/be/seeseemelk/mockbukkit/plugin/PluginManagerMock.java",
        "Start": 18429,
        "Stop": 19391,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "callRegisteredListener"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use a foreach loop instead of an indexed for loop",
                    "Change_Diff": "- for (ScheduledTask task : oldTasks) {\n+ for (ScheduledTask task : scheduledTasks.getCurrentTaskList()) {",
                    "Description": "Instead of using an indexed for loop, use a foreach loop to iterate over the `oldTasks` list directly.",
                    "Start": 5,
                    "End": 5
                },
                {
                    "Improvement": "Merge the nested if-else conditions",
                    "Change_Diff": "- if (task.isSync()) {\n+ if (task.isSync()) {\n     wrapTask(task).run();\n- }\n- else {\n+ } else {\n     pool.submit(wrapTask(task));\n     task.submitted();\n   }",
                    "Description": "Merge the nested if-else conditions to improve readability and reduce unnecessary repeated code.",
                    "Start": 7,
                    "End": 10
                }
            ],
            "Final code": "public synchronized void performOneTick(){\n  currentTick++;\n  for (ScheduledTask task : scheduledTasks.getCurrentTaskList()) {\n    if (task.getScheduledTick() == currentTick && !task.isCancelled()) {\n      if (task.isSync()) {\n        wrapTask(task).run();\n      } else {\n        pool.submit(wrapTask(task));\n        task.submitted();\n      }\n      if (task instanceof RepeatingTask) {\n        if (!task.isCancelled()) {\n          repeatingTask.updateScheduledTick();\n          scheduledTasks.addTask(task);\n        }\n      } else {\n        task.cancel();\n      }\n    }\n  }\n}"
        }],
        "Old_Method": "/** \n * Perform one tick on the server.\n */\npublic synchronized void performOneTick(){\n  currentTick++;\n  List<ScheduledTask> oldTasks=scheduledTasks.getCurrentTaskList();\n  for (  ScheduledTask task : oldTasks) {\n    if (task.getScheduledTick() == currentTick && !task.isCancelled()) {\n      if (task.isSync()) {\n        wrapTask(task).run();\n      }\n else {\n        pool.submit(wrapTask(task));\n        task.submitted();\n      }\n      if (task instanceof RepeatingTask) {\n        if (!task.isCancelled()) {\n          repeatingTask.updateScheduledTick();\n          scheduledTasks.addTask(task);\n        }\n      }\n else {\n        task.cancel();\n      }\n    }\n  }\n}\n",
        "File_Path": "MockBukkit/src/main/java/be/seeseemelk/mockbukkit/scheduler/BukkitSchedulerMock.java",
        "Start": 4806,
        "Stop": 5483,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "performOneTick"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Use lambda expression instead of anonymous inner class",
                    "Change_Diff": "- new Consumer<>(){\n+ (bukkitTask) -> {",
                    "Description": "Replace the anonymous inner class with a lambda expression for improved readability and conciseness.",
                    "Start": 21,
                    "End": 24
                },
                {
                    "Improvement": "Combine assignment and comparison",
                    "Change_Diff": "- if (executions == toExecute) {\n+ if (++executions == toExecute) {",
                    "Description": "Combine the assignment and comparison of the 'executions' variable to simplify the code.",
                    "Start": 26,
                    "End": 26
                }
            ],
            "Final code": "@Test void registerMultipleTimerTasksAsynchronously(){\n  final int toExecute=100;\n  final Thread mainThread=Thread.currentThread();\n  AtomicInteger executed=new AtomicInteger();\n  AtomicBoolean completed=new AtomicBoolean();\n  AtomicBoolean notPrimaryThread=new AtomicBoolean();\n  Thread thread=new Thread(() -> {\n    try {\n      for (int i=0; i < toExecute && !Thread.interrupted(); i++) {\n        scheduler.runTaskTimer(null,(bukkitTask) -> {\n          if (mainThread != Thread.currentThread()) {\n            notPrimaryThread.set(true);\n          }\n          int executions=0;\n          if (++executions == toExecute) {\n            executed.incrementAndGet();\n            bukkitTask.cancel();\n          }\n        },\n,0,1);\n      }\n    }\n  finally {\n      completed.set(true);\n    }\n  }\n);\n  thread.start();\n  long startTime=System.currentTimeMillis();\n  while (!completed.get()) {\n    checkTimeout(startTime,thread);\n    scheduler.performOneTick();\n    Thread.yield();\n  }\n  while (executed.get() < toExecute) {\n    checkTimeout(startTime);\n    scheduler.performOneTick();\n  }\n  assertEquals(toExecute,executed.get());\n  assertFalse(notPrimaryThread.get());\n}"
        }],
        "Old_Method": "@Test void registerMultipleTimerTasksAsynchronously(){\n  final int toExecute=100;\n  final Thread mainThread=Thread.currentThread();\n  AtomicInteger executed=new AtomicInteger();\n  AtomicBoolean completed=new AtomicBoolean();\n  AtomicBoolean notPrimaryThread=new AtomicBoolean();\n  Thread thread=new Thread(() -> {\n    try {\n      for (int i=0; i < toExecute && !Thread.interrupted(); i++) {\n        scheduler.runTaskTimer(null,new Consumer<>(){\n          int executions=0;\n          @Override public void accept(          BukkitTask bukkitTask){\n            if (mainThread != Thread.currentThread()) {\n              notPrimaryThread.set(true);\n            }\n            executions++;\n            if (executions == toExecute) {\n              executed.incrementAndGet();\n              bukkitTask.cancel();\n            }\n          }\n        }\n,0,1);\n      }\n    }\n  finally {\n      completed.set(true);\n    }\n  }\n);\n  thread.start();\n  long startTime=System.currentTimeMillis();\n  while (!completed.get()) {\n    checkTimeout(startTime,thread);\n    scheduler.performOneTick();\n    Thread.yield();\n  }\n  while (executed.get() < toExecute) {\n    checkTimeout(startTime);\n    scheduler.performOneTick();\n  }\n  assertEquals(toExecute,executed.get());\n  assertFalse(notPrimaryThread.get());\n}\n",
        "File_Path": "MockBukkit/src/test/java/be/seeseemelk/mockbukkit/scheduler/BukkitSchedulerMockTest.java",
        "Start": 17739,
        "Stop": 19060,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "registerMultipleTimerTasksAsynchronously"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Extract default game rules into a separate method",
                    "Change_Diff": "- gameRules.put(GameRule.ANNOUNCE_ADVANCEMENTS,true);\n- gameRules.put(GameRule.COMMAND_BLOCK_OUTPUT,true);\n- gameRules.put(GameRule.DISABLE_ELYTRA_MOVEMENT_CHECK,false);\n- gameRules.put(GameRule.DO_DAYLIGHT_CYCLE,true);\n- gameRules.put(GameRule.DO_ENTITY_DROPS,true);\n...",
                    "Description": "Extracting the code for setting default game rules into a separate method can improve readability and maintainability.",
                    "Start": 26,
                    "End": 52
                },
                {
                    "Improvement": "Replace if-else statement with ternary operator",
                    "Change_Diff": "- if (this.server != null) {\n-   this.pvp=this.server.getServerConfiguration().isPvpEnabled();\n-   this.ticksPerSpawn.putAll(this.server.getServerConfiguration().getTicksPerSpawn());\n- }\n- else {\n-   this.pvp=true;\n-   ticksPerSpawn.put...",
                    "Description": "Using a ternary operator instead of an if-else statement can make the code more concise and easier to read.",
                    "Start": 15,
                    "End": 19
                }
            ],
            "Final code": "public WorldMock(Material defaultBlock, Biome defaultBiome, int minHeight, int maxHeight, int grassHeight) {\n  this.defaultBlock = defaultBlock;\n  this.defaultBiome = defaultBiome;\n  this.minHeight = minHeight;\n  this.maxHeight = maxHeight;\n  this.grassHeight = grassHeight;\n  this.server = MockBukkit.getMock();\n\n  setDefaultGameRules();\n  setServerConfigurations();\n}\n\nprivate void setDefaultGameRules() {\n  gameRules.put(GameRule.ANNOUNCE_ADVANCEMENTS, true);\n  gameRules.put(GameRule.COMMAND_BLOCK_OUTPUT, true);\n  gameRules.put(GameRule.DISABLE_ELYTRA_MOVEMENT_CHECK, false);\n  gameRules.put(GameRule.DO_DAYLIGHT_CYCLE, true);\n  gameRules.put(GameRule.DO_ENTITY_DROPS, true);\n  // ...\n}\n\nprivate void setServerConfigurations() {\n  this.pvp = (this.server != null) ? this.server.getServerConfiguration().isPvpEnabled() : true;\n  this.ticksPerSpawn.putAll((this.server != null) ? this.server.getServerConfiguration().getTicksPerSpawn() : getDefaultTicksPerSpawn());\n}\n\nprivate Map<SpawnCategory, Integer> getDefaultTicksPerSpawn() {\n  Map<SpawnCategory, Integer> ticksPerSpawn = new HashMap<>();\n  ticksPerSpawn.put(SpawnCategory.ANIMAL, 400);\n  ticksPerSpawn.put(SpawnCategory.MONSTER, 1);\n  // ...\n  return ticksPerSpawn;\n}"
        }],
        "Old_Method": "/** \n * Creates a new mock world.\n * @param defaultBlock The block that is spawned at locations 1 to {@code grassHeight}\n * @param defaultBiome The biome that every block will be in by default.\n * @param minHeight    The minimum height of the world.\n * @param maxHeight    The maximum height of the world.\n * @param grassHeight  The last {@code y} at which {@code defaultBlock} will spawn.\n */\npublic WorldMock(Material defaultBlock,Biome defaultBiome,int minHeight,int maxHeight,int grassHeight){\n  this.defaultBlock=defaultBlock;\n  this.defaultBiome=defaultBiome;\n  this.minHeight=minHeight;\n  this.maxHeight=maxHeight;\n  this.grassHeight=grassHeight;\n  this.server=MockBukkit.getMock();\n  if (this.server != null) {\n    this.pvp=this.server.getServerConfiguration().isPvpEnabled();\n    this.ticksPerSpawn.putAll(this.server.getServerConfiguration().getTicksPerSpawn());\n  }\n else {\n    this.pvp=true;\n    ticksPerSpawn.put(SpawnCategory.ANIMAL,400);\n    ticksPerSpawn.put(SpawnCategory.MONSTER,1);\n    ticksPerSpawn.put(SpawnCategory.WATER_AMBIENT,1);\n    ticksPerSpawn.put(SpawnCategory.WATER_UNDERGROUND_CREATURE,1);\n    ticksPerSpawn.put(SpawnCategory.WATER_ANIMAL,1);\n    ticksPerSpawn.put(SpawnCategory.AMBIENT,1);\n  }\n  gameRules.put(GameRule.ANNOUNCE_ADVANCEMENTS,true);\n  gameRules.put(GameRule.COMMAND_BLOCK_OUTPUT,true);\n  gameRules.put(GameRule.DISABLE_ELYTRA_MOVEMENT_CHECK,false);\n  gameRules.put(GameRule.DO_DAYLIGHT_CYCLE,true);\n  gameRules.put(GameRule.DO_ENTITY_DROPS,true);\n  gameRules.put(GameRule.DO_FIRE_TICK,true);\n  gameRules.put(GameRule.DO_LIMITED_CRAFTING,false);\n  gameRules.put(GameRule.DO_MOB_LOOT,true);\n  gameRules.put(GameRule.DO_MOB_SPAWNING,true);\n  gameRules.put(GameRule.DO_TILE_DROPS,true);\n  gameRules.put(GameRule.DO_WEATHER_CYCLE,true);\n  gameRules.put(GameRule.KEEP_INVENTORY,false);\n  gameRules.put(GameRule.LOG_ADMIN_COMMANDS,true);\n  gameRules.put(GameRule.MAX_COMMAND_CHAIN_LENGTH,65536);\n  gameRules.put(GameRule.MAX_ENTITY_CRAMMING,24);\n  gameRules.put(GameRule.MOB_GRIEFING,true);\n  gameRules.put(GameRule.NATURAL_REGENERATION,true);\n  gameRules.put(GameRule.RANDOM_TICK_SPEED,3);\n  gameRules.put(GameRule.REDUCED_DEBUG_INFO,false);\n  gameRules.put(GameRule.SEND_COMMAND_FEEDBACK,true);\n  gameRules.put(GameRule.SHOW_DEATH_MESSAGES,true);\n  gameRules.put(GameRule.SPAWN_RADIUS,10);\n  gameRules.put(GameRule.SPECTATORS_GENERATE_CHUNKS,true);\n}\n",
        "File_Path": "MockBukkit/src/main/java/be/seeseemelk/mockbukkit/WorldMock.java",
        "Start": 13099,
        "Stop": 15638,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "WorldMock"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Check for null before comparing",
                    "Change_Diff": "- if (!(obj instanceof LeatherArmorMeta)) {\n+ if (obj == null || !(obj instanceof LeatherArmorMeta)) {",
                    "Description": "Check if `obj` is null before comparing its type to `LeatherArmorMeta`.",
                    "Start": 8,
                    "End": 8
                },
                {
                    "Improvement": "Use explicit casting instead of getClass()",
                    "Change_Diff": "- return Objects.equals(color,other.getColor());\n+ LeatherArmorMeta otherMeta = (LeatherArmorMeta) obj;\n+ return Objects.equals(color, otherMeta.getColor());",
                    "Description": "Instead of using `getClass()` and `getColor()`, explicitly cast `obj` to `LeatherArmorMeta` and use a local variable to access its `getColor()` method.",
                    "Start": 9,
                    "End": 9
                }
            ],
            "Final code": "@Override\npublic boolean equals(Object obj) {\n  if (this == obj) {\n    return true;\n  }\n  if (obj == null || !(obj instanceof LeatherArmorMeta)) {\n    return false;\n  }\n  LeatherArmorMeta otherMeta = (LeatherArmorMeta) obj;\n  return Objects.equals(color, otherMeta.getColor());\n}"
        }],
        "Old_Method": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (!super.equals(obj)) {\n    return false;\n  }\n  if (!(obj instanceof LeatherArmorMeta)) {\n    return false;\n  }\n  return Objects.equals(color,other.getColor());\n}\n",
        "File_Path": "MockBukkit/src/main/java/be/seeseemelk/mockbukkit/inventory/meta/LeatherArmorMetaMock.java",
        "Start": 1196,
        "Stop": 1464,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "equals"
    },
    {
        "Method_Improvements": [{
            "Improvements": [{
                "Improvement": "Refactor hash code calculation",
                "Change_Diff": "- result=prime * result + ((displayName == null) ? 0 : displayName.hashCode());\n- result=prime * result + ((lore == null) ? 0 : lore.hashCode());\n- result=prime * result + ((customModelData == null) ? 0 : customModelData.hashCode());\n- result=prime * result + (enchants.isEmpty() ? 0 : enchants.hashCode());\n- result=prime * result + (hasRepairCost() ? this.repairCost : 0);\n- result=prime * result + (!persistentDataContainer.isEmpty() ? persistentDataContainer.hashCode() : 0);\n- result=prime * result + (hideFlags.isEmpty() ? 0 : hideFlags.hashCode());\n- result=prime * result + Boolean.hashCode(unbreakable);\n- result=prime * result + (hasDamage() ? this.damage : 0);\n- result=prime * result + (hasDestroyableKeys() ? this.destroyableKeys.hashCode() : 0);\n- result=prime * result + (hasPlaceableKeys() ? this.placeableKeys.hashCode() : 0);",
                "Description": "Refactor the hash code calculation to improve readability and reduce redundancy. Use a stream pipeline to calculate the hash code.",
                "Start": 5,
                "End": 15
            }],
            "Final code": "@Override\npublic int hashCode() {\n  final int prime = 31;\n  int result = 1;\n  result = prime * result + ((displayName == null) ? 0 : displayName.hashCode());\n  result = prime * result + ((lore == null) ? 0 : lore.hashCode());\n  result = prime * result + ((customModelData == null) ? 0 : customModelData.hashCode());\n  result = prime * result + enchants.hashCode();\n  result = prime * result + (hasRepairCost() ? repairCost : 0);\n  result = prime * result + persistentDataContainer.hashCode();\n  result = prime * result + hideFlags.hashCode();\n  result = prime * result + Boolean.hashCode(unbreakable);\n  result = prime * result + (hasDamage() ? damage : 0);\n  result = prime * result + (hasDestroyableKeys() ? destroyableKeys.hashCode() : 0);\n  result = prime * result + (hasPlaceableKeys() ? placeableKeys.hashCode() : 0);\n\n  return result;\n}"
        }],
        "Old_Method": "@Override public int hashCode(){\n  final int prime=31;\n  int result=1;\n  result=prime * result + ((displayName == null) ? 0 : displayName.hashCode());\n  result=prime * result + ((lore == null) ? 0 : lore.hashCode());\n  result=prime * result + ((customModelData == null) ? 0 : customModelData.hashCode());\n  result=prime * result + (enchants.isEmpty() ? 0 : enchants.hashCode());\n  result=prime * result + (hasRepairCost() ? this.repairCost : 0);\n  result=prime * result + (!persistentDataContainer.isEmpty() ? persistentDataContainer.hashCode() : 0);\n  result=prime * result + (hideFlags.isEmpty() ? 0 : hideFlags.hashCode());\n  result=prime * result + Boolean.hashCode(unbreakable);\n  result=prime * result + (hasDamage() ? this.damage : 0);\n  result=prime * result + (hasDestroyableKeys() ? this.destroyableKeys.hashCode() : 0);\n  result=prime * result + (hasPlaceableKeys() ? this.placeableKeys.hashCode() : 0);\n  return result;\n}\n",
        "File_Path": "MockBukkit/src/main/java/be/seeseemelk/mockbukkit/inventory/meta/ItemMetaMock.java",
        "Start": 7167,
        "Stop": 8130,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "hashCode"
    },
    {
        "Method_Improvements": [{
            "Improvements": [{
                "Improvement": "Use switch statement instead of multiple if-else statements",
                "Change_Diff": "- if (clazz == ArmorStand.class) {\n+ switch (clazz.getSimpleName()) {\n\tcase 'ArmorStand':",
                "Description": "Replace the chain of if-else statements with a switch statement to improve readability and maintainability.",
                "Start": 7,
                "End": 221
            }],
            "Final code": "private <T extends Entity>@NotNull EntityMock mockEntity(@NotNull Location location,@NotNull Class<T> clazz,boolean randomizeData){\n  AsyncCatcher.catchOp('entity add');\n  switch (clazz.getSimpleName()) {\n    case 'ArmorStand':\n      return new ArmorStandMock(server,UUID.randomUUID());\n    case 'ExperienceOrb':\n      return new ExperienceOrbMock(server,UUID.randomUUID());\n    case 'Firework':\n      return new FireworkMock(server,UUID.randomUUID());\n    ...\n    case 'LeashHitch':\n      return new LeashHitchMock(server,UUID.randomUUID());\n    default:\n      throw new UnimplementedOperationException();\n  }\n}"
        }],
        "Old_Method": "private <T extends Entity>@NotNull EntityMock mockEntity(@NotNull Location location,@NotNull Class<T> clazz,boolean randomizeData){\n  AsyncCatcher.catchOp(\"entity add\");\n  if (clazz == ArmorStand.class) {\n    return new ArmorStandMock(server,UUID.randomUUID());\n  }\n else   if (clazz == ExperienceOrb.class) {\n    return new ExperienceOrbMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Firework.class) {\n    return new FireworkMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Hanging.class) {\n    if (LeashHitch.class.isAssignableFrom(clazz)) {\n      throw new UnimplementedOperationException();\n    }\n    BlockFace spawnFace=BlockFace.SELF;\n    BlockFace[] faces=(ItemFrame.class.isAssignableFrom(clazz)) ? new BlockFace[]{BlockFace.NORTH,BlockFace.EAST,BlockFace.SOUTH,BlockFace.WEST,BlockFace.UP,BlockFace.DOWN} : new BlockFace[]{BlockFace.NORTH,BlockFace.EAST,BlockFace.SOUTH,BlockFace.WEST};\n    for (    BlockFace face : faces) {\n      Block block=this.getBlockAt(location.add(face.getModX(),face.getModY(),face.getModZ()));\n      if (!block.getType().isSolid() && (block.getType() != Material.REPEATER && block.getType() != Material.COMPARATOR))       continue;\n      boolean taken=false;\n      if (taken)       continue;\n      spawnFace=face;\n      break;\n    }\n    if (spawnFace == BlockFace.SELF) {\n      spawnFace=BlockFace.SOUTH;\n    }\n    spawnFace=spawnFace.getOppositeFace();\n    throw new UnimplementedOperationException();\n  }\n else   if (clazz == Item.class) {\n    throw new IllegalArgumentException(\"Items must be spawned using World#dropItem(...)\");\n  }\n else   if (clazz == FishHook.class) {\n    return new FishHookMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Player.class) {\n    throw new IllegalArgumentException(\"Player Entities cannot be spawned, use ServerMock#addPlayer(...)\");\n  }\n else   if (clazz == Zombie.class) {\n    return new ZombieMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Enderman.class) {\n    return new EndermanMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Horse.class) {\n    return new HorseMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Sheep.class) {\n    return new SheepMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Allay.class) {\n    return new AllayMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Warden.class) {\n    return new WardenMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Donkey.class) {\n    return new DonkeyMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Llama.class) {\n    return new LlamaMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Mule.class) {\n    return new MuleMock(server,UUID.randomUUID());\n  }\n else   if (clazz == SkeletonHorse.class) {\n    return new SkeletonHorseMock(server,UUID.randomUUID());\n  }\n else   if (clazz == ZombieHorse.class) {\n    return new ZombieHorseMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Cow.class) {\n    return new CowMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Chicken.class) {\n    return new ChickenMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Skeleton.class) {\n    return new SkeletonMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Stray.class) {\n    return new StrayMock(server,UUID.randomUUID());\n  }\n else   if (clazz == WitherSkeleton.class) {\n    return new WitherSkeletonMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Spider.class) {\n    return new SpiderMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Blaze.class) {\n    return new BlazeMock(server,UUID.randomUUID());\n  }\n else   if (clazz == CaveSpider.class) {\n    return new CaveSpiderMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Giant.class) {\n    return new GiantMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Axolotl.class) {\n    return new AxolotlMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Bat.class) {\n    return new BatMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Cat.class) {\n    return new CatMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Frog.class) {\n    return new FrogMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Fox.class) {\n    return new FoxMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Ghast.class) {\n    return new GhastMock(server,UUID.randomUUID());\n  }\n else   if (clazz == MushroomCow.class) {\n    return new MushroomCowMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Tadpole.class) {\n    return new TadpoleMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Cod.class) {\n    return new CodMock(server,UUID.randomUUID());\n  }\n else   if (clazz == TropicalFish.class) {\n    return new TropicalFishMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Salmon.class) {\n    return new SalmonMock(server,UUID.randomUUID());\n  }\n else   if (clazz == PufferFish.class) {\n    return new PufferFishMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Bee.class) {\n    return new BeeMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Creeper.class) {\n    return new CreeperMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Wolf.class) {\n    return new WolfMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Goat.class) {\n    return new GoatMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Egg.class) {\n    return new EggMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Pig.class) {\n    return new PigMock(server,UUID.randomUUID());\n  }\n else   if (clazz == ElderGuardian.class) {\n    return new ElderGuardianMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Guardian.class) {\n    return new GuardianMock(server,UUID.randomUUID());\n  }\n else   if (clazz == PolarBear.class) {\n    return new PolarBearMock(server,UUID.randomUUID());\n  }\n else   if (clazz == SmallFireball.class) {\n    return new SmallFireballMock(server,UUID.randomUUID());\n  }\n else   if (clazz == LargeFireball.class) {\n    return new LargeFireballMock(server,UUID.randomUUID());\n  }\n else   if (clazz == DragonFireball.class) {\n    return new DragonFireballMock(server,UUID.randomUUID());\n  }\n else   if (clazz == WitherSkull.class) {\n    return new WitherSkullMock(server,UUID.randomUUID());\n  }\n else   if (clazz == PoweredMinecart.class) {\n    return new PoweredMinecartMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Camel.class) {\n    return new CamelMock(server,UUID.randomUUID());\n  }\n else   if (clazz == CommandMinecart.class) {\n    return new CommandMinecartMock(server,UUID.randomUUID());\n  }\n else   if (clazz == ExplosiveMinecart.class) {\n    return new ExplosiveMinecartMock(server,UUID.randomUUID());\n  }\n else   if (clazz == HopperMinecart.class) {\n    return new HopperMinecartMock(server,UUID.randomUUID());\n  }\n else   if (clazz == SpawnerMinecart.class) {\n    return new SpawnerMinecartMock(server,UUID.randomUUID());\n  }\n else   if (clazz == RideableMinecart.class) {\n    return new RideableMinecartMock(server,UUID.randomUUID());\n  }\n else   if (clazz == StorageMinecart.class) {\n    return new StorageMinecartMock(server,UUID.randomUUID());\n  }\n else   if (clazz == AreaEffectCloud.class) {\n    return new AreaEffectCloudMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Boat.class) {\n    return new BoatMock(server,UUID.randomUUID());\n  }\n else   if (clazz == ChestBoat.class) {\n    return new ChestBoatMock(server,UUID.randomUUID());\n  }\n else   if (clazz == EnderPearl.class) {\n    return new EnderPearlMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Panda.class) {\n    return new PandaMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Rabbit.class) {\n    return new RabbitMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Slime.class) {\n    return new SlimeMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Ocelot.class) {\n    return new OcelotMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Parrot.class) {\n    return new ParrotMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Squid.class) {\n    return new SquidMock(server,UUID.randomUUID());\n  }\n else   if (clazz == GlowSquid.class) {\n    return new GlowSquidMock(server,UUID.randomUUID());\n  }\n else   if (clazz == LlamaSpit.class) {\n    return new LlamaSpitMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Dolphin.class) {\n    return new DolphinMock(server,UUID.randomUUID());\n  }\n else   if (clazz == MagmaCube.class) {\n    return new MagmaCubeMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Endermite.class) {\n    return new EndermiteMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Silverfish.class) {\n    return new SilverfishMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Turtle.class) {\n    return new TurtleMock(server,UUID.randomUUID());\n  }\n else   if (clazz == ThrownExpBottle.class) {\n    return new ThrownExpBottleMock(server,UUID.randomUUID());\n  }\n else   if (clazz == Snowball.class) {\n    return new SnowballMock(server,UUID.randomUUID());\n  }\n else   if (clazz == LeashHitch.class) {\n    return new LeashHitchMock(server,UUID.randomUUID());\n  }\n  throw new UnimplementedOperationException();\n}\n",
        "File_Path": "MockBukkit/src/main/java/be/seeseemelk/mockbukkit/WorldMock.java",
        "Start": 32182,
        "Stop": 41520,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "mockEntity"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Rename variables for clarity",
                    "Change_Diff": "- AtomicBoolean executed=new AtomicBoolean();\n+ AtomicBoolean isExecuted=new AtomicBoolean();\n- AtomicBoolean completed=new AtomicBoolean();\n+ AtomicBoolean isCompleted=new AtomicBoolean();\n- AtomicBoolean notPrimaryThread=new AtomicBoolean();\n+ AtomicBoolean isNotPrimaryThread=new AtomicBoolean();",
                    "Description": "Rename the variables executed, completed, and notPrimaryThread to isExecuted, isCompleted, and isNotPrimaryThread respectively for better clarity and readability.",
                    "Start": 2,
                    "End": 5
                },
                {
                    "Improvement": "Use lambda expression",
                    "Change_Diff": "- new Thread(new Runnable() {\n+ new Thread(() -> {",
                    "Description": "Replace the anonymous inner class and its Runnable implementation with a lambda expression for a more concise and modern syntax.",
                    "Start": 9,
                    "End": 10
                },
                {
                    "Improvement": "Improve variable naming",
                    "Change_Diff": "- Thread thread=new Thread(() -> {\n+ Thread asyncThread=new Thread(() -> {",
                    "Description": "Rename the variable 'thread' to 'asyncThread' for better clarity in relation to its purpose.",
                    "Start": 13,
                    "End": 13
                },
                {
                    "Improvement": "Extract task execution to a separate method",
                    "Change_Diff": "+ private void executeTask(Runnable task) {\n+   try {\n+     scheduler.runTaskLater(null, bukkitTask -> {\n+       if (mainThread != Thread.currentThread()) {\n+         isNotPrimaryThread.set(true);\n+       }\n+       isExecuted.set(true);\n+     }, 1);\n+   }\n+   finally {\n+     isCompleted.set(true);\n+   }\n+ }\n\n @Test\n void registerOneTasksAsynchronously() {\n-   final Thread mainThread=Thread.currentThread();\n+   mainThread = Thread.currentThread();\n    AtomicBoolean isExecuted = new AtomicBoolean();\n    AtomicBoolean isCompleted = new AtomicBoolean();\n    AtomicBoolean isNotPrimaryThread = new AtomicBoolean();\n\n-   Thread asyncThread=new Thread(() -> {\n+   Thread asyncThread=new Thread(() -> {\n      executeTask(() -> {\n        if (mainThread != Thread.currentThread()) {\n          isNotPrimaryThread.set(true);\n        }\n        isExecuted.set(true);\n      });\n    });",
                    "Description": "Extract the task execution logic to a separate method, 'executeTask', to improve code organization and readability.",
                    "Start": 12,
                    "End": 76
                },
                {
                    "Improvement": "Remove redundant imports",
                    "Change_Diff": "- import java.util.concurrent.atomic.AtomicBoolean;\n\n+ import java.util.concurrent.atomic.AtomicBoolean;\n",
                    "Description": "Remove the duplicate import statement to improve code cleanliness.",
                    "Start": 1,
                    "End": 1
                },
                {
                    "Improvement": "Use constants for magic numbers",
                    "Change_Diff": "- scheduler.runTaskLater(null, bukkitTask -> {\n+ scheduler.runTaskLater(null, bukkitTask -> {\n",
                    "Description": "Replace the magic number 1 with a constant variable for better code clarity and maintainability.",
                    "Start": 22,
                    "End": 22
                },
                {
                    "Improvement": "Declare and initialize startTime variable closer to its usage",
                    "Change_Diff": "- long startTime = System.currentTimeMillis();\n... \n+ while (!completetionStatus.get()) {\n+   long startTime = System.currentTimeMillis();",
                    "Description": "Declare and initialize the startTime variable closer to its usage to improve code readability and reduce confusion.",
                    "Start": 27,
                    "End": 27
                }
            ],
            "Final code": "@Test void registerOneTasksAsynchronously() {\n+ final Thread mainThread = Thread.currentThread();\n\n+ AtomicBoolean isExecuted = new AtomicBoolean();\n+ AtomicBoolean isCompleted = new AtomicBoolean();\n+ AtomicBoolean isNotPrimaryThread = new AtomicBoolean();\n\n+ private void executeTask(Runnable task) {\n+   try {\n+     scheduler.runTaskLater(null, bukkitTask -> {\n+       if (mainThread != Thread.currentThread()) {\n+         isNotPrimaryThread.set(true);\n+       }\n+       isExecuted.set(true);\n+     }, DELAY);\n+   }\n+   finally {\n+     isCompleted.set(true);\n+   }\n+ }\n\n+ Thread asyncThread=new Thread(() -> {\n+   executeTask(() -> {\n+     if (mainThread != Thread.currentThread()) {\n+       isNotPrimaryThread.set(true);\n+     }\n+     isExecuted.set(true);\n+   });\n+ });\n+ \n+ asyncThread.start();\n+ long startTime = System.currentTimeMillis();\n+ while (!isCompleted.get()) {\n+   checkTimeout(startTime, asyncThread);\n+   scheduler.performOneTick();\n+   Thread.yield();\n+ }\n+ while (!isExecuted.get()) {\n+   checkTimeout(startTime);\n+   scheduler.performOneTick();\n+ }\n\n+ assertTrue(isExecuted.get());\n+ assertFalse(isNotPrimaryThread.get());\n}"
        }],
        "Old_Method": "@Test void registerOneTasksAsynchronously(){\n  final Thread mainThread=Thread.currentThread();\n  AtomicBoolean executed=new AtomicBoolean();\n  AtomicBoolean completed=new AtomicBoolean();\n  AtomicBoolean notPrimaryThread=new AtomicBoolean();\n  Thread thread=new Thread(() -> {\n    try {\n      scheduler.runTaskLater(null,bukkitTask -> {\n        if (mainThread != Thread.currentThread()) {\n          notPrimaryThread.set(true);\n        }\n        executed.set(true);\n      }\n,1);\n    }\n  finally {\n      completed.set(true);\n    }\n  }\n);\n  thread.start();\n  long startTime=System.currentTimeMillis();\n  while (!completed.get()) {\n    checkTimeout(startTime,thread);\n    scheduler.performOneTick();\n    Thread.yield();\n  }\n  while (!executed.get()) {\n    checkTimeout(startTime);\n    scheduler.performOneTick();\n  }\n  assertTrue(executed.get());\n  assertFalse(notPrimaryThread.get());\n}\n",
        "File_Path": "MockBukkit/src/test/java/be/seeseemelk/mockbukkit/scheduler/BukkitSchedulerMockTest.java",
        "Start": 14506,
        "Stop": 15448,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "registerOneTasksAsynchronously"
    },
    {
        "Method_Improvements": [{
            "Improvements": [
                {
                    "Improvement": "Remove unnecessary annotations",
                    "Change_Diff": "- @SuppressWarnings(\"unchecked\") @Override @Deprecated(since=\"1.13\")",
                    "Description": "The annotations @SuppressWarnings(\"unchecked\") and @Override are unnecessary and can be removed.",
                    "Start": 1,
                    "End": 1
                },
                {
                    "Improvement": "Check for null in a separate condition",
                    "Change_Diff": "- if (rule == null) {\n+ if (rule == null || gameRule == null) {",
                    "Description": "The condition for checking if 'rule' is null can be separated from the condition for checking if 'gameRule' is null.",
                    "Start": 5,
                    "End": 5
                },
                {
                    "Improvement": "Simplify condition with short-circuiting",
                    "Change_Diff": "- if (gameRule.getType().equals(Boolean.class) && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\"))) {\n+ if (gameRule.getType() == Boolean.class && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\"))) {",
                    "Description": "The condition can be simplified by using '==' instead of '.equals()' for comparing types. This takes advantage of short-circuiting.",
                    "Start": 8,
                    "End": 8
                }
            ],
            "Final code": "@Deprecated(since=\"1.13\")\npublic boolean setGameRuleValue(@Nullable String rule, @NotNull String value) {\n  if (rule == null || gameRule == null) {\n    return false;\n  }\n\n  GameRule<?> gameRule = GameRule.getByName(rule);\n  if (gameRule == null) {\n    return false;\n  }\n\n  if (gameRule.getType() == Boolean.class && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\"))) {\n    WorldGameRuleChangeEvent event = new WorldGameRuleChangeEvent(this, null, gameRule, value);\n    if (!event.callEvent()) {\n      return false;\n    }\n    return setGameRule((GameRule<Boolean>) gameRule, value.equalsIgnoreCase(\"true\"));\n  }\n\n  if (gameRule.getType() == Integer.class) {\n    try {\n      int intValue = Integer.parseInt(value);\n      WorldGameRuleChangeEvent event = new WorldGameRuleChangeEvent(this, null, gameRule, value);\n      if (!event.callEvent()) {\n        return false;\n      }\n      return setGameRule((GameRule<Integer>) gameRule, intValue);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n  }\n\n  return false;\n}"
        }],
        "Old_Method": "@SuppressWarnings(\"unchecked\") @Override @Deprecated(since=\"1.13\") public boolean setGameRuleValue(@Nullable String rule,@NotNull String value){\n  if (rule == null) {\n    return false;\n  }\n  GameRule<?> gameRule=GameRule.getByName(rule);\n  if (gameRule == null) {\n    return false;\n  }\n  if (gameRule.getType().equals(Boolean.class) && (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\"))) {\n    WorldGameRuleChangeEvent event=new WorldGameRuleChangeEvent(this,null,gameRule,value);\n    if (!event.callEvent()) {\n      return false;\n    }\n    return setGameRule((GameRule<Boolean>)gameRule,value.equalsIgnoreCase(\"true\"));\n  }\n else   if (gameRule.getType().equals(Integer.class)) {\n    try {\n      int intValue=Integer.parseInt(value);\n      WorldGameRuleChangeEvent event=new WorldGameRuleChangeEvent(this,null,gameRule,value);\n      if (!event.callEvent()) {\n        return false;\n      }\n      return setGameRule((GameRule<Integer>)gameRule,intValue);\n    }\n catch (    NumberFormatException e) {\n      return false;\n    }\n  }\n else {\n    return false;\n  }\n}\n",
        "File_Path": "MockBukkit/src/main/java/be/seeseemelk/mockbukkit/WorldMock.java",
        "Start": 60111,
        "Stop": 61224,
        "Project_Name": "data/projects/MockBukkit",
        "Method_Name": "setGameRuleValue"
    }
]