{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Use Java logger instead of System.out.println",
                "Change_Diff": "- System.out.println(...);\n+ logger.info(...);",
                "Description": "It's a good practice to use a logger instead of System.out.println to write the output. This allows us to set the level of logging we want (INFO, DEBUG, ERROR, etc), and to control where the output goes (console, file, etc).",
                "Start": 4,
                "End": 48
            },
            {
                "Improvement": "Handle InterruptedException properly",
                "Change_Diff": "- catch (final InterruptedException e) {\n+ catch (final InterruptedException e) {\n+ Thread.currentThread().interrupt();\n+ return;",
                "Description": "When a thread is interrupted in Java, it's usually because some other thread wants it to stop what it's doing and do something else. It's a common pattern to catch InterruptedException and then immediately return or break from the loop. This is a better approach than simply swallowing the exception.",
                "Start": 8,
                "End": 11
            },
            {
                "Improvement": "Use Set instead of List for eventsDisplayed",
                "Change_Diff": "- final List<StackEvent> eventsDisplayed=new ArrayList<>();\n+ final Set<StackEvent> eventsDisplayed=new HashSet<>();",
                "Description": "The eventsDisplayed list is used to check if an event has been displayed already. This operation is faster for a Set than for a List. We should change eventsDisplayed to be a Set.",
                "Start": 5,
                "End": 5
            }
        ],
        "Final code": "protected void waitForStack(final Context context,final String stackName,final FinalStatus finalStackStatus){\n  logger.info(\"waitForStack[\" + stackName + \"]: to reach status \"+ finalStackStatus.finalStatus);\n  final Set<StackEvent> eventsDisplayed=new HashSet<>();\n  while (true) {\n    try {\n      Thread.sleep(20000);\n    } catch (final InterruptedException e) {\n      Thread.currentThread().interrupt();\n      return;\n    }\n    final List<StackEvent> events=getStackEvents(stackName);\n    for (final StackEvent event : events) {\n      boolean displayed=eventsDisplayed.contains(event);\n      if (!displayed) {\n        logger.info(\"waitForStack[\" + stackName + \"]: \"+ event.getTimestamp().toString()+ \" \"+ event.getLogicalResourceId()+ \" \"+ event.getResourceStatus()+ \" \"+ event.getResourceStatusReason());\n        eventsDisplayed.add(event);\n      }\n    }\n    try {\n      final DescribeStacksResult res=this.cf.describeStacks(new DescribeStacksRequest().withStackName(stackName));\n      final StackStatus currentStatus=StackStatus.fromValue(res.getStacks().get(0).getStackStatus());\n      if (finalStackStatus.finalStatus == currentStatus) {\n        logger.info(\"waitForStack[\" + stackName + \"]: final status reached.\");\n        return;\n      } else {\n        if (finalStackStatus.intermediateStatus.contains(currentStatus)) {\n          logger.info(\"waitForStack[\" + stackName + \"]: continue to wait (still in intermediate status \"+ currentStatus+ \") ...\");\n        } else {\n          context.reportStackFailure(stackName);\n          throw new RuntimeException(\"waitForStack[\" + stackName + \"]: reached invalid intermediate status \"+ currentStatus+ \".\");\n        }\n      }\n    } catch (final AmazonServiceException e) {\n      if (e.getErrorMessage().equals(\"Stack with id \" + stackName + \" does not exist\")) {\n        if (finalStackStatus.notFoundIsFinalStatus) {\n          logger.info(\"waitForStack[\" + stackName + \"]: final  reached (not found).\");\n          return;\n        } else {\n          if (finalStackStatus.notFoundIsIntermediateStatus) {\n            logger.info(\"waitForStack[\" + stackName + \"]: continue to wait (stack not found) ...\");\n          } else {\n            context.reportStackFailure(stackName);\n            throw new RuntimeException(\"waitForStack[\" + stackName + \"]: stack not found.\");\n          }\n        }\n      } else {\n        throw e;\n      }\n    }\n  }\n}"
    },
    "Old_Method": "protected void waitForStack(final Context context,final String stackName,final FinalStatus finalStackStatus){\n  System.out.println(\"waitForStack[\" + stackName + \"]: to reach status \"+ finalStackStatus.finalStatus);\n  final List<StackEvent> eventsDisplayed=new ArrayList<>();\n  while (true) {\n    try {\n      Thread.sleep(20000);\n    }\n catch (    final InterruptedException e) {\n    }\n    final List<StackEvent> events=getStackEvents(stackName);\n    for (    final StackEvent event : events) {\n      boolean displayed=false;\n      for (      final StackEvent eventDisplayed : eventsDisplayed) {\n        if (event.getEventId().equals(eventDisplayed.getEventId())) {\n          displayed=true;\n        }\n      }\n      if (!displayed) {\n        System.out.println(\"waitForStack[\" + stackName + \"]: \"+ event.getTimestamp().toString()+ \" \"+ event.getLogicalResourceId()+ \" \"+ event.getResourceStatus()+ \" \"+ event.getResourceStatusReason());\n        eventsDisplayed.add(event);\n      }\n    }\n    try {\n      final DescribeStacksResult res=this.cf.describeStacks(new DescribeStacksRequest().withStackName(stackName));\n      final StackStatus currentStatus=StackStatus.fromValue(res.getStacks().get(0).getStackStatus());\n      if (finalStackStatus.finalStatus == currentStatus) {\n        System.out.println(\"waitForStack[\" + stackName + \"]: final status reached.\");\n        return;\n      }\n else {\n        if (finalStackStatus.intermediateStatus.contains(currentStatus)) {\n          System.out.println(\"waitForStack[\" + stackName + \"]: continue to wait (still in intermediate status \"+ currentStatus+ \") ...\");\n        }\n else {\n          context.reportStackFailure(stackName);\n          throw new RuntimeException(\"waitForStack[\" + stackName + \"]: reached invalid intermediate status \"+ currentStatus+ \".\");\n        }\n      }\n    }\n catch (    final AmazonServiceException e) {\n      if (e.getErrorMessage().equals(\"Stack with id \" + stackName + \" does not exist\")) {\n        if (finalStackStatus.notFoundIsFinalStatus) {\n          System.out.println(\"waitForStack[\" + stackName + \"]: final  reached (not found).\");\n          return;\n        }\n else {\n          if (finalStackStatus.notFoundIsIntermediateStatus) {\n            System.out.println(\"waitForStack[\" + stackName + \"]: continue to wait (stack not found) ...\");\n          }\n else {\n            context.reportStackFailure(stackName);\n            throw new RuntimeException(\"waitForStack[\" + stackName + \"]: stack not found.\");\n          }\n        }\n      }\n else {\n        throw e;\n      }\n    }\n  }\n}\n",
    "File_Path": "aws-s3-virusscan/test/src/test/java/de/widdix/awss3virusscan/ACloudFormationTest.java",
    "Start": 6172,
    "Stop": 9325,
    "Project_Name": "data/projects/aws-s3-virusscan",
    "Method_Name": "waitForStack"
}