{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Extract repeated code into separate method",
                "Change_Diff": "- System.out.println(\"waitForStack[\" + stackName + \"]: \"+ event.getTimestamp().toString()+ \" \"+ event.getLogicalResourceId()+ \" \"+ event.getResourceStatus()+ \" \"+ event.getResourceStatusReason());\n+ displayEventDetails(stackName, event);",
                "Description": "The code for displaying the stack event name, timestamp, resource id, status, and reason is repeated. This can be extracted to a separate method for reusability and to improve code readability.",
                "Start": 13,
                "End": 22
            },
            {
                "Improvement": "Handle InterruptedException properly",
                "Change_Diff": "- catch (final InterruptedException e) {\n}\n+ catch (final InterruptedException e) {\n Thread.currentThread().interrupt();\n throw new RuntimeException(\"Thread was interrupted\", e);\n}",
                "Description": "The InterruptedException is currently being swallowed which is not a good practice. We should either restore the interrupt or rethrow the exception.",
                "Start": 7,
                "End": 9
            },
            {
                "Improvement": "Use Java 8 Stream API for checking if event is already displayed",
                "Change_Diff": "- for (final StackEvent eventDisplayed : eventsDisplayed) {\n if (event.getEventId().equals(eventDisplayed.getEventId())) {\n displayed=true;\n }\n}\n+ displayed = eventsDisplayed.stream().anyMatch(e -> e.getEventId().equals(event.getEventId()));",
                "Description": "Instead of using the nested for loop to check if an event is already displayed, we can use Java 8 Stream API which is more readable and efficient.",
                "Start": 12,
                "End": 18
            }
        ],
        "Final code": "protected void waitForStack(final Context context,final String stackName,final FinalStatus finalStackStatus){\n System.out.println(\"waitForStack[\" + stackName + \"]: to reach status \"+ finalStackStatus.finalStatus);\n final List<StackEvent> eventsDisplayed=new ArrayList<>();\n while (true) {\n try {\n Thread.sleep(20000);\n}\n catch (final InterruptedException e) {\n Thread.currentThread().interrupt();\n throw new RuntimeException(\"Thread was interrupted\", e);\n}\n final List<StackEvent> events=getStackEvents(stackName);\n for (final StackEvent event : events) {\n boolean displayed=eventsDisplayed.stream().anyMatch(e -> e.getEventId().equals(event.getEventId()));\n if (!displayed) {\n displayEventDetails(stackName, event);\n eventsDisplayed.add(event);\n}\n}\n try {\n final DescribeStacksResult res=this.cf.describeStacks(new DescribeStacksRequest().withStackName(stackName));\n final StackStatus currentStatus=StackStatus.fromValue(res.getStacks().get(0).getStackStatus());\n if (finalStackStatus.finalStatus == currentStatus) {\n System.out.println(\"waitForStack[\" + stackName + \"]: final status reached.\");\n return;\n}\n else {\n if (finalStackStatus.intermediateStatus.contains(currentStatus)) {\n System.out.println(\"waitForStack[\" + stackName + \"]: continue to wait (still in intermediate status \"+ currentStatus+ \") ...\");\n}\n else {\n context.reportStackFailure(stackName);\n throw new RuntimeException(\"waitForStack[\" + stackName + \"]: reached invalid intermediate status \"+ currentStatus+ \".\");\n}\n}\n}\n catch (final AmazonServiceException e) {\n if (e.getErrorMessage().equals(\"Stack with id \" + stackName + \" does not exist\")) {\n if (finalStackStatus.notFoundIsFinalStatus) {\n System.out.println(\"waitForStack[\" + stackName + \"]: final reached (not found).\");\n return;\n}\n else {\n if (finalStackStatus.notFoundIsIntermediateStatus) {\n System.out.println(\"waitForStack[\" + stackName + \"]: continue to wait (stack not found) ...\");\n}\n else {\n context.reportStackFailure(stackName);\n throw new RuntimeException(\"waitForStack[\" + stackName + \"]: stack not found.\");\n}\n}\n}\n else {\n throw e;\n}\n}\n}\n}\n\nprivate void displayEventDetails(String stackName, StackEvent event) {\n System.out.println(\"waitForStack[\" + stackName + \"]: \"+ event.getTimestamp().toString()+ \" \"+ event.getLogicalResourceId()+ \" \"+ event.getResourceStatus()+ \" \"+ event.getResourceStatusReason());\n}"
    },
    "Old_Method": "protected void waitForStack(final Context context,final String stackName,final FinalStatus finalStackStatus){\n  System.out.println(\"waitForStack[\" + stackName + \"]: to reach status \"+ finalStackStatus.finalStatus);\n  final List<StackEvent> eventsDisplayed=new ArrayList<>();\n  while (true) {\n    try {\n      Thread.sleep(20000);\n    }\n catch (    final InterruptedException e) {\n    }\n    final List<StackEvent> events=getStackEvents(stackName);\n    for (    final StackEvent event : events) {\n      boolean displayed=false;\n      for (      final StackEvent eventDisplayed : eventsDisplayed) {\n        if (event.getEventId().equals(eventDisplayed.getEventId())) {\n          displayed=true;\n        }\n      }\n      if (!displayed) {\n        System.out.println(\"waitForStack[\" + stackName + \"]: \"+ event.getTimestamp().toString()+ \" \"+ event.getLogicalResourceId()+ \" \"+ event.getResourceStatus()+ \" \"+ event.getResourceStatusReason());\n        eventsDisplayed.add(event);\n      }\n    }\n    try {\n      final DescribeStacksResult res=this.cf.describeStacks(new DescribeStacksRequest().withStackName(stackName));\n      final StackStatus currentStatus=StackStatus.fromValue(res.getStacks().get(0).getStackStatus());\n      if (finalStackStatus.finalStatus == currentStatus) {\n        System.out.println(\"waitForStack[\" + stackName + \"]: final status reached.\");\n        return;\n      }\n else {\n        if (finalStackStatus.intermediateStatus.contains(currentStatus)) {\n          System.out.println(\"waitForStack[\" + stackName + \"]: continue to wait (still in intermediate status \"+ currentStatus+ \") ...\");\n        }\n else {\n          context.reportStackFailure(stackName);\n          throw new RuntimeException(\"waitForStack[\" + stackName + \"]: reached invalid intermediate status \"+ currentStatus+ \".\");\n        }\n      }\n    }\n catch (    final AmazonServiceException e) {\n      if (e.getErrorMessage().equals(\"Stack with id \" + stackName + \" does not exist\")) {\n        if (finalStackStatus.notFoundIsFinalStatus) {\n          System.out.println(\"waitForStack[\" + stackName + \"]: final  reached (not found).\");\n          return;\n        }\n else {\n          if (finalStackStatus.notFoundIsIntermediateStatus) {\n            System.out.println(\"waitForStack[\" + stackName + \"]: continue to wait (stack not found) ...\");\n          }\n else {\n            context.reportStackFailure(stackName);\n            throw new RuntimeException(\"waitForStack[\" + stackName + \"]: stack not found.\");\n          }\n        }\n      }\n else {\n        throw e;\n      }\n    }\n  }\n}\n",
    "File_Path": "aws-s3-virusscan/test/src/test/java/de/widdix/awss3virusscan/ACloudFormationTest.java",
    "Start": 6172,
    "Stop": 9325,
    "Project_Name": "data/projects/aws-s3-virusscan",
    "Method_Name": "waitForStack"
}