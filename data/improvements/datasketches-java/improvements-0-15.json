{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Remove redundant else clause",
                "Change_Diff": "- else {\n+ ",
                "Description": "The else clause after a return statement can be removed to simplify the control flow.",
                "Start": 72,
                "End": 73
            },
            {
                "Improvement": "Use try-with-resources for StringBuilder",
                "Change_Diff": "- final StringBuilder sb=new StringBuilder();\n+ try (final StringBuilder sb=new StringBuilder()) {",
                "Description": "The StringBuilder should be used with try-with-resources to ensure that resources are properly closed and to improve readability.",
                "Start": 5,
                "End": 5
            },
            {
                "Improvement": "Use Strings instead of StringBuilders for constant strings",
                "Change_Diff": "- sb.append(Util.LS).append(\"### KLL SKETCH MEMORY SUMMARY:\").append(LS);\n+ String summaryHeader = Util.LS + \"### KLL SKETCH MEMORY SUMMARY:\" + LS;",
                "Description": "For constant strings that aren't being modified, using Strings is more efficient than using StringBuilders.",
                "Start": 12,
                "End": 12
            }
        ],
        "Final code": "/** \n * Returns a human readable string summary of the internal state of the given Memory. Used primarily in testing.\n * @param mem the given Memory\n * @param sketchType the sketch type: FLOATS_SKETCH, DOUBLES_SKETCH, or ITEMS_SKETCH.\n * @param includeData if true, includes detail of retained data.\n * @param serDe must be supplied for KllItemsSketch, otherwise can be null.\n * @return the summary string.\n */\nstatic <T>String toString(final Memory mem,final SketchType sketchType,final boolean includeData,final ArrayOfItemsSerDe<T> serDe){\n  if (sketchType == ITEMS_SKETCH) {\n    Objects.requireNonNull(serDe,\"SerDe parameter must not be null for ITEMS_SKETCH.\");\n  }\n  final KllMemoryValidate memVal=new KllMemoryValidate(mem,sketchType,serDe);\n  final SketchStructure myStructure=memVal.sketchStructure;\n  final int flags=memVal.flags & 0XFF;\n  final String flagsStr=(flags) + \", 0x\" + (Integer.toHexString(flags))+ \", \"+ zeroPad(Integer.toBinaryString(flags),8);\n  final int preInts=memVal.preInts;\n  final boolean emptyFlag=memVal.emptyFlag;\n  final int sketchBytes=memVal.sketchBytes;\n  final int typeBytes=sketchType == DOUBLES_SKETCH ? Double.BYTES : Float.BYTES;\n  final int familyID=getMemoryFamilyID(mem);\n  final String famName=idToFamily(familyID).toString();\n  try (final StringBuilder sb=new StringBuilder()) {\n  String summaryHeader = Util.LS + \"### KLL SKETCH MEMORY SUMMARY:\" + LS;\n  sb.append(summaryHeader);\n  sb.append(\"Sketch Type                          : \").append(sketchType.toString()).append(LS);\n  sb.append(\"SketchStructure                      : \").append(myStructure.toString()).append(LS);\n  sb.append(\"Byte   0       : Preamble Ints       : \").append(preInts).append(LS);  \n  //... rest of the code\n  return sb.toString();\n}"
    },
    "Old_Method": "/** \n * Returns a human readable string summary of the internal state of the given Memory. Used primarily in testing.\n * @param mem the given Memory\n * @param sketchType the sketch type: FLOATS_SKETCH, DOUBLES_SKETCH, or ITEMS_SKETCH.\n * @param includeData if true, includes detail of retained data.\n * @param serDe must be supplied for KllItemsSketch, otherwise can be null.\n * @return the summary string.\n */\nstatic <T>String toString(final Memory mem,final SketchType sketchType,final boolean includeData,final ArrayOfItemsSerDe<T> serDe){\n  if (sketchType == ITEMS_SKETCH) {\n    Objects.requireNonNull(serDe,\"SerDe parameter must not be null for ITEMS_SKETCH.\");\n  }\n  final KllMemoryValidate memVal=new KllMemoryValidate(mem,sketchType,serDe);\n  final SketchStructure myStructure=memVal.sketchStructure;\n  final int flags=memVal.flags & 0XFF;\n  final String flagsStr=(flags) + \", 0x\" + (Integer.toHexString(flags))+ \", \"+ zeroPad(Integer.toBinaryString(flags),8);\n  final int preInts=memVal.preInts;\n  final boolean emptyFlag=memVal.emptyFlag;\n  final int sketchBytes=memVal.sketchBytes;\n  final int typeBytes=sketchType == DOUBLES_SKETCH ? Double.BYTES : Float.BYTES;\n  final int familyID=getMemoryFamilyID(mem);\n  final String famName=idToFamily(familyID).toString();\n  final StringBuilder sb=new StringBuilder();\n  sb.append(Util.LS).append(\"### KLL SKETCH MEMORY SUMMARY:\").append(LS);\n  sb.append(\"Sketch Type                          : \").append(sketchType.toString()).append(LS);\n  sb.append(\"SketchStructure                      : \").append(myStructure.toString()).append(LS);\n  sb.append(\"Byte   0       : Preamble Ints       : \").append(preInts).append(LS);\n  sb.append(\"Byte   1       : SerVer              : \").append(memVal.serVer).append(LS);\n  sb.append(\"Byte   2       : FamilyID            : \").append(memVal.familyID).append(LS);\n  sb.append(\"               : FamilyName          : \").append(famName).append(LS);\n  sb.append(\"Byte   3       : Flags Field         : \").append(flagsStr).append(LS);\n  sb.append(\"            Bit: Flag Name           : \").append(LS);\n  sb.append(\"              0: EMPTY               : \").append(emptyFlag).append(LS);\n  sb.append(\"              1: LEVEL_ZERO_SORTED   : \").append(memVal.level0SortedFlag).append(LS);\n  sb.append(\"Bytes  4-5     : K                   : \").append(memVal.k).append(LS);\n  sb.append(\"Byte   6       : Min Level Cap, M    : \").append(memVal.m).append(LS);\n  sb.append(\"Byte   7       : (Reserved)          : \").append(LS);\n  final long n=memVal.n;\n  final int minK=memVal.minK;\n  final int numLevels=memVal.numLevels;\n  final int[] levelsArr=memVal.levelsArr;\n  final int retainedItems=levelsArr[numLevels] - levelsArr[0];\n  if (myStructure == COMPACT_FULL || myStructure == UPDATABLE) {\n    sb.append(\"Bytes  8-15    : N                   : \").append(n).append(LS);\n    sb.append(\"Bytes 16-17    : MinK                : \").append(minK).append(LS);\n    sb.append(\"Byte  18       : NumLevels           : \").append(numLevels).append(LS);\n  }\n else {\n    sb.append(\"Assumed        : N                   : \").append(n).append(LS);\n    sb.append(\"Assumed        : MinK                : \").append(minK).append(LS);\n    sb.append(\"Assumed        : NumLevels           : \").append(numLevels).append(LS);\n  }\n  sb.append(\"PreambleBytes                        : \").append(preInts * Integer.BYTES).append(LS);\n  sb.append(\"Sketch Bytes                         : \").append(sketchBytes).append(LS);\n  sb.append(\"Memory Capacity Bytes                : \").append(mem.getCapacity()).append(LS);\n  sb.append(\"### END KLL Sketch Memory Summary\").append(LS);\n  if (includeData) {\n    sb.append(LS);\n    sb.append(\"### START KLL DATA:\").append(LS);\n    int offsetBytes=0;\n    if (myStructure == UPDATABLE) {\n      sb.append(\"LEVELS ARR:\").append(LS);\n      offsetBytes=DATA_START_ADR;\n      for (int i=0; i < numLevels + 1; i++) {\n        sb.append(i + \", \" + mem.getInt(offsetBytes)).append(LS);\n        offsetBytes+=Integer.BYTES;\n      }\n      sb.append(\"MIN/MAX:\").append(LS);\n      if (sketchType == DOUBLES_SKETCH) {\n        sb.append(mem.getDouble(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n        sb.append(mem.getDouble(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        sb.append(mem.getFloat(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n        sb.append(mem.getFloat(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n      }\n else {\n        sb.append(\"<<<Updatable Structure is not suppported by ItemsSketch>>>\").append(LS);\n      }\n      sb.append(\"ALL DATA (including free space)\").append(LS);\n      final int itemsSpace=(sketchBytes - offsetBytes) / typeBytes;\n      if (sketchType == DOUBLES_SKETCH) {\n        for (int i=0; i < itemsSpace; i++) {\n          sb.append(i + \", \" + mem.getDouble(offsetBytes)).append(LS);\n          offsetBytes+=typeBytes;\n        }\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        for (int i=0; i < itemsSpace; i++) {\n          sb.append(mem.getFloat(offsetBytes)).append(LS);\n          offsetBytes+=typeBytes;\n        }\n      }\n else {\n        sb.append(\"<<<Updatable Structure is not suppported by ItemsSketch>>>\").append(LS);\n      }\n    }\n else     if (myStructure == COMPACT_FULL) {\n      sb.append(\"LEVELS ARR:\").append(LS);\n      offsetBytes=DATA_START_ADR;\n      int j;\n      for (j=0; j < numLevels; j++) {\n        sb.append(j + \", \" + mem.getInt(offsetBytes)).append(LS);\n        offsetBytes+=Integer.BYTES;\n      }\n      sb.append(j + \", \" + levelsArr[numLevels]);\n      sb.append(\" (Top level of Levels Array is absent in Memory)\").append(LS);\n      sb.append(\"MIN/MAX:\").append(LS);\n      if (sketchType == DOUBLES_SKETCH) {\n        sb.append(mem.getDouble(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n        sb.append(mem.getDouble(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        sb.append(mem.getFloat(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n        sb.append(mem.getFloat(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n      }\n else {\n        sb.append(serDe.deserializeFromMemory(mem,offsetBytes,1)[0]).append(LS);\n        offsetBytes+=serDe.sizeOf(mem,offsetBytes,1);\n        sb.append(serDe.deserializeFromMemory(mem,offsetBytes,1)[0]).append(LS);\n        offsetBytes+=serDe.sizeOf(mem,offsetBytes,1);\n      }\n      sb.append(\"RETAINED DATA\").append(LS);\n      final int itemSpace=(sketchBytes - offsetBytes) / typeBytes;\n      if (sketchType == DOUBLES_SKETCH) {\n        for (int i=0; i < itemSpace; i++) {\n          sb.append(i + \", \" + mem.getDouble(offsetBytes)).append(LS);\n          offsetBytes+=typeBytes;\n        }\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        for (int i=0; i < itemSpace; i++) {\n          sb.append(i + \", \" + mem.getFloat(offsetBytes)).append(LS);\n          offsetBytes+=typeBytes;\n        }\n      }\n else {\n        final T[] itemsArr=serDe.deserializeFromMemory(mem,offsetBytes,retainedItems);\n        for (int i=0; i < itemsArr.length; i++) {\n          sb.append(i + \", \" + serDe.toString(itemsArr[i])).append(LS);\n        }\n        offsetBytes+=serDe.sizeOf(mem,offsetBytes,retainedItems);\n      }\n    }\n else     if (myStructure == COMPACT_SINGLE) {\n      sb.append(\"SINGLE ITEM DATUM: \");\n      if (sketchType == DOUBLES_SKETCH) {\n        sb.append(mem.getDouble(DATA_START_ADR_SINGLE_ITEM)).append(LS);\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        sb.append(mem.getFloat(DATA_START_ADR_SINGLE_ITEM)).append(LS);\n      }\n else {\n        sb.append(serDe.deserializeFromMemory(mem,DATA_START_ADR_SINGLE_ITEM,1)[0]).append(LS);\n      }\n    }\n else {\n      sb.append(\"EMPTY, NO DATA\").append(LS);\n    }\n    sb.append(\"### END KLL DATA:\").append(LS);\n  }\n  return sb.toString();\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/kll/KllPreambleUtil.java",
    "Start": 9526,
    "Stop": 18095,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "toString"
}