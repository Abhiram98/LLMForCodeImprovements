{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Use StringBuilder's chaining feature",
                "Change_Diff": "- sb.append(\"### SKETCH PREAMBLE SUMMARY:\").append(LS);\n+ sb.append(\"### SKETCH PREAMBLE SUMMARY:\").append(LS)\n.append(\"Native Byte Order             : \").append(nativeOrder).append(LS)\n.append(\"Byte  0: Preamble Longs       : \").append(preLongs).append(LS);",
                "Description": "StringBuilder's methods return the StringBuilder instance itself. Therefore, you can chain multiple method calls together which leads to more readable and efficient code.",
                "Start": 33,
                "End": 112
            },
            {
                "Improvement": "Eliminate unnecessary if-else checks",
                "Change_Diff": "- if (preLongs == 2) {\n-    curCount=extractCurCount(mem);\n-    p=extractP(mem);\n-  }\n- else   if (preLongs == 3) {\n-    curCount=extractCurCount(mem);\n-    p=extractP(mem);\n-    thetaLong=extractThetaLong(mem);\n-    thetaULong=thetaLong;\n-  }\n- else   if (preLongs == 4) {\n-    curCount=extractCurCount(mem);\n-    p=extractP(mem);\n-    thetaLong=extractThetaLong(mem);\n-    thetaULong=extractUnionThetaLong(mem);\n-  }\n+ if (preLongs >= 2) {\n+    curCount=extractCurCount(mem);\n+    p=extractP(mem);\n+ }\n+ if (preLongs >= 3) {\n+    thetaLong=extractThetaLong(mem);\n+    thetaULong=thetaLong;\n+ }\n+ if (preLongs >= 4) {\n+    thetaULong=extractUnionThetaLong(mem);\n+ }",
                "Description": "The checks for preLongs == 2, preLongs == 3 and preLongs >= 4 are redundant. The code can be simplified by removing the unnecessary checks.",
                "Start": 43,
                "End": 66
            }
        ],
        "Final code": "static String preambleToString(final Memory mem){\n  final int preLongs=getAndCheckPreLongs(mem);\n  ...\n  if (preLongs >= 2) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n  }\n  if (preLongs >= 3) {\n    thetaLong=extractThetaLong(mem);\n    thetaULong=thetaLong;\n  }\n  if (preLongs >= 4) {\n    thetaULong=extractUnionThetaLong(mem);\n  }\n  ...\n  sb.append(\"### SKETCH PREAMBLE SUMMARY:\").append(LS)\n    .append(\"Native Byte Order             : \").append(nativeOrder).append(LS)\n    .append(\"Byte  0: Preamble Longs       : \").append(preLongs).append(LS);\n  ...\n  return sb.toString();\n}"
    },
    "Old_Method": "/** \n * Returns a human readable string summary of the preamble state of the given Memory. Note: other than making sure that the given Memory size is large enough for just the preamble, this does not do much value checking of the contents of the preamble as this is primarily a tool for debugging the preamble visually.\n * @param mem the given Memory.\n * @return the summary preamble string.\n */\nstatic String preambleToString(final Memory mem){\n  final int preLongs=getAndCheckPreLongs(mem);\n  final int rfId=extractLgResizeFactor(mem);\n  final ResizeFactor rf=ResizeFactor.getRF(rfId);\n  final int serVer=extractSerVer(mem);\n  final int familyId=extractFamilyID(mem);\n  final Family family=Family.idToFamily(familyId);\n  final int lgNomLongs=extractLgNomLongs(mem);\n  final int lgArrLongs=extractLgArrLongs(mem);\n  final int flags=extractFlags(mem);\n  final String flagsStr=(flags) + \", 0x\" + (Integer.toHexString(flags))+ \", \"+ zeroPad(Integer.toBinaryString(flags),8);\n  final String nativeOrder=ByteOrder.nativeOrder().toString();\n  final boolean bigEndian=(flags & BIG_ENDIAN_FLAG_MASK) > 0;\n  final boolean readOnly=(flags & READ_ONLY_FLAG_MASK) > 0;\n  final boolean empty=(flags & EMPTY_FLAG_MASK) > 0;\n  final boolean compact=(flags & COMPACT_FLAG_MASK) > 0;\n  final boolean ordered=(flags & ORDERED_FLAG_MASK) > 0;\n  final boolean singleItem=(flags & SINGLEITEM_FLAG_MASK) > 0;\n  final int seedHash=extractSeedHash(mem);\n  int curCount=singleItem ? 1 : 0;\n  float p=(float)1.0;\n  long thetaLong=Long.MAX_VALUE;\n  long thetaULong=thetaLong;\n  if (preLongs == 2) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n  }\n else   if (preLongs == 3) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n    thetaLong=extractThetaLong(mem);\n    thetaULong=thetaLong;\n  }\n else   if (preLongs == 4) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n    thetaLong=extractThetaLong(mem);\n    thetaULong=extractUnionThetaLong(mem);\n  }\n  final double thetaDbl=thetaLong / Util.LONG_MAX_VALUE_AS_DOUBLE;\n  final String thetaHex=zeroPad(Long.toHexString(thetaLong),16);\n  final double thetaUDbl=thetaULong / Util.LONG_MAX_VALUE_AS_DOUBLE;\n  final String thetaUHex=zeroPad(Long.toHexString(thetaULong),16);\n  final StringBuilder sb=new StringBuilder();\n  sb.append(LS);\n  sb.append(\"### SKETCH PREAMBLE SUMMARY:\").append(LS);\n  sb.append(\"Native Byte Order             : \").append(nativeOrder).append(LS);\n  sb.append(\"Byte  0: Preamble Longs       : \").append(preLongs).append(LS);\n  sb.append(\"Byte  0: ResizeFactor         : \").append(rfId + \", \" + rf.toString()).append(LS);\n  sb.append(\"Byte  1: Serialization Version: \").append(serVer).append(LS);\n  sb.append(\"Byte  2: Family               : \").append(familyId + \", \" + family.toString()).append(LS);\n  sb.append(\"Byte  3: LgNomLongs           : \").append(lgNomLongs).append(LS);\n  sb.append(\"Byte  4: LgArrLongs           : \").append(lgArrLongs).append(LS);\n  sb.append(\"Byte  5: Flags Field          : \").append(flagsStr).append(LS);\n  sb.append(\"  Bit Flag Name               : State:\").append(LS);\n  sb.append(\"    0 BIG_ENDIAN_STORAGE      : \").append(bigEndian).append(LS);\n  sb.append(\"    1 READ_ONLY               : \").append(readOnly).append(LS);\n  sb.append(\"    2 EMPTY                   : \").append(empty).append(LS);\n  sb.append(\"    3 COMPACT                 : \").append(compact).append(LS);\n  sb.append(\"    4 ORDERED                 : \").append(ordered).append(LS);\n  sb.append(\"    5 SINGLE_ITEM             : \").append(singleItem).append(LS);\n  sb.append(\"Bytes 6-7  : Seed Hash Hex    : \").append(Integer.toHexString(seedHash)).append(LS);\n  if (preLongs == 1) {\n    sb.append(\" --ABSENT FIELDS, ASSUMED:\").append(LS);\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else   if (preLongs == 2) {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\" --ABSENT, ASSUMED:\").append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else   if (preLongs == 3) {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n    sb.append(\"Bytes 25-31: ThetaU (double)  : \").append(thetaUDbl).append(LS);\n    sb.append(\"             ThetaU (long)    : \").append(thetaULong).append(LS);\n    sb.append(\"             ThetaU (long,hex): \").append(thetaUHex).append(LS);\n  }\n  sb.append(\"Preamble Bytes                : \").append(preLongs * 8).append(LS);\n  sb.append(\"Data Bytes                    : \").append(curCount * 8).append(LS);\n  sb.append(\"TOTAL Sketch Bytes            : \").append((preLongs + curCount) * 8).append(LS);\n  sb.append(\"TOTAL Capacity Bytes          : \").append(mem.getCapacity()).append(LS);\n  sb.append(\"### END SKETCH PREAMBLE SUMMARY\").append(LS);\n  return sb.toString();\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/theta/PreambleUtil.java",
    "Start": 10484,
    "Stop": 17176,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "preambleToString"
}