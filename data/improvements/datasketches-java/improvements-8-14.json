{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Use meaningful variable names",
                "Change_Diff": "- final ResizeFactor rf=ResizeFactor.getRF(extractResizeFactor(srcMem));\n+ final ResizeFactor resizeFactor=ResizeFactor.getRF(extractResizeFactor(srcMem));\n- final int k=extractK(srcMem);\n+ final int numberOfItems=extractK(srcMem);\n- final long n=extractN(srcMem);\n+ final long totalItems=extractN(srcMem);\n- final int hCount=extractHRegionItemCount(srcMem);\n+ final int regionHItemCount=extractHRegionItemCount(srcMem);\n- final int rCount=extractRRegionItemCount(srcMem);\n+ final int regionRItemCount=extractRRegionItemCount(srcMem);\n- final double[] wts=new double[allocatedItems];\n+ final double[] weights=new double[allocatedItems];",
                "Description": "Variable names should be meaningful and explain what they are used for. Instead of using 'rf', better to use 'resizeFactor'. Instead of using 'k', better to use 'numberOfItems'. Instead of using 'n', use 'totalItems'. Instead of using 'hCount', use 'regionHItemCount'. Instead of using 'rCount', use 'regionRItemCount'. Instead of using 'wts', use 'weights'.",
                "Start": 6,
                "End": 68
            },
            {
                "Improvement": "Avoid using magic numbers",
                "Change_Diff": "- if (k < 1) {\n+ if (numberOfItems < MINIMUM_VALID_ITEM_COUNT) {\n- final int allocatedItems=k + 1;\n+ final int allocatedItems=numberOfItems + MINIMUM_VALID_ITEM_COUNT;\n- if (allocatedItems == k) {\n+ if (allocatedItems == numberOfItems) {\n- for (int i=0; i < hCount; ++i) {\n+ for (int i=0; i < regionHItemCount; ++i) {",
                "Description": "Magic numbers can decrease the readability of the code and make it more error-prone. It's a good practice to declare them as constants to improve readability. For example, instead of using '1' directly in the code, better to use a constant with a meaningful name like 'MINIMUM_VALID_ITEM_COUNT'.",
                "Start": 30,
                "End": 95
            },
            {
                "Improvement": "Extract repeated logic into methods",
                "Change_Diff": "- if (n < 0) {\n-    throw new SketchesArgumentException(\"Possible Corruption: n cannot be negative: \" + n);\n-  }\n- if (hCount < 0) {\n-    throw new SketchesArgumentException(\"Possible Corruption: H region count cannot be \" + \"negative: \" + hCount);\n-  }\n- if (rCount < 0) {\n-    throw new SketchesArgumentException(\"Possible Corruption: R region count cannot be \" + \"negative: \" + rCount);\n-  }\n+ checkForNegativeValue(totalItems, \"n\");\n+ checkForNegativeValue(regionHItemCount, \"H region count\");\n+ checkForNegativeValue(regionRItemCount, \"R region count\");",
                "Description": "The logic for checking if a value is negative and throwing an exception is repeated several times. This logic can be extracted into a separate method to avoid repetition and improve readability.",
                "Start": 38,
                "End": 55
            }
        ],
        "Final code": "public static <T>VarOptItemsSketch<T> heapify(final Memory srcMem,final ArrayOfItemsSerDe<T> serDe){\n  final int numPreLongs=getAndCheckPreLongs(srcMem);\n  final ResizeFactor resizeFactor=ResizeFactor.getRF(extractResizeFactor(srcMem));\n  final int serVer=extractSerVer(srcMem);\n  final int familyId=extractFamilyID(srcMem);\n  final int flags=extractFlags(srcMem);\n  final boolean isEmpty=(flags & EMPTY_FLAG_MASK) != 0;\n  final boolean isGadget=(flags & GADGET_FLAG_MASK) != 0;\n  if (isEmpty) {\n    if (numPreLongs != VO_PRELONGS_EMPTY) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_EMPTY + \" for an empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n else {\n    if ((numPreLongs != VO_PRELONGS_WARMUP) && (numPreLongs != VO_PRELONGS_FULL)) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_WARMUP + \" or \"+ VO_PRELONGS_FULL+ \" for a non-empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n  if (serVer != SER_VER) {\n    throw new SketchesArgumentException(\"Possible Corruption: Ser Ver must be \" + SER_VER + \": \"+ serVer);\n  }\n  final int reqFamilyId=Family.VAROPT.getID();\n  if (familyId != reqFamilyId) {\n    throw new SketchesArgumentException(\"Possible Corruption: FamilyID must be \" + reqFamilyId + \": \"+ familyId);\n  }\n  final int numberOfItems=extractK(srcMem);\n  checkForNegativeValue(numberOfItems, \"numberOfItems\");\n  if (isEmpty) {\n    assert numPreLongs == Family.VAROPT.getMinPreLongs();\n    return new VarOptItemsSketch<>(numberOfItems,resizeFactor);\n  }\n  final long totalItems=extractN(srcMem);\n  checkForNegativeValue(totalItems, \"totalItems\");\n  final int regionHItemCount=extractHRegionItemCount(srcMem);\n  checkForNegativeValue(regionHItemCount, \"regionHItemCount\");\n  final int regionRItemCount=extractRRegionItemCount(srcMem);\n  checkForNegativeValue(regionRItemCount, \"regionRItemCount\");\n  double totalRWeight=0.0;\n  if (numPreLongs == Family.VAROPT.getMaxPreLongs()) {\n    if (regionRItemCount > 0) {\n      totalRWeight=extractTotalRWeight(srcMem);\n    }\n else {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + Family.VAROPT.getMaxPreLongs() + \" preLongs but no items in R region\");\n    }\n  }\n  final int preLongBytes=numPreLongs << 3;\n  final int totalItemsInRegions=regionHItemCount + regionRItemCount;\n  int allocatedItems=numberOfItems + MINIMUM_VALID_ITEM_COUNT;\n  if (regionRItemCount == 0) {\n    final int ceilingLgK=Util.exactLog2OfInt(Util.ceilingPowerOf2(numberOfItems),\"heapify\");\n    final int minLgSize=Util.exactLog2OfInt(Util.ceilingPowerOf2(regionHItemCount),\"heapify\");\n    final int initialLgSize=SamplingUtil.startingSubMultiple(ceilingLgK,resizeFactor.lg(),Math.max(minLgSize,MIN_LG_ARR_ITEMS));\n    allocatedItems=SamplingUtil.getAdjustedSize(numberOfItems,1 << initialLgSize);\n    if (allocatedItems == numberOfItems) {\n      ++allocatedItems;\n    }\n  }\n  final long weightOffsetBytes=TOTAL_WEIGHT_R_DOUBLE + (regionRItemCount > 0 ? Double.BYTES : 0);\n  final ArrayList<Double> weightList=new ArrayList<>(allocatedItems);\n  final double[] weights=new double[allocatedItems];\n  srcMem.getDoubleArray(weightOffsetBytes,weights,0,regionHItemCount);\n  for (int i=0; i < regionHItemCount; ++i) {\n    if (weights[i] <= 0.0) {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + \"Non-positive weight in heapify(): \" + weights[i]);\n    }\n    weightList.add(weights[i]);\n  }\n  long markBytes=0;\n  int markCount=0;\n  ArrayList<Boolean> markList=null;\n  if (isGadget) {\n    final long markOffsetBytes=preLongBytes + ((long)regionHItemCount * Double.BYTES);\n    markBytes=ArrayOfBooleansSerDe.computeBytesNeeded(regionHItemCount);\n    markList=new ArrayList<>(allocatedItems);\n    final ArrayOfBooleansSerDe booleansSerDe=new ArrayOfBooleansSerDe();\n    final Boolean[] markArray=booleansSerDe.deserializeFromMemory(srcMem.region(markOffsetBytes,(regionHItemCount >>> 3) + 1),0,regionHItemCount);\n    for (    Boolean mark : markArray) {\n      if (mark) {\n        ++markCount;\n      }\n    }\n    markList.addAll(Arrays.asList(markArray));\n  }\n  final long offsetBytes=preLongBytes + ((long)regionHItemCount * Double.BYTES) + markBytes;\n  final T[] data=serDe.deserializeFromMemory(srcMem.region(offsetBytes,srcMem.getCapacity() - offsetBytes),0,totalItemsInRegions);\n  final List<T> wrappedData=Arrays.asList(data);\n  final ArrayList<T> dataList=new ArrayList<>(allocatedItems);\n  dataList.addAll(wrappedData.subList(0,regionHItemCount));\n  if (regionRItemCount > 0) {\n    weightList.add(-1.0);\n    if (isGadget) {\n      markList.add(false);\n    }\n    for (int i=0; i < regionRItemCount; ++i) {\n      weightList.add(-1.0);\n      if (isGadget) {\n        markList.add(false);\n      }\n    }\n    dataList.add(null);\n    dataList.addAll(wrappedData.subList(regionHItemCount,totalItemsInRegions));\n  }\n  final VarOptItemsSketch<T> sketch=new VarOptItemsSketch<>(dataList,weightList,numberOfItems,totalItems,allocatedItems,resizeFactor,regionHItemCount,regionRItemCount,totalRWeight);\n  if (isGadget) {\n    sketch.marks_=markList;\n    sketch.numMarksInH_=markCount;\n  }\n  return sketch;\n}"
    },
    "Old_Method": "/** \n * Returns a sketch instance of this class from the given srcMem, which must be a Memory representation of this sketch class.\n * @param < T >    The type of item this sketch contains\n * @param srcMem a Memory representation of a sketch of this class.<a href=\" {@docRoot}/resources/dictionary.html#mem\">See Memory<\/a>\n * @param serDe  An instance of ArrayOfItemsSerDe\n * @return a sketch instance of this class\n */\npublic static <T>VarOptItemsSketch<T> heapify(final Memory srcMem,final ArrayOfItemsSerDe<T> serDe){\n  final int numPreLongs=getAndCheckPreLongs(srcMem);\n  final ResizeFactor rf=ResizeFactor.getRF(extractResizeFactor(srcMem));\n  final int serVer=extractSerVer(srcMem);\n  final int familyId=extractFamilyID(srcMem);\n  final int flags=extractFlags(srcMem);\n  final boolean isEmpty=(flags & EMPTY_FLAG_MASK) != 0;\n  final boolean isGadget=(flags & GADGET_FLAG_MASK) != 0;\n  if (isEmpty) {\n    if (numPreLongs != VO_PRELONGS_EMPTY) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_EMPTY + \" for an empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n else {\n    if ((numPreLongs != VO_PRELONGS_WARMUP) && (numPreLongs != VO_PRELONGS_FULL)) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_WARMUP + \" or \"+ VO_PRELONGS_FULL+ \" for a non-empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n  if (serVer != SER_VER) {\n    throw new SketchesArgumentException(\"Possible Corruption: Ser Ver must be \" + SER_VER + \": \"+ serVer);\n  }\n  final int reqFamilyId=Family.VAROPT.getID();\n  if (familyId != reqFamilyId) {\n    throw new SketchesArgumentException(\"Possible Corruption: FamilyID must be \" + reqFamilyId + \": \"+ familyId);\n  }\n  final int k=extractK(srcMem);\n  if (k < 1) {\n    throw new SketchesArgumentException(\"Possible Corruption: k must be at least 1: \" + k);\n  }\n  if (isEmpty) {\n    assert numPreLongs == Family.VAROPT.getMinPreLongs();\n    return new VarOptItemsSketch<>(k,rf);\n  }\n  final long n=extractN(srcMem);\n  if (n < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: n cannot be negative: \" + n);\n  }\n  final int hCount=extractHRegionItemCount(srcMem);\n  final int rCount=extractRRegionItemCount(srcMem);\n  if (hCount < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: H region count cannot be \" + \"negative: \" + hCount);\n  }\n  if (rCount < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: R region count cannot be \" + \"negative: \" + rCount);\n  }\n  double totalRWeight=0.0;\n  if (numPreLongs == Family.VAROPT.getMaxPreLongs()) {\n    if (rCount > 0) {\n      totalRWeight=extractTotalRWeight(srcMem);\n    }\n else {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + Family.VAROPT.getMaxPreLongs() + \" preLongs but no items in R region\");\n    }\n  }\n  final int preLongBytes=numPreLongs << 3;\n  final int totalItems=hCount + rCount;\n  int allocatedItems=k + 1;\n  if (rCount == 0) {\n    final int ceilingLgK=Util.exactLog2OfInt(Util.ceilingPowerOf2(k),\"heapify\");\n    final int minLgSize=Util.exactLog2OfInt(Util.ceilingPowerOf2(hCount),\"heapify\");\n    final int initialLgSize=SamplingUtil.startingSubMultiple(ceilingLgK,rf.lg(),Math.max(minLgSize,MIN_LG_ARR_ITEMS));\n    allocatedItems=SamplingUtil.getAdjustedSize(k,1 << initialLgSize);\n    if (allocatedItems == k) {\n      ++allocatedItems;\n    }\n  }\n  final long weightOffsetBytes=TOTAL_WEIGHT_R_DOUBLE + (rCount > 0 ? Double.BYTES : 0);\n  final ArrayList<Double> weightList=new ArrayList<>(allocatedItems);\n  final double[] wts=new double[allocatedItems];\n  srcMem.getDoubleArray(weightOffsetBytes,wts,0,hCount);\n  for (int i=0; i < hCount; ++i) {\n    if (wts[i] <= 0.0) {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + \"Non-positive weight in heapify(): \" + wts[i]);\n    }\n    weightList.add(wts[i]);\n  }\n  long markBytes=0;\n  int markCount=0;\n  ArrayList<Boolean> markList=null;\n  if (isGadget) {\n    final long markOffsetBytes=preLongBytes + ((long)hCount * Double.BYTES);\n    markBytes=ArrayOfBooleansSerDe.computeBytesNeeded(hCount);\n    markList=new ArrayList<>(allocatedItems);\n    final ArrayOfBooleansSerDe booleansSerDe=new ArrayOfBooleansSerDe();\n    final Boolean[] markArray=booleansSerDe.deserializeFromMemory(srcMem.region(markOffsetBytes,(hCount >>> 3) + 1),0,hCount);\n    for (    Boolean mark : markArray) {\n      if (mark) {\n        ++markCount;\n      }\n    }\n    markList.addAll(Arrays.asList(markArray));\n  }\n  final long offsetBytes=preLongBytes + ((long)hCount * Double.BYTES) + markBytes;\n  final T[] data=serDe.deserializeFromMemory(srcMem.region(offsetBytes,srcMem.getCapacity() - offsetBytes),0,totalItems);\n  final List<T> wrappedData=Arrays.asList(data);\n  final ArrayList<T> dataList=new ArrayList<>(allocatedItems);\n  dataList.addAll(wrappedData.subList(0,hCount));\n  if (rCount > 0) {\n    weightList.add(-1.0);\n    if (isGadget) {\n      markList.add(false);\n    }\n    for (int i=0; i < rCount; ++i) {\n      weightList.add(-1.0);\n      if (isGadget) {\n        markList.add(false);\n      }\n    }\n    dataList.add(null);\n    dataList.addAll(wrappedData.subList(hCount,totalItems));\n  }\n  final VarOptItemsSketch<T> sketch=new VarOptItemsSketch<>(dataList,weightList,k,n,allocatedItems,rf,hCount,rCount,totalRWeight);\n  if (isGadget) {\n    sketch.marks_=markList;\n    sketch.numMarksInH_=markCount;\n  }\n  return sketch;\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/sampling/VarOptItemsSketch.java",
    "Start": 11791,
    "Stop": 18243,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "heapify"
}