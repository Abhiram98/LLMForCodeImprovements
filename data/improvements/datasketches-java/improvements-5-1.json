{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Extract Magic Numbers as Constants",
                "Change_Diff": "- int k=256;\n- int n=1000000;\n- int numPhiValues=99;\n- double nominal=(1e6 * q) / 100.0;\n- assertTrue(reported >= (nominal - 10000.0));\n- assertTrue(reported <= (nominal + 10000.0));\n- assertTrue(subtotal >= (phi - 0.01));\n- assertTrue(subtotal <= (phi + 0.01));\n- assertEquals(result.getRank(500000),0.5,0.01);\n+ final int K_VALUE = 256;\n+ final int N_VALUE = 1000000;\n+ final int PHI_VALUES = 99;\n+ final double NOMINAL_FACTOR = 1e6;\n+ final double ERROR_MARGIN = 10000.0;\n+ final double PHI_INCREMENT = 0.01;\n+ final double RANK_VALUE = 500000;\n+ final double EXPECTED_RANK = 0.5;",
                "Description": "Magic numbers like 256, 1000000, 99, 10000.0, 0.01 and 0.5 are used in the code. It's better to extract them as constants to improve readability and maintainability.",
                "Start": 2,
                "End": 46
            },
            {
                "Improvement": "Use enhanced for loop instead of traditional for loop",
                "Change_Diff": "- for (int q=1; q <= 99; q++) {\n- phiArr[q - 1]=q / 100.0;\n- for (int q=1; q <= 99; q++) {\n- double reported=splitPoints[q - 1];\n- for (int q=1; q <= 100; q++) {\n- subtotal+=pmfResult[q - 1];\n- for (int q=1; q <= 100; q++) {\n- subtotal=cdfResult[q - 1];\n+ for (double val : phiArr) {\n+ for (double reported : splitPoints) {\n+ for (double pmf : pmfResult) {\n+ subtotal += pmf;\n+ for (double cdf : cdfResult) {\n+ subtotal = cdf;",
                "Description": "Instead of using a traditional for loop to iterate over phiArr, splitPoints, pmfResult and cdfResult, use an enhanced for loop.",
                "Start": 23,
                "End": 46
            }
        ],
        "Final code": "@Test public void checkEndToEnd(){\n  final int K_VALUE = 256;\n  final int N_VALUE = 1000000;\n  final int PHI_VALUES = 99;\n  final double NOMINAL_FACTOR = 1e6;\n  final double ERROR_MARGIN = 10000.0;\n  final double PHI_INCREMENT = 0.01;\n  final double RANK_VALUE = 500000;\n  final double EXPECTED_RANK = 0.5;\n\n  UpdateDoublesSketch qs=DoublesSketch.builder().setK(K_VALUE).build();\n  UpdateDoublesSketch qs2=DoublesSketch.builder().setK(K_VALUE).build();\n\n  for (int item=N_VALUE; item >= 1; item--) {\n    if ((item % 4) == 0) qs.update(item);\n    else qs2.update(item);\n  }\n\n  assertEquals(qs.getN() + qs2.getN(), N_VALUE);\n\n  DoublesUnion union=DoublesUnion.heapify(qs);\n  union.union(qs2);\n\n  DoublesSketch result=union.getResult();\n\n  double[] phiArr=new double[PHI_VALUES];\n\n  for (double val : phiArr) {\n    val = PHI_INCREMENT;\n  }\n\n  double[] splitPoints=result.getQuantiles(phiArr);\n\n  for (double reported : splitPoints) {\n    double nominal = (NOMINAL_FACTOR * PHI_INCREMENT) / 100.0;\n    assertTrue(reported >= (nominal - ERROR_MARGIN));\n    assertTrue(reported <= (nominal + ERROR_MARGIN));\n  }\n\n  double[] pmfResult=result.getPMF(splitPoints);\n\n  double subtotal=0.0;\n\n  for (double pmf : pmfResult) {\n    subtotal += pmf;\n    assertTrue(subtotal >= (PHI_INCREMENT - 0.01));\n    assertTrue(subtotal <= (PHI_INCREMENT + 0.01));\n  }\n\n  double[] cdfResult=result.getCDF(splitPoints);\n\n  for (double cdf : cdfResult) {\n    subtotal = cdf;\n    assertTrue(subtotal >= (PHI_INCREMENT - 0.01));\n    assertTrue(subtotal <= (PHI_INCREMENT + 0.01));\n  }\n\n  assertEquals(result.getRank(RANK_VALUE),EXPECTED_RANK,0.01);\n}"
    },
    "Old_Method": "@Test public void checkEndToEnd(){\n  int k=256;\n  UpdateDoublesSketch qs=DoublesSketch.builder().setK(k).build();\n  UpdateDoublesSketch qs2=DoublesSketch.builder().setK(k).build();\n  int n=1000000;\n  for (int item=n; item >= 1; item--) {\n    if ((item % 4) == 0) {\n      qs.update(item);\n    }\n else {\n      qs2.update(item);\n    }\n  }\n  assertEquals(qs.getN() + qs2.getN(),n);\n  DoublesUnion union=DoublesUnion.heapify(qs);\n  union.union(qs2);\n  DoublesSketch result=union.getResult();\n  int numPhiValues=99;\n  double[] phiArr=new double[numPhiValues];\n  for (int q=1; q <= 99; q++) {\n    phiArr[q - 1]=q / 100.0;\n  }\n  double[] splitPoints=result.getQuantiles(phiArr);\n  for (int q=1; q <= 99; q++) {\n    double nominal=(1e6 * q) / 100.0;\n    double reported=splitPoints[q - 1];\n    assertTrue(reported >= (nominal - 10000.0));\n    assertTrue(reported <= (nominal + 10000.0));\n  }\n  double[] pmfResult=result.getPMF(splitPoints);\n  double subtotal=0.0;\n  for (int q=1; q <= 100; q++) {\n    double phi=q / 100.0;\n    subtotal+=pmfResult[q - 1];\n    assertTrue(subtotal >= (phi - 0.01));\n    assertTrue(subtotal <= (phi + 0.01));\n  }\n  double[] cdfResult=result.getCDF(splitPoints);\n  for (int q=1; q <= 100; q++) {\n    double phi=q / 100.0;\n    subtotal=cdfResult[q - 1];\n    assertTrue(subtotal >= (phi - 0.01));\n    assertTrue(subtotal <= (phi + 0.01));\n  }\n  assertEquals(result.getRank(500000),0.5,0.01);\n}\n",
    "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/quantiles/HeapUpdateDoublesSketchTest.java",
    "Start": 2693,
    "Stop": 4396,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "checkEndToEnd"
}