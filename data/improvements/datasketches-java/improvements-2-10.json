{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Use try-with-resources to manage resources",
                "Change_Diff": "- final WritableMemory wmem=WritableMemory.allocate((int)cap); \n+ try(final WritableMemory wmem=WritableMemory.allocate((int)cap)){",
                "Description": "In the current code, resources such as WritableMemory are not being managed properly. Not closing resources can lead to memory leaks. Java 7 introduced the try-with-resources statement, which ensures that each resource is closed at the end of the statement. This can be used to manage resources effectively.",
                "Start": 26,
                "End": 78
            },
            {
                "Improvement": "Use Java 8 Stream API for sum operations",
                "Change_Diff": "- sumCtor_nS+=nanoEnd - nanoStart;\n+ sumCtor_nS=streamSketches.stream().mapToLong(sketch -> sketch.nanoTime()).sum();",
                "Description": "Java 8 introduced the Stream API, which can be used to perform operations on collections in a functional programming style. This can be used to simplify the code and make it more readable. For instance, the sum operations can be performed using the Stream API's `mapToLong` and `sum` methods.",
                "Start": 47,
                "End": 47
            },
            {
                "Improvement": "Avoid using magic numbers",
                "Change_Diff": "- final int lgWaves=Math.max(lgTotTrials - 10,0); \n+ final int MAGIC_NUMBER_10 = 10; \n+ final int lgWaves=Math.max(lgTotTrials - MAGIC_NUMBER_10,0);",
                "Description": "The code contains many magic numbers, such as 10, 1E3, and 2.0. These values should be replaced with named constants to make the code more readable and maintainable.",
                "Start": 1,
                "End": 98
            }
        ],
        "Final code": "private void doTrialsAtLgKAtN(final int lgK,final long n,final int totalTrials){\n final int k=1 << lgK;\n final int minNK=(int)((k < n) ? k : n);\n final double nOverK=(double)n / k;\n final int lgTotTrials=Integer.numberOfTrailingZeros(totalTrials);\n final int MAGIC_NUMBER_10 = 10; \n final int lgWaves=Math.max(lgTotTrials - MAGIC_NUMBER_10,0);\n final int trialsPerWave=1 << (lgTotTrials - lgWaves);\n streamSketches=new CpcSketch[trialsPerWave];\n compressedStates1=new CompressedState[trialsPerWave];\n memoryArr=new WritableMemory[trialsPerWave];\n compressedStates2=new CompressedState[trialsPerWave];\n unCompressedSketches=new CpcSketch[trialsPerWave];\n long totalC=0;\n long totalW=0;\n long sumCtor_nS=0;\n long sumUpd_nS=0;\n long sumCom_nS=0;\n long sumSer_nS=0;\n long sumDes_nS=0;\n long sumUnc_nS=0;\n long sumEqu_nS=0;\n long nanoStart, nanoEnd;\n final long start=System.currentTimeMillis();\n for (int w=0; w < (1 << lgWaves); w++) {\n  nanoStart=System.nanoTime();\n  for (int trial=0; trial < trialsPerWave; trial++) {\n   final CpcSketch sketch=new CpcSketch(lgK);\n   streamSketches[trial]=sketch;\n  }\n  nanoEnd=System.nanoTime();\n  sumCtor_nS=streamSketches.stream().mapToLong(sketch -> sketch.nanoTime()).sum();\n  nanoStart=nanoEnd;\n  for (int trial=0; trial < trialsPerWave; trial++) {\n   final CpcSketch sketch=streamSketches[trial];\n   for (long i=0; i < n; i++) {\n    sketch.update(vIn+=INVERSE_GOLDEN_U64);\n   }\n  }\n  nanoEnd=System.nanoTime();\n  sumUpd_nS+=nanoEnd - nanoStart;\n  nanoStart=nanoEnd;\n  for (int trial=0; trial < trialsPerWave; trial++) {\n   final CpcSketch sketch=streamSketches[trial];\n   final CompressedState state=CompressedState.compress(sketch);\n   compressedStates1[trial]=state;\n   totalC+=sketch.numCoupons;\n   totalW+=state.csvLengthInts + state.cwLengthInts;\n  }\n  nanoEnd=System.nanoTime();\n  sumCom_nS+=nanoEnd - nanoStart;\n  nanoStart=nanoEnd;\n  for (int trial=0; trial < trialsPerWave; trial++) {\n   final CompressedState state=compressedStates1[trial];\n   final long cap=state.getRequiredSerializedBytes();\n   try(final WritableMemory wmem=WritableMemory.allocate((int)cap)){\n    state.exportToMemory(wmem);\n    memoryArr[trial]=wmem;\n   }\n  }\n  nanoEnd=System.nanoTime();\n  sumSer_nS+=nanoEnd - nanoStart;\n  nanoStart=nanoEnd;\n  for (int trial=0; trial < trialsPerWave; trial++) {\n   final Memory mem=memoryArr[trial];\n   final CompressedState state=importFromMemory(mem);\n   compressedStates2[trial]=state;\n  }\n  nanoEnd=System.nanoTime();\n  sumDes_nS+=nanoEnd - nanoStart;\n  nanoStart=nanoEnd;\n  for (int trial=0; trial < trialsPerWave; trial++) {\n   final CompressedState state=compressedStates2[trial];\n   CpcSketch uncSk=null;\n   uncSk=CpcSketch.uncompress(state,ThetaUtil.DEFAULT_UPDATE_SEED);\n   unCompressedSketches[trial]=uncSk;\n  }\n  nanoEnd=System.nanoTime();\n  sumUnc_nS+=nanoEnd - nanoStart;\n  nanoStart=nanoEnd;\n  for (int trial=0; trial < trialsPerWave; trial++) {\n   rtAssert(TestUtil.specialEquals(streamSketches[trial],unCompressedSketches[trial],false,false));\n  }\n  nanoEnd=System.nanoTime();\n  sumEqu_nS+=nanoEnd - nanoStart;\n  nanoStart=nanoEnd;\n }\n final double total_S=(System.currentTimeMillis() - start) / 1E3;\n final double avgC=(1.0 * totalC) / totalTrials;\n final double avgCoK=avgC / k;\n final double avgWords=(1.0 * totalW) / totalTrials;\n final double avgBytes=(4.0 * totalW) / totalTrials;\n final double avgCtor_nS=Math.round((double)sumCtor_nS / totalTrials);\n final double avgUpd_nS=Math.round((double)sumUpd_nS / totalTrials);\n final double avgUpd_nSperN=avgUpd_nS / n;\n final double avgCom_nS=Math.round((double)sumCom_nS / totalTrials);\n final double avgCom_nSper2C=avgCom_nS / (2.0 * avgC);\n final double avgCom_nSperK=avgCom_nS / k;\n final double avgSer_nS=Math.round((double)sumSer_nS / totalTrials);\n final double avgSer_nSperW=avgSer_nS / avgWords;\n final double avgDes_nS=Math.round((double)sumDes_nS / totalTrials);\n final double avgDes_nSperW=avgDes_nS / avgWords;\n final double avgUnc_nS=Math.round((double)sumUnc_nS / totalTrials);\n final double avgUnc_nSper2C=avgUnc_nS / (2.0 * avgC);\n final double avgUnc_nSperK=avgUnc_nS / k;\n final double avgEqu_nS=Math.round((double)sumEqu_nS / totalTrials);\n final double avgEqu_nSperMinNK=avgEqu_nS / minNK;\n final int len=unCompressedSketches.length;\n final Flavor finFlavor=unCompressedSketches[len - 1].getFlavor();\n final String offStr=Integer.toString(unCompressedSketches[len - 1].windowOffset);\n final String flavorOff=finFlavor.toString() + String.format(\"%2s\",offStr);\n printf(dfmt,lgK,totalTrials,n,minNK,avgCoK,flavorOff,nOverK,avgBytes,avgCtor_nS,avgUpd_nS,avgCom_nS,avgSer_nS,avgDes_nS,avgUnc_nS,avgEqu_nS,avgUpd_nSperN,avgCom_nSper2C,avgCom_nSperK,avgSer_nSperW,avgDes_nSperW,avgUnc_nSper2C,avgUnc_nSperK,avgEqu_nSperMinNK,total_S);\n}"
    },
    "Old_Method": "private void doTrialsAtLgKAtN(final int lgK,final long n,final int totalTrials){\n  final int k=1 << lgK;\n  final int minNK=(int)((k < n) ? k : n);\n  final double nOverK=(double)n / k;\n  final int lgTotTrials=Integer.numberOfTrailingZeros(totalTrials);\n  final int lgWaves=Math.max(lgTotTrials - 10,0);\n  final int trialsPerWave=1 << (lgTotTrials - lgWaves);\n  streamSketches=new CpcSketch[trialsPerWave];\n  compressedStates1=new CompressedState[trialsPerWave];\n  memoryArr=new WritableMemory[trialsPerWave];\n  compressedStates2=new CompressedState[trialsPerWave];\n  unCompressedSketches=new CpcSketch[trialsPerWave];\n  long totalC=0;\n  long totalW=0;\n  long sumCtor_nS=0;\n  long sumUpd_nS=0;\n  long sumCom_nS=0;\n  long sumSer_nS=0;\n  long sumDes_nS=0;\n  long sumUnc_nS=0;\n  long sumEqu_nS=0;\n  long nanoStart, nanoEnd;\n  final long start=System.currentTimeMillis();\n  for (int w=0; w < (1 << lgWaves); w++) {\n    nanoStart=System.nanoTime();\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=new CpcSketch(lgK);\n      streamSketches[trial]=sketch;\n    }\n    nanoEnd=System.nanoTime();\n    sumCtor_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=streamSketches[trial];\n      for (long i=0; i < n; i++) {\n        sketch.update(vIn+=INVERSE_GOLDEN_U64);\n      }\n    }\n    nanoEnd=System.nanoTime();\n    sumUpd_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=streamSketches[trial];\n      final CompressedState state=CompressedState.compress(sketch);\n      compressedStates1[trial]=state;\n      totalC+=sketch.numCoupons;\n      totalW+=state.csvLengthInts + state.cwLengthInts;\n    }\n    nanoEnd=System.nanoTime();\n    sumCom_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CompressedState state=compressedStates1[trial];\n      final long cap=state.getRequiredSerializedBytes();\n      final WritableMemory wmem=WritableMemory.allocate((int)cap);\n      state.exportToMemory(wmem);\n      memoryArr[trial]=wmem;\n    }\n    nanoEnd=System.nanoTime();\n    sumSer_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final Memory mem=memoryArr[trial];\n      final CompressedState state=importFromMemory(mem);\n      compressedStates2[trial]=state;\n    }\n    nanoEnd=System.nanoTime();\n    sumDes_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CompressedState state=compressedStates2[trial];\n      CpcSketch uncSk=null;\n      uncSk=CpcSketch.uncompress(state,ThetaUtil.DEFAULT_UPDATE_SEED);\n      unCompressedSketches[trial]=uncSk;\n    }\n    nanoEnd=System.nanoTime();\n    sumUnc_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      rtAssert(TestUtil.specialEquals(streamSketches[trial],unCompressedSketches[trial],false,false));\n    }\n    nanoEnd=System.nanoTime();\n    sumEqu_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n  }\n  final double total_S=(System.currentTimeMillis() - start) / 1E3;\n  final double avgC=(1.0 * totalC) / totalTrials;\n  final double avgCoK=avgC / k;\n  final double avgWords=(1.0 * totalW) / totalTrials;\n  final double avgBytes=(4.0 * totalW) / totalTrials;\n  final double avgCtor_nS=Math.round((double)sumCtor_nS / totalTrials);\n  final double avgUpd_nS=Math.round((double)sumUpd_nS / totalTrials);\n  final double avgUpd_nSperN=avgUpd_nS / n;\n  final double avgCom_nS=Math.round((double)sumCom_nS / totalTrials);\n  final double avgCom_nSper2C=avgCom_nS / (2.0 * avgC);\n  final double avgCom_nSperK=avgCom_nS / k;\n  final double avgSer_nS=Math.round((double)sumSer_nS / totalTrials);\n  final double avgSer_nSperW=avgSer_nS / avgWords;\n  final double avgDes_nS=Math.round((double)sumDes_nS / totalTrials);\n  final double avgDes_nSperW=avgDes_nS / avgWords;\n  final double avgUnc_nS=Math.round((double)sumUnc_nS / totalTrials);\n  final double avgUnc_nSper2C=avgUnc_nS / (2.0 * avgC);\n  final double avgUnc_nSperK=avgUnc_nS / k;\n  final double avgEqu_nS=Math.round((double)sumEqu_nS / totalTrials);\n  final double avgEqu_nSperMinNK=avgEqu_nS / minNK;\n  final int len=unCompressedSketches.length;\n  final Flavor finFlavor=unCompressedSketches[len - 1].getFlavor();\n  final String offStr=Integer.toString(unCompressedSketches[len - 1].windowOffset);\n  final String flavorOff=finFlavor.toString() + String.format(\"%2s\",offStr);\n  printf(dfmt,lgK,totalTrials,n,minNK,avgCoK,flavorOff,nOverK,avgBytes,avgCtor_nS,avgUpd_nS,avgCom_nS,avgSer_nS,avgDes_nS,avgUnc_nS,avgEqu_nS,avgUpd_nSperN,avgCom_nSper2C,avgCom_nSperK,avgSer_nSperW,avgDes_nSperW,avgUnc_nSper2C,avgUnc_nSperK,avgEqu_nSperMinNK,total_S);\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/cpc/CompressionCharacterization.java",
    "Start": 3877,
    "Stop": 9810,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "doTrialsAtLgKAtN"
}