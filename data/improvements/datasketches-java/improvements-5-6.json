{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Remove hard-coded values and use constants",
                "Change_Diff": "- int k=256;\n+ final int K_VALUE = 256;\n\n- int n=1000000;\n+ final int N_VALUE = 1000000;\n\n- int numPhiValues=99;\n+ final int NUM_PHI_VALUES = 99;\n\n- for (int q=1; q <= 99; q++) {\n+ for (int q=1; q <= NUM_PHI_VALUES; q++) {\n\n- double nominal=(1e6 * q) / 100.0;\n+ final double NOMINAL_FACTOR = 1e6 / 100.0;\n- double nominal=(NOMINAL_FACTOR * q);\n\n- assertTrue(reported >= (nominal - 10000.0));\n- assertTrue(reported <= (nominal + 10000.0));\n+ final double ERROR_MARGIN = 10000.0;\n+ assertTrue(reported >= (nominal - ERROR_MARGIN));\n+ assertTrue(reported <= (nominal + ERROR_MARGIN));\n\n- for (int q=1; q <= 100; q++) {\n+ final int NUM_QUERIES = 100;\n+ for (int q=1; q <= NUM_QUERIES; q++) {\n\n- assertTrue(subtotal >= (phi - 0.01));\n- assertTrue(subtotal <= (phi + 0.01));\n+ final double PHI_ERROR_MARGIN = 0.01;\n+ assertTrue(subtotal >= (phi - PHI_ERROR_MARGIN));\n+ assertTrue(subtotal <= (phi + PHI_ERROR_MARGIN));",
                "Description": "Hard-coded values (e.g., 256, 1000000, 99, 100, 10000.0, 0.01) can make the code harder to understand and maintain. They should be replaced with named constants for clarity and ease of modification.",
                "Start": 2,
                "End": 44
            },
            {
                "Improvement": "Use enhanced for loop instead of traditional for loop",
                "Change_Diff": "- for (int q=1; q <= NUM_PHI_VALUES; q++) {\n+ for (double phi : phiArr) {\n\n- for (int q=1; q <= NUM_QUERIES; q++) {\n+ for (double pmf : pmfResult) {\n\n- for (int q=1; q <= NUM_QUERIES; q++) {\n+ for (double cdf : cdfResult) {",
                "Description": "When dealing with arrays or collections, using an enhanced for loop can make the code cleaner and easier to read.",
                "Start": 10,
                "End": 44
            }
        ],
        "Final code": "@Test public void checkEndToEnd(){\n  final int K_VALUE = 256;\n  UpdateDoublesSketch qs=DoublesSketch.builder().setK(K_VALUE).build();\n  UpdateDoublesSketch qs2=DoublesSketch.builder().setK(K_VALUE).build();\n  final int N_VALUE = 1000000;\n  for (int item=N_VALUE; item >= 1; item--) {\n    if ((item % 4) == 0) {\n      qs.update(item);\n    } else {\n      qs2.update(item);\n    }\n  }\n  assertEquals(qs.getN() + qs2.getN(),N_VALUE);\n  DoublesUnion union=DoublesUnion.heapify(qs);\n  union.union(qs2);\n  DoublesSketch result=union.getResult();\n  final int NUM_PHI_VALUES = 99;\n  double[] phiArr=new double[NUM_PHI_VALUES];\n  for (int q=1; q <= NUM_PHI_VALUES; q++) {\n    phiArr[q - 1]=q / 100.0;\n  }\n  double[] splitPoints=result.getQuantiles(phiArr);\n  final double NOMINAL_FACTOR = 1e6 / 100.0;\n  final double ERROR_MARGIN = 10000.0;\n  for (double phi : phiArr) {\n    double nominal=(NOMINAL_FACTOR * phi);\n    double reported=splitPoints[phi - 1];\n    assertTrue(reported >= (nominal - ERROR_MARGIN));\n    assertTrue(reported <= (nominal + ERROR_MARGIN));\n  }\n  double[] pmfResult=result.getPMF(splitPoints);\n  double subtotal=0.0;\n  final int NUM_QUERIES = 100;\n  final double PHI_ERROR_MARGIN = 0.01;\n  for (double pmf : pmfResult) {\n    double phi=pmf / NUM_QUERIES;\n    subtotal+=pmf;\n    assertTrue(subtotal >= (phi - PHI_ERROR_MARGIN));\n    assertTrue(subtotal <= (phi + PHI_ERROR_MARGIN));\n  }\n  double[] cdfResult=result.getCDF(splitPoints);\n  for (double cdf : cdfResult) {\n    double phi=cdf / NUM_QUERIES;\n    subtotal=cdf;\n    assertTrue(subtotal >= (phi - PHI_ERROR_MARGIN));\n    assertTrue(subtotal <= (phi + PHI_ERROR_MARGIN));\n  }\n  assertEquals(result.getRank(500000),0.5,0.01);}"
    },
    "Old_Method": "@Test public void checkEndToEnd(){\n  int k=256;\n  UpdateDoublesSketch qs=DoublesSketch.builder().setK(k).build();\n  UpdateDoublesSketch qs2=DoublesSketch.builder().setK(k).build();\n  int n=1000000;\n  for (int item=n; item >= 1; item--) {\n    if ((item % 4) == 0) {\n      qs.update(item);\n    }\n else {\n      qs2.update(item);\n    }\n  }\n  assertEquals(qs.getN() + qs2.getN(),n);\n  DoublesUnion union=DoublesUnion.heapify(qs);\n  union.union(qs2);\n  DoublesSketch result=union.getResult();\n  int numPhiValues=99;\n  double[] phiArr=new double[numPhiValues];\n  for (int q=1; q <= 99; q++) {\n    phiArr[q - 1]=q / 100.0;\n  }\n  double[] splitPoints=result.getQuantiles(phiArr);\n  for (int q=1; q <= 99; q++) {\n    double nominal=(1e6 * q) / 100.0;\n    double reported=splitPoints[q - 1];\n    assertTrue(reported >= (nominal - 10000.0));\n    assertTrue(reported <= (nominal + 10000.0));\n  }\n  double[] pmfResult=result.getPMF(splitPoints);\n  double subtotal=0.0;\n  for (int q=1; q <= 100; q++) {\n    double phi=q / 100.0;\n    subtotal+=pmfResult[q - 1];\n    assertTrue(subtotal >= (phi - 0.01));\n    assertTrue(subtotal <= (phi + 0.01));\n  }\n  double[] cdfResult=result.getCDF(splitPoints);\n  for (int q=1; q <= 100; q++) {\n    double phi=q / 100.0;\n    subtotal=cdfResult[q - 1];\n    assertTrue(subtotal >= (phi - 0.01));\n    assertTrue(subtotal <= (phi + 0.01));\n  }\n  assertEquals(result.getRank(500000),0.5,0.01);\n}\n",
    "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/quantiles/HeapUpdateDoublesSketchTest.java",
    "Start": 2693,
    "Stop": 4396,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "checkEndToEnd"
}