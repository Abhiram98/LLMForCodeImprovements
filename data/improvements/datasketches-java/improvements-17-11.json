{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Remove unnecessary variable initialization",
                "Change_Diff": "- int i=0;\n+ // removed unused initialization",
                "Description": "Variable `i` is initialized at line 25 but it is not used till it is reinitialized in the for loop at line 26. Thus, the initialization at line 25 is not needed and can be removed.",
                "Start": 25,
                "End": 25
            },
            {
                "Improvement": "Avoid magic numbers",
                "Change_Diff": "+ final int INITIAL_VALUE = 7;\n+ final int STEP_VALUE = 2;\n- int t1=2;\n- int t2=2;\n- int rt=2;\n- int lgK1=7;\n- int lgK2=7;\n- int lgMaxK=7;\n- int n1=7;\n- int n2=7;\n+ int t1=INITIAL_VALUE;\n+ int t2=INITIAL_VALUE;\n+ int rt=INITIAL_VALUE;\n+ int lgK1=INITIAL_VALUE;\n+ int lgK2=INITIAL_VALUE;\n+ int lgMaxK=INITIAL_VALUE;\n+ int n1=INITIAL_VALUE;\n+ int n2=INITIAL_VALUE;",
                "Description": "The code contains magic numbers (i.e., bare numbers without a clear meaning), replace them with named constants to increase code readability.",
                "Start": 1,
                "End": 63
            },
            {
                "Improvement": "Extract repeated code into a method",
                "Change_Diff": "+ private void calculateAndUnion(int i, int lgK1, int lgK2, int lgMaxK, int t1, int t2, int rt) {\n+    int n1=((1 << (i - 3)) * 3) / 4;\n+    int n2=n1;\n+    basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n+    n1+=STEP_VALUE;\n+    basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n+    n1-=STEP_VALUE;\n+    n2+=STEP_VALUE;\n+    basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n+    n1+=STEP_VALUE;\n+    basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n+ }\n- // repeated code blocks replaced with method call",
                "Description": "The code block for calculating n1, n2 and calling basicUnion is repeated multiple times. This can be extracted into a method to avoid repetition and increase readability.",
                "Start": 29,
                "End": 61
            }
        ],
        "Final code": "final int INITIAL_VALUE = 7;\nfinal int STEP_VALUE = 2;\n\n@Test public void checkUnions(){\n\n  int t1=INITIAL_VALUE;\n  int t2=INITIAL_VALUE;\n  int rt=INITIAL_VALUE;\n  int lgK1=INITIAL_VALUE;\n  int lgK2=INITIAL_VALUE;\n  int lgMaxK=INITIAL_VALUE;\n  int n1=INITIAL_VALUE;\n  int n2=INITIAL_VALUE;\n\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n\n  n1=8;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n\n  n1=7;\n  n2=8;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n\n  n1=8;\n  n2=8;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n\n  n1=7;\n  n2=14;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n\n  println(\"++END BASE GROUP++\");\n\n  for (int i=7; i <= 13; i++) {\n    lgK1=i;\n    lgK2=i;\n    lgMaxK=i;\n\n    calculateAndUnion(i, lgK1, lgK2, lgMaxK, t1, t2, rt);\n\n    println(\"--END MINOR GROUP--\");\n\n    lgK1=i;\n    lgK2=i + 1;\n\n    calculateAndUnion(i, lgK1, lgK2, lgMaxK, t1, t2, rt);\n\n    println(\"--END MINOR GROUP--\");\n\n    lgK1=i + 1;\n    lgK2=i;\n\n    calculateAndUnion(i, lgK1, lgK2, lgMaxK, t1, t2, rt);\n\n    println(\"--END MINOR GROUP--\");\n\n    lgK1=i + 1;\n    lgK2=i + 1;\n\n    calculateAndUnion(i, lgK1, lgK2, lgMaxK, t1, t2, rt);\n\n    println(\"++END MAJOR GROUP++\");\n  }\n}\n\nprivate void calculateAndUnion(int i, int lgK1, int lgK2, int lgMaxK, int t1, int t2, int rt) {\n    int n1=((1 << (i - 3)) * 3) / 4;\n    int n2=n1;\n    basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    n1+=STEP_VALUE;\n    basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    n1-=STEP_VALUE;\n    n2+=STEP_VALUE;\n    basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    n1+=STEP_VALUE;\n    basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n}"
    },
    "Old_Method": "/** \n * The task here is to check the transition boundaries as the sketch morphs between LIST to SET to HLL modes. The transition points vary as a function of lgConfigK. In addition, this checks that the union operation is operating properly based on the order the sketches are presented to the union.\n */\n@Test public void checkUnions(){\n  int t1=2;\n  int t2=2;\n  int rt=2;\n  println(\"TgtR: \" + TgtHllType.values()[rt].toString());\n  int lgK1=7;\n  int lgK2=7;\n  int lgMaxK=7;\n  int n1=7;\n  int n2=7;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  n1=8;\n  n2=7;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  n1=7;\n  n2=8;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  n1=8;\n  n2=8;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  n1=7;\n  n2=14;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  println(\"++END BASE GROUP++\");\n  int i=0;\n  for (i=7; i <= 13; i++) {\n    lgK1=i;\n    lgK2=i;\n    lgMaxK=i;\n{\n      n1=((1 << (i - 3)) * 3) / 4;\n      n2=n1;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1-=2;\n      n2+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    }\n    println(\"--END MINOR GROUP--\");\n    lgK1=i;\n    lgK2=i + 1;\n    lgMaxK=i;\n{\n      n1=((1 << (i - 3)) * 3) / 4;\n      n2=n1;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1-=2;\n      n2+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    }\n    println(\"--END MINOR GROUP--\");\n    lgK1=i + 1;\n    lgK2=i;\n    lgMaxK=i;\n{\n      n1=((1 << (i - 3)) * 3) / 4;\n      n2=n1;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1-=2;\n      n2+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    }\n    println(\"--END MINOR GROUP--\");\n    lgK1=i + 1;\n    lgK2=i + 1;\n    lgMaxK=i;\n{\n      n1=((1 << (i - 3)) * 3) / 4;\n      n2=n1;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1-=2;\n      n2+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    }\n    println(\"++END MAJOR GROUP++\");\n  }\n}\n",
    "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/hll/UnionTest.java",
    "Start": 2061,
    "Stop": 5085,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "checkUnions"
}