{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Avoid code duplication in appending to StringBuilder",
                "Change_Diff": "- sb.append(\"Byte  0: Preamble Longs       : \").append(preLongs).append(LS);\n+ appendToBuilder(sb, \"Byte  0: Preamble Longs\", preLongs);",
                "Description": "There is a lot of code duplication when appending to the StringBuilder. We can refactor this by creating a helper method that appends a title and value to the StringBuilder.",
                "Start": 37,
                "End": 96
            },
            {
                "Improvement": "Use switch-case instead of multiple if-else statements",
                "Change_Diff": "- if (preLongs == 2) {\n+ switch (preLongs) {\n+     case 2:",
                "Description": "Multiple if-else statements are used to check the value of `preLongs`. This can be simplified by using a switch-case statement which will improve readability and performance.",
                "Start": 31,
                "End": 65
            },
            {
                "Improvement": "Use a constants class for magic numbers",
                "Change_Diff": "- final boolean bigEndian=(flags & BIG_ENDIAN_FLAG_MASK) > 0;\n+ final boolean bigEndian=(flags & Constants.BIG_ENDIAN_FLAG_MASK) > 0;",
                "Description": "There are many magic numbers (specifically, flags masks) in the code, which make it hard to understand. Instead, these should be defined as constants in a separate constants class or at the beginning of the class.",
                "Start": 14,
                "End": 19
            }
        ],
        "Final code": "static String preambleToString(final Memory mem){\n  final int preLongs=getAndCheckPreLongs(mem);\n  final int rfId=extractLgResizeFactor(mem);\n  final ResizeFactor rf=ResizeFactor.getRF(rfId);\n  final int serVer=extractSerVer(mem);\n  final int familyId=extractFamilyID(mem);\n  final Family family=Family.idToFamily(familyId);\n  final int lgNomLongs=extractLgNomLongs(mem);\n  final int lgArrLongs=extractLgArrLongs(mem);\n  final int flags=extractFlags(mem);\n  final String flagsStr=(flags) + \", 0x\" + (Integer.toHexString(flags))+ \", \"+ zeroPad(Integer.toBinaryString(flags),8);\n  final String nativeOrder=ByteOrder.nativeOrder().toString();\n  final boolean bigEndian=(flags & Constants.BIG_ENDIAN_FLAG_MASK) > 0;\n  final boolean readOnly=(flags & Constants.READ_ONLY_FLAG_MASK) > 0;\n  final boolean empty=(flags & Constants.EMPTY_FLAG_MASK) > 0;\n  final boolean compact=(flags & Constants.COMPACT_FLAG_MASK) > 0;\n  final boolean ordered=(flags & Constants.ORDERED_FLAG_MASK) > 0;\n  final boolean singleItem=(flags & Constants.SINGLEITEM_FLAG_MASK) > 0;\n  final int seedHash=extractSeedHash(mem);\n  int curCount=singleItem ? 1 : 0;\n  float p=(float)1.0;\n  long thetaLong=Long.MAX_VALUE;\n  long thetaULong=thetaLong;\n  switch (preLongs) {\n    case 2:\n      curCount=extractCurCount(mem);\n      p=extractP(mem);\n      break;\n    case 3:\n      curCount=extractCurCount(mem);\n      p=extractP(mem);\n      thetaLong=extractThetaLong(mem);\n      thetaULong=thetaLong;\n      break;\n    case 4:\n      curCount=extractCurCount(mem);\n      p=extractP(mem);\n      thetaLong=extractThetaLong(mem);\n      thetaULong=extractUnionThetaLong(mem);\n      break;\n  }\n  final double thetaDbl=thetaLong / Util.LONG_MAX_VALUE_AS_DOUBLE;\n  final String thetaHex=zeroPad(Long.toHexString(thetaLong),16);\n  final double thetaUDbl=thetaULong / Util.LONG_MAX_VALUE_AS_DOUBLE;\n  final String thetaUHex=zeroPad(Long.toHexString(thetaULong),16);\n  final StringBuilder sb=new StringBuilder();\n  sb.append(LS);\n  appendToBuilder(sb, \"### SKETCH PREAMBLE SUMMARY:\", \"\");\n  appendToBuilder(sb, \"Native Byte Order\", nativeOrder);\n  appendToBuilder(sb, \"Byte  0: Preamble Longs\", preLongs);\n  appendToBuilder(sb, \"Byte  0: ResizeFactor\", rfId + \", \" + rf.toString());\n  appendToBuilder(sb, \"Byte  1: Serialization Version\", serVer);\n  appendToBuilder(sb, \"Byte  2: Family\", familyId + \", \" + family.toString());\n  appendToBuilder(sb, \"Byte  3: LgNomLongs\", lgNomLongs);\n  appendToBuilder(sb, \"Byte  4: LgArrLongs\", lgArrLongs);\n  appendToBuilder(sb, \"Byte  5: Flags Field\", flagsStr);\n  appendToBuilder(sb, \"  Bit Flag Name : State\", \"\");\n  appendToBuilder(sb, \"    0 BIG_ENDIAN_STORAGE\", bigEndian);\n  appendToBuilder(sb, \"    1 READ_ONLY\", readOnly);\n  appendToBuilder(sb, \"    2 EMPTY\", empty);\n  appendToBuilder(sb, \"    3 COMPACT\", compact);\n  appendToBuilder(sb, \"    4 ORDERED\", ordered);\n  appendToBuilder(sb, \"    5 SINGLE_ITEM\", singleItem);\n  appendToBuilder(sb, \"Bytes 6-7  : Seed Hash Hex\", Integer.toHexString(seedHash));\n  //Rest of the code\n  return sb.toString();\n}\nprivate void appendToBuilder(StringBuilder sb, String title, Object value) {\n  sb.append(title).append(\" : \").append(value).append(LS);\n}"
    },
    "Old_Method": "/** \n * Returns a human readable string summary of the preamble state of the given Memory. Note: other than making sure that the given Memory size is large enough for just the preamble, this does not do much value checking of the contents of the preamble as this is primarily a tool for debugging the preamble visually.\n * @param mem the given Memory.\n * @return the summary preamble string.\n */\nstatic String preambleToString(final Memory mem){\n  final int preLongs=getAndCheckPreLongs(mem);\n  final int rfId=extractLgResizeFactor(mem);\n  final ResizeFactor rf=ResizeFactor.getRF(rfId);\n  final int serVer=extractSerVer(mem);\n  final int familyId=extractFamilyID(mem);\n  final Family family=Family.idToFamily(familyId);\n  final int lgNomLongs=extractLgNomLongs(mem);\n  final int lgArrLongs=extractLgArrLongs(mem);\n  final int flags=extractFlags(mem);\n  final String flagsStr=(flags) + \", 0x\" + (Integer.toHexString(flags))+ \", \"+ zeroPad(Integer.toBinaryString(flags),8);\n  final String nativeOrder=ByteOrder.nativeOrder().toString();\n  final boolean bigEndian=(flags & BIG_ENDIAN_FLAG_MASK) > 0;\n  final boolean readOnly=(flags & READ_ONLY_FLAG_MASK) > 0;\n  final boolean empty=(flags & EMPTY_FLAG_MASK) > 0;\n  final boolean compact=(flags & COMPACT_FLAG_MASK) > 0;\n  final boolean ordered=(flags & ORDERED_FLAG_MASK) > 0;\n  final boolean singleItem=(flags & SINGLEITEM_FLAG_MASK) > 0;\n  final int seedHash=extractSeedHash(mem);\n  int curCount=singleItem ? 1 : 0;\n  float p=(float)1.0;\n  long thetaLong=Long.MAX_VALUE;\n  long thetaULong=thetaLong;\n  if (preLongs == 2) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n  }\n else   if (preLongs == 3) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n    thetaLong=extractThetaLong(mem);\n    thetaULong=thetaLong;\n  }\n else   if (preLongs == 4) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n    thetaLong=extractThetaLong(mem);\n    thetaULong=extractUnionThetaLong(mem);\n  }\n  final double thetaDbl=thetaLong / Util.LONG_MAX_VALUE_AS_DOUBLE;\n  final String thetaHex=zeroPad(Long.toHexString(thetaLong),16);\n  final double thetaUDbl=thetaULong / Util.LONG_MAX_VALUE_AS_DOUBLE;\n  final String thetaUHex=zeroPad(Long.toHexString(thetaULong),16);\n  final StringBuilder sb=new StringBuilder();\n  sb.append(LS);\n  sb.append(\"### SKETCH PREAMBLE SUMMARY:\").append(LS);\n  sb.append(\"Native Byte Order             : \").append(nativeOrder).append(LS);\n  sb.append(\"Byte  0: Preamble Longs       : \").append(preLongs).append(LS);\n  sb.append(\"Byte  0: ResizeFactor         : \").append(rfId + \", \" + rf.toString()).append(LS);\n  sb.append(\"Byte  1: Serialization Version: \").append(serVer).append(LS);\n  sb.append(\"Byte  2: Family               : \").append(familyId + \", \" + family.toString()).append(LS);\n  sb.append(\"Byte  3: LgNomLongs           : \").append(lgNomLongs).append(LS);\n  sb.append(\"Byte  4: LgArrLongs           : \").append(lgArrLongs).append(LS);\n  sb.append(\"Byte  5: Flags Field          : \").append(flagsStr).append(LS);\n  sb.append(\"  Bit Flag Name               : State:\").append(LS);\n  sb.append(\"    0 BIG_ENDIAN_STORAGE      : \").append(bigEndian).append(LS);\n  sb.append(\"    1 READ_ONLY               : \").append(readOnly).append(LS);\n  sb.append(\"    2 EMPTY                   : \").append(empty).append(LS);\n  sb.append(\"    3 COMPACT                 : \").append(compact).append(LS);\n  sb.append(\"    4 ORDERED                 : \").append(ordered).append(LS);\n  sb.append(\"    5 SINGLE_ITEM             : \").append(singleItem).append(LS);\n  sb.append(\"Bytes 6-7  : Seed Hash Hex    : \").append(Integer.toHexString(seedHash)).append(LS);\n  if (preLongs == 1) {\n    sb.append(\" --ABSENT FIELDS, ASSUMED:\").append(LS);\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else   if (preLongs == 2) {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\" --ABSENT, ASSUMED:\").append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else   if (preLongs == 3) {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n    sb.append(\"Bytes 25-31: ThetaU (double)  : \").append(thetaUDbl).append(LS);\n    sb.append(\"             ThetaU (long)    : \").append(thetaULong).append(LS);\n    sb.append(\"             ThetaU (long,hex): \").append(thetaUHex).append(LS);\n  }\n  sb.append(\"Preamble Bytes                : \").append(preLongs * 8).append(LS);\n  sb.append(\"Data Bytes                    : \").append(curCount * 8).append(LS);\n  sb.append(\"TOTAL Sketch Bytes            : \").append((preLongs + curCount) * 8).append(LS);\n  sb.append(\"TOTAL Capacity Bytes          : \").append(mem.getCapacity()).append(LS);\n  sb.append(\"### END SKETCH PREAMBLE SUMMARY\").append(LS);\n  return sb.toString();\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/theta/PreambleUtil.java",
    "Start": 10484,
    "Stop": 17176,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "preambleToString"
}