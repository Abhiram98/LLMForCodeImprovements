{
    "Method_Improvements": {
        "Improvements": [{
            "Improvement": "Avoid re-declaration of variables inside switch-case",
            "Change_Diff": "- CompactSketch<S> result=null;\n- switch (anotbAction) {\n- case EMPTY_1_0_T:\n- {\n-       result=new CompactSketch<>(null,null,Long.MAX_VALUE,true);\n-       break;\n-     }\n- case DEGEN_MIN_0_F:\n- {\n-     final long thetaLong=min(thetaLongA,thetaLongB);\n-     result=new CompactSketch<>(null,null,thetaLong,false);\n-     break;\n-   }\n- case DEGEN_THA_0_F:\n- {\n-   result=new CompactSketch<>(null,null,thetaLongA,false);\n-   break;\n- }\n- case TRIM_A:\n- {\n- final DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\n- final long[] hashArrA=daA.hashArr;\n- final S[] summaryArrA=daA.summaryArr;\n- final long minThetaLong=min(thetaLongA,thetaLongB);\n- final DataArrays<S> da=trimAndCopyDataArrays(hashArrA,summaryArrA,minThetaLong,false);\n- result=new CompactSketch<>(da.hashArr,da.summaryArr,minThetaLong,skA.empty_);\n- break;\n- }\n- case SKETCH_A:\n- {\n- final DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\n- result=new CompactSketch<>(daA.hashArr,daA.summaryArr,thetaLongA,skA.empty_);\n- break;\n- }\n- case FULL_ANOTB:\n- {\n- final DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\n- final long minThetaLong=min(thetaLongA,thetaLongB);\n- @SuppressFBWarnings(value=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",justification=\"hashArr and summaryArr are guaranteed to be valid due to the switch on CornerCase\") final DataArrays<S> daR=getCopyOfResultArraysTheta(minThetaLong,daA.hashArr.length,daA.hashArr,daA.summaryArr,skB);\n- final int countR=(daR.hashArr == null) ? 0 : daR.hashArr.length;\n- if (countR == 0) {\n- result=new CompactSketch<>(null,null,minThetaLong,minThetaLong == Long.MAX_VALUE);\n- }\n-  else {\n- result=new CompactSketch<>(daR.hashArr,daR.summaryArr,minThetaLong,false);\n- }\n- }\n- }\n+ CompactSketch<S> result;\n+ DataArrays<S> daA;\n+ long minThetaLong;\n+ switch (anotbAction) {\n+ case EMPTY_1_0_T:\n+   result=new CompactSketch<>(null,null,Long.MAX_VALUE,true);\n+   break;\n+ case DEGEN_MIN_0_F:\n+   minThetaLong=min(thetaLongA,thetaLongB);\n+   result=new CompactSketch<>(null,null,minThetaLong,false);\n+   break;\n+ case DEGEN_THA_0_F:\n+   result=new CompactSketch<>(null,null,thetaLongA,false);\n+   break;\n+ case TRIM_A:\n+   daA=getCopyOfDataArraysTuple(skA);\n+   minThetaLong=min(thetaLongA,thetaLongB);\n+   DataArrays<S> da=trimAndCopyDataArrays(daA.hashArr,daA.summaryArr,minThetaLong,false);\n+   result=new CompactSketch<>(da.hashArr,da.summaryArr,minThetaLong,skA.empty_);\n+   break;\n+ case SKETCH_A:\n+   daA=getCopyOfDataArraysTuple(skA);\n+   result=new CompactSketch<>(daA.hashArr,daA.summaryArr,thetaLongA,skA.empty_);\n+   break;\n+ case FULL_ANOTB:\n+   daA=getCopyOfDataArraysTuple(skA);\n+   minThetaLong=min(thetaLongA,thetaLongB);\n+   DataArrays<S> daR=getCopyOfResultArraysTheta(minThetaLong,daA.hashArr.length,daA.hashArr,daA.summaryArr,skB);\n+   int countR=(daR.hashArr == null) ? 0 : daR.hashArr.length;\n+   if (countR == 0) {\n+     result=new CompactSketch<>(null,null,minThetaLong,minThetaLong == Long.MAX_VALUE);\n+   }\n+   else {\n+     result=new CompactSketch<>(daR.hashArr,daR.summaryArr,minThetaLong,false);\n+   }\n+   break;\n+ }",
            "Description": "Variables such as 'result', 'daA', 'minThetaLong' etc. are re-declared in each case of the switch statement. This is redundant and can lead to confusion. It's better to declare once and reuse these variables in each case.",
            "Start": 20,
            "End": 54
        }],
        "Final code": "@SuppressFBWarnings(value=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",justification=\"hashArr and summaryArr are guaranteed to be valid due to the switch on CornerCase\")\npublic static <S extends Summary>CompactSketch<S> aNotB(final Sketch<S> skA,final org.apache.datasketches.theta.Sketch skB){\n  if (skA == null || skB == null) {\n    throw new SketchesArgumentException(\"Neither argument may be null for this stateless operation.\");\n  }\n  final long thetaLongA=skA.getThetaLong();\n  final int countA=skA.getRetainedEntries();\n  final boolean emptyA=skA.isEmpty();\n  final long thetaLongB=skB.getThetaLong();\n  final int countB=skB.getRetainedEntries();\n  final boolean emptyB=skB.isEmpty();\n  final int id=SetOperationCornerCases.createCornerCaseId(thetaLongA,countA,emptyA,thetaLongB,countB,emptyB);\n  final CornerCase cCase=CornerCase.caseIdToCornerCase(id);\n  final AnotbAction anotbAction=cCase.getAnotbAction();\n  CompactSketch<S> result;\n  DataArrays<S> daA;\n  long minThetaLong;\n  switch (anotbAction) {\n    case EMPTY_1_0_T:\n      result=new CompactSketch<>(null,null,Long.MAX_VALUE,true);\n      break;\n    case DEGEN_MIN_0_F:\n      minThetaLong=min(thetaLongA,thetaLongB);\n      result=new CompactSketch<>(null,null,minThetaLong,false);\n      break;\n    case DEGEN_THA_0_F:\n      result=new CompactSketch<>(null,null,thetaLongA,false);\n      break;\n    case TRIM_A:\n      daA=getCopyOfDataArraysTuple(skA);\n      minThetaLong=min(thetaLongA,thetaLongB);\n      DataArrays<S> da=trimAndCopyDataArrays(daA.hashArr,daA.summaryArr,minThetaLong,false);\n      result=new CompactSketch<>(da.hashArr,da.summaryArr,minThetaLong,skA.empty_);\n      break;\n    case SKETCH_A:\n      daA=getCopyOfDataArraysTuple(skA);\n      result=new CompactSketch<>(daA.hashArr,daA.summaryArr,thetaLongA,skA.empty_);\n      break;\n    case FULL_ANOTB:\n      daA=getCopyOfDataArraysTuple(skA);\n      minThetaLong=min(thetaLongA,thetaLongB);\n      DataArrays<S> daR=getCopyOfResultArraysTheta(minThetaLong,daA.hashArr.length,daA.hashArr,daA.summaryArr,skB);\n      int countR=(daR.hashArr == null) ? 0 : daR.hashArr.length;\n      if (countR == 0) {\n        result=new CompactSketch<>(null,null,minThetaLong,minThetaLong == Long.MAX_VALUE);\n      }\n      else {\n        result=new CompactSketch<>(daR.hashArr,daR.summaryArr,minThetaLong,false);\n      }\n      break;\n  }\n  return result;\n}"
    },
    "Old_Method": "/** \n * Returns the A-and-not-B set operation on a Tuple sketch and a Theta sketch. <p>This a stateless operation and has no impact on the internal state of this operator. Thus, this is not an accumulating update and is independent of the  {@link #setA(Sketch)}, {@link #notB(Sketch)},  {@link #notB(org.apache.datasketches.theta.Sketch)}, and {@link #getResult(boolean)} methods.<\/p><p>If either argument is null an exception is thrown.<\/p> <p>Rationale: In mathematics a \"null set\" is a set with no members, which we call an empty set. That is distinctly different from the java <i>null<\/i>, which represents a nonexistent object. In most cases it is a programming error due to some object that was not properly initialized. With a null as the first argument, we cannot know what the user's intent is. With a null as the second argument, we can't ignore it as we must return a result and there is no following possible viable arguments for the second argument. Since it is very likely that a <i>null<\/i> is a programming error for either argument we throw a an exception.<\/p>\n * @param skA The incoming Tuple sketch for the first argument\n * @param skB The incoming Theta sketch for the second argument\n * @param < S > Type of Summary\n * @return the result as an unordered {@link CompactSketch}\n */\n@SuppressFBWarnings(value=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",justification=\"hashArr and summaryArr are guaranteed to be valid due to the switch on CornerCase\") public static <S extends Summary>CompactSketch<S> aNotB(final Sketch<S> skA,final org.apache.datasketches.theta.Sketch skB){\n  if (skA == null || skB == null) {\n    throw new SketchesArgumentException(\"Neither argument may be null for this stateless operation.\");\n  }\n  final long thetaLongA=skA.getThetaLong();\n  final int countA=skA.getRetainedEntries();\n  final boolean emptyA=skA.isEmpty();\n  final long thetaLongB=skB.getThetaLong();\n  final int countB=skB.getRetainedEntries();\n  final boolean emptyB=skB.isEmpty();\n  final int id=SetOperationCornerCases.createCornerCaseId(thetaLongA,countA,emptyA,thetaLongB,countB,emptyB);\n  final CornerCase cCase=CornerCase.caseIdToCornerCase(id);\n  final AnotbAction anotbAction=cCase.getAnotbAction();\n  CompactSketch<S> result=null;\nswitch (anotbAction) {\ncase EMPTY_1_0_T:\n{\n      result=new CompactSketch<>(null,null,Long.MAX_VALUE,true);\n      break;\n    }\ncase DEGEN_MIN_0_F:\n{\n    final long thetaLong=min(thetaLongA,thetaLongB);\n    result=new CompactSketch<>(null,null,thetaLong,false);\n    break;\n  }\ncase DEGEN_THA_0_F:\n{\n  result=new CompactSketch<>(null,null,thetaLongA,false);\n  break;\n}\ncase TRIM_A:\n{\nfinal DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\nfinal long[] hashArrA=daA.hashArr;\nfinal S[] summaryArrA=daA.summaryArr;\nfinal long minThetaLong=min(thetaLongA,thetaLongB);\nfinal DataArrays<S> da=trimAndCopyDataArrays(hashArrA,summaryArrA,minThetaLong,false);\nresult=new CompactSketch<>(da.hashArr,da.summaryArr,minThetaLong,skA.empty_);\nbreak;\n}\ncase SKETCH_A:\n{\nfinal DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\nresult=new CompactSketch<>(daA.hashArr,daA.summaryArr,thetaLongA,skA.empty_);\nbreak;\n}\ncase FULL_ANOTB:\n{\nfinal DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\nfinal long minThetaLong=min(thetaLongA,thetaLongB);\n@SuppressFBWarnings(value=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",justification=\"hashArr and summaryArr are guaranteed to be valid due to the switch on CornerCase\") final DataArrays<S> daR=getCopyOfResultArraysTheta(minThetaLong,daA.hashArr.length,daA.hashArr,daA.summaryArr,skB);\nfinal int countR=(daR.hashArr == null) ? 0 : daR.hashArr.length;\nif (countR == 0) {\nresult=new CompactSketch<>(null,null,minThetaLong,minThetaLong == Long.MAX_VALUE);\n}\n else {\nresult=new CompactSketch<>(daR.hashArr,daR.summaryArr,minThetaLong,false);\n}\n}\n}\nreturn result;\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/tuple/AnotB.java",
    "Start": 15811,
    "Stop": 20259,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "aNotB"
}