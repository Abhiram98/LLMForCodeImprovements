{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Replace if-else statements with guard clauses",
                "Change_Diff": "- if (isEmpty) {\n-    if (numPreLongs != VO_PRELONGS_EMPTY) {\n-      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_EMPTY + \" for an empty sketch. Found: \"+ numPreLongs);\n-    }\n-  }\n- else {\n-    if ((numPreLongs != VO_PRELONGS_WARMUP) && (numPreLongs != VO_PRELONGS_FULL)) {\n-      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_WARMUP + \" or \"+ VO_PRELONGS_FULL+ \" for a non-empty sketch. Found: \"+ numPreLongs);\n-    }\n-  }\n+ if (isEmpty && numPreLongs != VO_PRELONGS_EMPTY) {\n+   throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_EMPTY + \" for an empty sketch. Found: \"+ numPreLongs);\n+ }\n+ if (!isEmpty && ((numPreLongs != VO_PRELONGS_WARMUP) && (numPreLongs != VO_PRELONGS_FULL))) {\n+   throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_WARMUP + \" or \"+ VO_PRELONGS_FULL+ \" for a non-empty sketch. Found: \"+ numPreLongs);\n+ }",
                "Description": "Using guard clauses instead of nested if-else statements can make the code easier to read and understand by reducing the level of indentation and making it clear when we expect execution to stop and an exception to be thrown.",
                "Start": 9,
                "End": 46
            },
            {
                "Improvement": "Extract data validation into separate method",
                "Change_Diff": "- final int numPreLongs=getAndCheckPreLongs(srcMem);\n- final ResizeFactor rf=ResizeFactor.getRF(extractResizeFactor(srcMem));\n- final int serVer=extractSerVer(srcMem);\n- final int familyId=extractFamilyID(srcMem);\n- final int flags=extractFlags(srcMem);\n- final boolean isEmpty=(flags & EMPTY_FLAG_MASK) != 0;\n- final boolean isGadget=(flags & GADGET_FLAG_MASK) != 0;\n- // ... rest of validation code ...\n+ validateData(srcMem);",
                "Description": "The data validation code in the given method is quite large and distracts from the main logic of the method. Extracting this code into a separate method would improve readability. This also improves the method's maintainability because any changes to the validation logic can be made in one place.",
                "Start": 9,
                "End": 46
            },
            {
                "Improvement": "Use try-with-resources for Memory region",
                "Change_Diff": "- final T[] data=serDe.deserializeFromMemory(srcMem.region(offsetBytes,srcMem.getCapacity() - offsetBytes),0,totalItems);\n+ try (Memory region = srcMem.region(offsetBytes,srcMem.getCapacity() - offsetBytes)) {\n+   final T[] data=serDe.deserializeFromMemory(region,0,totalItems);\n+ }",
                "Description": "srcMem.region(...) returns a new Memory instance that should be closed to release its resources when it is no longer needed. Using a try-with-resources statement can ensure that these resources are released, even if an exception is thrown.",
                "Start": 97,
                "End": 97
            }
        ],
        "Final code": "public static <T>VarOptItemsSketch<T> heapify(final Memory srcMem,final ArrayOfItemsSerDe<T> serDe){\n  validateData(srcMem);\n  // ... rest of method after validation ...\n  try (Memory region = srcMem.region(offsetBytes,srcMem.getCapacity() - offsetBytes)) {\n    final T[] data=serDe.deserializeFromMemory(region,0,totalItems);\n  }\n  // ... rest of method after try-with-resources ...\n}"
    },
    "Old_Method": "/** \n * Returns a sketch instance of this class from the given srcMem, which must be a Memory representation of this sketch class.\n * @param < T >    The type of item this sketch contains\n * @param srcMem a Memory representation of a sketch of this class.<a href=\" {@docRoot}/resources/dictionary.html#mem\">See Memory<\/a>\n * @param serDe  An instance of ArrayOfItemsSerDe\n * @return a sketch instance of this class\n */\npublic static <T>VarOptItemsSketch<T> heapify(final Memory srcMem,final ArrayOfItemsSerDe<T> serDe){\n  final int numPreLongs=getAndCheckPreLongs(srcMem);\n  final ResizeFactor rf=ResizeFactor.getRF(extractResizeFactor(srcMem));\n  final int serVer=extractSerVer(srcMem);\n  final int familyId=extractFamilyID(srcMem);\n  final int flags=extractFlags(srcMem);\n  final boolean isEmpty=(flags & EMPTY_FLAG_MASK) != 0;\n  final boolean isGadget=(flags & GADGET_FLAG_MASK) != 0;\n  if (isEmpty) {\n    if (numPreLongs != VO_PRELONGS_EMPTY) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_EMPTY + \" for an empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n else {\n    if ((numPreLongs != VO_PRELONGS_WARMUP) && (numPreLongs != VO_PRELONGS_FULL)) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_WARMUP + \" or \"+ VO_PRELONGS_FULL+ \" for a non-empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n  if (serVer != SER_VER) {\n    throw new SketchesArgumentException(\"Possible Corruption: Ser Ver must be \" + SER_VER + \": \"+ serVer);\n  }\n  final int reqFamilyId=Family.VAROPT.getID();\n  if (familyId != reqFamilyId) {\n    throw new SketchesArgumentException(\"Possible Corruption: FamilyID must be \" + reqFamilyId + \": \"+ familyId);\n  }\n  final int k=extractK(srcMem);\n  if (k < 1) {\n    throw new SketchesArgumentException(\"Possible Corruption: k must be at least 1: \" + k);\n  }\n  if (isEmpty) {\n    assert numPreLongs == Family.VAROPT.getMinPreLongs();\n    return new VarOptItemsSketch<>(k,rf);\n  }\n  final long n=extractN(srcMem);\n  if (n < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: n cannot be negative: \" + n);\n  }\n  final int hCount=extractHRegionItemCount(srcMem);\n  final int rCount=extractRRegionItemCount(srcMem);\n  if (hCount < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: H region count cannot be \" + \"negative: \" + hCount);\n  }\n  if (rCount < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: R region count cannot be \" + \"negative: \" + rCount);\n  }\n  double totalRWeight=0.0;\n  if (numPreLongs == Family.VAROPT.getMaxPreLongs()) {\n    if (rCount > 0) {\n      totalRWeight=extractTotalRWeight(srcMem);\n    }\n else {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + Family.VAROPT.getMaxPreLongs() + \" preLongs but no items in R region\");\n    }\n  }\n  final int preLongBytes=numPreLongs << 3;\n  final int totalItems=hCount + rCount;\n  int allocatedItems=k + 1;\n  if (rCount == 0) {\n    final int ceilingLgK=Util.exactLog2OfInt(Util.ceilingPowerOf2(k),\"heapify\");\n    final int minLgSize=Util.exactLog2OfInt(Util.ceilingPowerOf2(hCount),\"heapify\");\n    final int initialLgSize=SamplingUtil.startingSubMultiple(ceilingLgK,rf.lg(),Math.max(minLgSize,MIN_LG_ARR_ITEMS));\n    allocatedItems=SamplingUtil.getAdjustedSize(k,1 << initialLgSize);\n    if (allocatedItems == k) {\n      ++allocatedItems;\n    }\n  }\n  final long weightOffsetBytes=TOTAL_WEIGHT_R_DOUBLE + (rCount > 0 ? Double.BYTES : 0);\n  final ArrayList<Double> weightList=new ArrayList<>(allocatedItems);\n  final double[] wts=new double[allocatedItems];\n  srcMem.getDoubleArray(weightOffsetBytes,wts,0,hCount);\n  for (int i=0; i < hCount; ++i) {\n    if (wts[i] <= 0.0) {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + \"Non-positive weight in heapify(): \" + wts[i]);\n    }\n    weightList.add(wts[i]);\n  }\n  long markBytes=0;\n  int markCount=0;\n  ArrayList<Boolean> markList=null;\n  if (isGadget) {\n    final long markOffsetBytes=preLongBytes + ((long)hCount * Double.BYTES);\n    markBytes=ArrayOfBooleansSerDe.computeBytesNeeded(hCount);\n    markList=new ArrayList<>(allocatedItems);\n    final ArrayOfBooleansSerDe booleansSerDe=new ArrayOfBooleansSerDe();\n    final Boolean[] markArray=booleansSerDe.deserializeFromMemory(srcMem.region(markOffsetBytes,(hCount >>> 3) + 1),0,hCount);\n    for (    Boolean mark : markArray) {\n      if (mark) {\n        ++markCount;\n      }\n    }\n    markList.addAll(Arrays.asList(markArray));\n  }\n  final long offsetBytes=preLongBytes + ((long)hCount * Double.BYTES) + markBytes;\n  final T[] data=serDe.deserializeFromMemory(srcMem.region(offsetBytes,srcMem.getCapacity() - offsetBytes),0,totalItems);\n  final List<T> wrappedData=Arrays.asList(data);\n  final ArrayList<T> dataList=new ArrayList<>(allocatedItems);\n  dataList.addAll(wrappedData.subList(0,hCount));\n  if (rCount > 0) {\n    weightList.add(-1.0);\n    if (isGadget) {\n      markList.add(false);\n    }\n    for (int i=0; i < rCount; ++i) {\n      weightList.add(-1.0);\n      if (isGadget) {\n        markList.add(false);\n      }\n    }\n    dataList.add(null);\n    dataList.addAll(wrappedData.subList(hCount,totalItems));\n  }\n  final VarOptItemsSketch<T> sketch=new VarOptItemsSketch<>(dataList,weightList,k,n,allocatedItems,rf,hCount,rCount,totalRWeight);\n  if (isGadget) {\n    sketch.marks_=markList;\n    sketch.numMarksInH_=markCount;\n  }\n  return sketch;\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/sampling/VarOptItemsSketch.java",
    "Start": 11791,
    "Stop": 18243,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "heapify"
}