{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Refactor error handling into a separate method",
                "Change_Diff": "See Final Code for the updated method and new error handling method.",
                "Description": "The code has several instances of throwing 'SketchesArgumentException' for various conditions. Refactoring these into a separate method would improve readability and maintainability.",
                "Start": 13,
                "End": 53
            },
            {
                "Improvement": "Use parameterized error messages",
                "Change_Diff": "- throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_EMPTY + \" for an empty sketch. Found: \"+ numPreLongs);",
                "Description": "The error messages are currently hardcoded with concatenation. Using parameterized error messages would make the code cleaner and more maintainable.",
                "Start": 17,
                "End": 53
            },
            {
                "Improvement": "Replace manual array copying with System.arraycopy",
                "Change_Diff": "- for (int i=0; i < hCount; ++i) {\n-    if (wts[i] <= 0.0) {\n-      throw new SketchesArgumentException(\"Possible Corruption: \" + \"Non-positive weight in heapify(): \" + wts[i]);\n-    }\n-    weightList.add(wts[i]);\n-  }",
                "Description": "Manual array copying is error prone and less efficient. Java provides built-in methods for array copying, like System.arraycopy, which are faster and safer.",
                "Start": 73,
                "End": 75
            }
        ],
        "Final code": "public static <T>VarOptItemsSketch<T> heapify(final Memory srcMem,final ArrayOfItemsSerDe<T> serDe){\n  final int numPreLongs=getAndCheckPreLongs(srcMem);\n  final ResizeFactor rf=ResizeFactor.getRF(extractResizeFactor(srcMem));\n  final int serVer=extractSerVer(srcMem);\n  final int familyId=extractFamilyID(srcMem);\n  final int flags=extractFlags(srcMem);\n  final boolean isEmpty=(flags & EMPTY_FLAG_MASK) != 0;\n  final boolean isGadget=(flags & GADGET_FLAG_MASK) != 0;\n  errorHandling(isEmpty, numPreLongs, serVer, familyId);\n  final int k=extractK(srcMem);\n  errorHandlingK(k);\n  // remaining part of the code remains the same\n}\n\nprivate void errorHandling(boolean isEmpty, int numPreLongs, int serVer, int familyId) {\n  final int reqFamilyId=Family.VAROPT.getID();\n  if (isEmpty && numPreLongs != VO_PRELONGS_EMPTY) {\n    throw new SketchesArgumentException(String.format(\"Possible corruption: Must be %s for an empty sketch. Found: %s\", VO_PRELONGS_EMPTY, numPreLongs));\n  } else if (!isEmpty && (numPreLongs != VO_PRELONGS_WARMUP) && (numPreLongs != VO_PRELONGS_FULL)) {\n    throw new SketchesArgumentException(String.format(\"Possible corruption: Must be %s or %s for a non-empty sketch. Found: %s\", VO_PRELONGS_WARMUP, VO_PRELONGS_FULL, numPreLongs));\n  }\n  if (serVer != SER_VER) {\n    throw new SketchesArgumentException(String.format(\"Possible Corruption: Ser Ver must be %s: %s\", SER_VER, serVer));\n  }\n  if (familyId != reqFamilyId) {\n    throw new SketchesArgumentException(String.format(\"Possible Corruption: FamilyID must be %s: %s\", reqFamilyId, familyId));\n  }\n}\n\nprivate void errorHandlingK(int k) {\n  if (k < 1) {\n    throw new SketchesArgumentException(String.format(\"Possible Corruption: k must be at least 1: %s\", k));\n  }\n}"
    },
    "Old_Method": "/** \n * Returns a sketch instance of this class from the given srcMem, which must be a Memory representation of this sketch class.\n * @param < T >    The type of item this sketch contains\n * @param srcMem a Memory representation of a sketch of this class.<a href=\" {@docRoot}/resources/dictionary.html#mem\">See Memory<\/a>\n * @param serDe  An instance of ArrayOfItemsSerDe\n * @return a sketch instance of this class\n */\npublic static <T>VarOptItemsSketch<T> heapify(final Memory srcMem,final ArrayOfItemsSerDe<T> serDe){\n  final int numPreLongs=getAndCheckPreLongs(srcMem);\n  final ResizeFactor rf=ResizeFactor.getRF(extractResizeFactor(srcMem));\n  final int serVer=extractSerVer(srcMem);\n  final int familyId=extractFamilyID(srcMem);\n  final int flags=extractFlags(srcMem);\n  final boolean isEmpty=(flags & EMPTY_FLAG_MASK) != 0;\n  final boolean isGadget=(flags & GADGET_FLAG_MASK) != 0;\n  if (isEmpty) {\n    if (numPreLongs != VO_PRELONGS_EMPTY) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_EMPTY + \" for an empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n else {\n    if ((numPreLongs != VO_PRELONGS_WARMUP) && (numPreLongs != VO_PRELONGS_FULL)) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_WARMUP + \" or \"+ VO_PRELONGS_FULL+ \" for a non-empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n  if (serVer != SER_VER) {\n    throw new SketchesArgumentException(\"Possible Corruption: Ser Ver must be \" + SER_VER + \": \"+ serVer);\n  }\n  final int reqFamilyId=Family.VAROPT.getID();\n  if (familyId != reqFamilyId) {\n    throw new SketchesArgumentException(\"Possible Corruption: FamilyID must be \" + reqFamilyId + \": \"+ familyId);\n  }\n  final int k=extractK(srcMem);\n  if (k < 1) {\n    throw new SketchesArgumentException(\"Possible Corruption: k must be at least 1: \" + k);\n  }\n  if (isEmpty) {\n    assert numPreLongs == Family.VAROPT.getMinPreLongs();\n    return new VarOptItemsSketch<>(k,rf);\n  }\n  final long n=extractN(srcMem);\n  if (n < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: n cannot be negative: \" + n);\n  }\n  final int hCount=extractHRegionItemCount(srcMem);\n  final int rCount=extractRRegionItemCount(srcMem);\n  if (hCount < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: H region count cannot be \" + \"negative: \" + hCount);\n  }\n  if (rCount < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: R region count cannot be \" + \"negative: \" + rCount);\n  }\n  double totalRWeight=0.0;\n  if (numPreLongs == Family.VAROPT.getMaxPreLongs()) {\n    if (rCount > 0) {\n      totalRWeight=extractTotalRWeight(srcMem);\n    }\n else {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + Family.VAROPT.getMaxPreLongs() + \" preLongs but no items in R region\");\n    }\n  }\n  final int preLongBytes=numPreLongs << 3;\n  final int totalItems=hCount + rCount;\n  int allocatedItems=k + 1;\n  if (rCount == 0) {\n    final int ceilingLgK=Util.exactLog2OfInt(Util.ceilingPowerOf2(k),\"heapify\");\n    final int minLgSize=Util.exactLog2OfInt(Util.ceilingPowerOf2(hCount),\"heapify\");\n    final int initialLgSize=SamplingUtil.startingSubMultiple(ceilingLgK,rf.lg(),Math.max(minLgSize,MIN_LG_ARR_ITEMS));\n    allocatedItems=SamplingUtil.getAdjustedSize(k,1 << initialLgSize);\n    if (allocatedItems == k) {\n      ++allocatedItems;\n    }\n  }\n  final long weightOffsetBytes=TOTAL_WEIGHT_R_DOUBLE + (rCount > 0 ? Double.BYTES : 0);\n  final ArrayList<Double> weightList=new ArrayList<>(allocatedItems);\n  final double[] wts=new double[allocatedItems];\n  srcMem.getDoubleArray(weightOffsetBytes,wts,0,hCount);\n  for (int i=0; i < hCount; ++i) {\n    if (wts[i] <= 0.0) {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + \"Non-positive weight in heapify(): \" + wts[i]);\n    }\n    weightList.add(wts[i]);\n  }\n  long markBytes=0;\n  int markCount=0;\n  ArrayList<Boolean> markList=null;\n  if (isGadget) {\n    final long markOffsetBytes=preLongBytes + ((long)hCount * Double.BYTES);\n    markBytes=ArrayOfBooleansSerDe.computeBytesNeeded(hCount);\n    markList=new ArrayList<>(allocatedItems);\n    final ArrayOfBooleansSerDe booleansSerDe=new ArrayOfBooleansSerDe();\n    final Boolean[] markArray=booleansSerDe.deserializeFromMemory(srcMem.region(markOffsetBytes,(hCount >>> 3) + 1),0,hCount);\n    for (    Boolean mark : markArray) {\n      if (mark) {\n        ++markCount;\n      }\n    }\n    markList.addAll(Arrays.asList(markArray));\n  }\n  final long offsetBytes=preLongBytes + ((long)hCount * Double.BYTES) + markBytes;\n  final T[] data=serDe.deserializeFromMemory(srcMem.region(offsetBytes,srcMem.getCapacity() - offsetBytes),0,totalItems);\n  final List<T> wrappedData=Arrays.asList(data);\n  final ArrayList<T> dataList=new ArrayList<>(allocatedItems);\n  dataList.addAll(wrappedData.subList(0,hCount));\n  if (rCount > 0) {\n    weightList.add(-1.0);\n    if (isGadget) {\n      markList.add(false);\n    }\n    for (int i=0; i < rCount; ++i) {\n      weightList.add(-1.0);\n      if (isGadget) {\n        markList.add(false);\n      }\n    }\n    dataList.add(null);\n    dataList.addAll(wrappedData.subList(hCount,totalItems));\n  }\n  final VarOptItemsSketch<T> sketch=new VarOptItemsSketch<>(dataList,weightList,k,n,allocatedItems,rf,hCount,rCount,totalRWeight);\n  if (isGadget) {\n    sketch.marks_=markList;\n    sketch.numMarksInH_=markCount;\n  }\n  return sketch;\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/sampling/VarOptItemsSketch.java",
    "Start": 11791,
    "Stop": 18243,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "heapify"
}