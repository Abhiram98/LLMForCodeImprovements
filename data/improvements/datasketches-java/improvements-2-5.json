{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Avoid using magic numbers",
                "Change_Diff": "- final int lgWaves=Math.max(lgTotTrials - 10,0);\n+ final int DEFAULT_WAVES = 10;\n+ final int lgWaves=Math.max(lgTotTrials - DEFAULT_WAVES,0);\n\n- for (int w=0; w < (1 << lgWaves); w++) {\n+ final int DEFAULT_WAVES_SHIFT = 1 << lgWaves;\n+ for (int w=0; w < DEFAULT_WAVES_SHIFT; w++) {\n\n- final double avgC=(1.0 * totalC) / totalTrials;\n+ final double DEFAULT_AVERAGE = 1.0;\n+ final double avgC=(DEFAULT_AVERAGE * totalC) / totalTrials;",
                "Description": "In the code, magic numbers like 10, 1 << lgWaves, 1.0, 2.0, 4.0, etc., are used. This makes the code harder to understand and maintain. It would be better to replace these magic numbers with named constants.",
                "Start": 7,
                "End": 116
            },
            {
                "Improvement": "Avoid repeated code",
                "Change_Diff": "- for (int trial=0; trial < trialsPerWave; trial++) {\n- ...\n- }\n\n+ private void performTrialOperation(int trialsPerWave, Operation operation) {\n+     for (int trial=0; trial < trialsPerWave; trial++) {\n+         operation.execute(trial);\n+     }\n+ }\n\n- for (int trial=0; trial < trialsPerWave; trial++) {\n-     ...\n- }\n\n+ performTrialOperation(trialsPerWave, trial -> {...});",
                "Description": "The same for loop structure is repeated multiple times in the code. It would be better to extract this pattern into a separate method, which will make the code more concise, easier to understand, and less error-prone.",
                "Start": 19,
                "End": 113
            }
        ],
        "Final code": "private void doTrialsAtLgKAtN(final int lgK,final long n,final int totalTrials){\n  final int k=1 << lgK;\n  final int minNK=(int)((k < n) ? k : n);\n  final double nOverK=(double)n / k;\n  final int lgTotTrials=Integer.numberOfTrailingZeros(totalTrials);\n  final int DEFAULT_WAVES = 10;\n  final int lgWaves=Math.max(lgTotTrials - DEFAULT_WAVES,0);\n  final int trialsPerWave=1 << (lgTotTrials - lgWaves);\n  streamSketches=new CpcSketch[trialsPerWave];\n  compressedStates1=new CompressedState[trialsPerWave];\n  memoryArr=new WritableMemory[trialsPerWave];\n  compressedStates2=new CompressedState[trialsPerWave];\n  unCompressedSketches=new CpcSketch[trialsPerWave];\n  long totalC=0;\n  long totalW=0;\n  long sumCtor_nS=0;\n  long sumUpd_nS=0;\n  long sumCom_nS=0;\n  long sumSer_nS=0;\n  long sumDes_nS=0;\n  long sumUnc_nS=0;\n  long sumEqu_nS=0;\n  long nanoStart, nanoEnd;\n  final long start=System.currentTimeMillis();\n  final int DEFAULT_WAVES_SHIFT = 1 << lgWaves;\n  for (int w=0; w < DEFAULT_WAVES_SHIFT; w++) {\n    nanoStart=System.nanoTime();\n    performTrialOperation(trialsPerWave, trial -> {\n      final CpcSketch sketch=new CpcSketch(lgK);\n      streamSketches[trial]=sketch;\n    });\n    nanoEnd=System.nanoTime();\n    sumCtor_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    performTrialOperation(trialsPerWave, trial -> {\n      final CpcSketch sketch=streamSketches[trial];\n      for (long i=0; i < n; i++) {\n        sketch.update(vIn+=INVERSE_GOLDEN_U64);\n      }\n    });\n    nanoEnd=System.nanoTime();\n    sumUpd_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    performTrialOperation(trialsPerWave, trial -> {\n      final CpcSketch sketch=streamSketches[trial];\n      final CompressedState state=CompressedState.compress(sketch);\n      compressedStates1[trial]=state;\n      totalC+=sketch.numCoupons;\n      totalW+=state.csvLengthInts + state.cwLengthInts;\n    });\n    nanoEnd=System.nanoTime();\n    sumCom_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    performTrialOperation(trialsPerWave, trial -> {\n      final CompressedState state=compressedStates1[trial];\n      final long cap=state.getRequiredSerializedBytes();\n      final WritableMemory wmem=WritableMemory.allocate((int)cap);\n      state.exportToMemory(wmem);\n      memoryArr[trial]=wmem;\n    });\n    nanoEnd=System.nanoTime();\n    sumSer_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    performTrialOperation(trialsPerWave, trial -> {\n      final Memory mem=memoryArr[trial];\n      final CompressedState state=importFromMemory(mem);\n      compressedStates2[trial]=state;\n    });\n    nanoEnd=System.nanoTime();\n    sumDes_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    performTrialOperation(trialsPerWave, trial -> {\n      final CompressedState state=compressedStates2[trial];\n      CpcSketch uncSk=null;\n      uncSk=CpcSketch.uncompress(state,ThetaUtil.DEFAULT_UPDATE_SEED);\n      unCompressedSketches[trial]=uncSk;\n    });\n    nanoEnd=System.nanoTime();\n    sumUnc_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    performTrialOperation(trialsPerWave, trial -> {\n      rtAssert(TestUtil.specialEquals(streamSketches[trial],unCompressedSketches[trial],false,false));\n    });\n    nanoEnd=System.nanoTime();\n    sumEqu_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n  }\n  final double total_S=(System.currentTimeMillis() - start) / 1E3;\n  final double DEFAULT_AVERAGE = 1.0;\n  final double avgC=(DEFAULT_AVERAGE * totalC) / totalTrials;\n  final double avgCoK=avgC / k;\n  final double avgWords=(DEFAULT_AVERAGE * totalW) / totalTrials;\n  final double avgBytes=(4.0 * totalW) / totalTrials;\n  final double avgCtor_nS=Math.round((double)sumCtor_nS / totalTrials);\n  final double avgUpd_nS=Math.round((double)sumUpd_nS / totalTrials);\n  final double avgUpd_nSperN=avgUpd_nS / n;\n  final double avgCom_nS=Math.round((double)sumCom_nS / totalTrials);\n  final double avgCom_nSper2C=avgCom_nS / (2.0 * avgC);\n  final double avgCom_nSperK=avgCom_nS / k;\n  final double avgSer_nS=Math.round((double)sumSer_nS / totalTrials);\n  final double avgSer_nSperW=avgSer_nS / avgWords;\n  final double avgDes_nS=Math.round((double)sumDes_nS / totalTrials);\n  final double avgDes_nSperW=avgDes_nS / avgWords;\n  final double avgUnc_nS=Math.round((double)sumUnc_nS / totalTrials);\n  final double avgUnc_nSper2C=avgUnc_nS / (2.0 * avgC);\n  final double avgUnc_nSperK=avgUnc_nS / k;\n  final double avgEqu_nS=Math.round((double)sumEqu_nS / totalTrials);\n  final double avgEqu_nSperMinNK=avgEqu_nS / minNK;\n  final int len=unCompressedSketches.length;\n  final Flavor finFlavor=unCompressedSketches[len - 1].getFlavor();\n  final String offStr=Integer.toString(unCompressedSketches[len - 1].windowOffset);\n  final String flavorOff=finFlavor.toString() + String.format(\"%2s\",offStr);\n  printf(dfmt,lgK,totalTrials,n,minNK,avgCoK,flavorOff,nOverK,avgBytes,avgCtor_nS,avgUpd_nS,avgCom_nS,avgSer_nS,avgDes_nS,avgUnc_nS,avgEqu_nS,avgUpd_nSperN,avgCom_nSper2C,avgCom_nSperK,avgSer_nSperW,avgDes_nSperW,avgUnc_nSper2C,avgUnc_nSperK,avgEqu_nSperMinNK,total_S);\n}\n\nprivate void performTrialOperation(int trialsPerWave, Operation operation) {\n  for (int trial=0; trial < trialsPerWave; trial++) {\n    operation.execute(trial);\n  }\n}\n\ninterface Operation {\n  void execute(int trial);\n}"
    },
    "Old_Method": "private void doTrialsAtLgKAtN(final int lgK,final long n,final int totalTrials){\n  final int k=1 << lgK;\n  final int minNK=(int)((k < n) ? k : n);\n  final double nOverK=(double)n / k;\n  final int lgTotTrials=Integer.numberOfTrailingZeros(totalTrials);\n  final int lgWaves=Math.max(lgTotTrials - 10,0);\n  final int trialsPerWave=1 << (lgTotTrials - lgWaves);\n  streamSketches=new CpcSketch[trialsPerWave];\n  compressedStates1=new CompressedState[trialsPerWave];\n  memoryArr=new WritableMemory[trialsPerWave];\n  compressedStates2=new CompressedState[trialsPerWave];\n  unCompressedSketches=new CpcSketch[trialsPerWave];\n  long totalC=0;\n  long totalW=0;\n  long sumCtor_nS=0;\n  long sumUpd_nS=0;\n  long sumCom_nS=0;\n  long sumSer_nS=0;\n  long sumDes_nS=0;\n  long sumUnc_nS=0;\n  long sumEqu_nS=0;\n  long nanoStart, nanoEnd;\n  final long start=System.currentTimeMillis();\n  for (int w=0; w < (1 << lgWaves); w++) {\n    nanoStart=System.nanoTime();\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=new CpcSketch(lgK);\n      streamSketches[trial]=sketch;\n    }\n    nanoEnd=System.nanoTime();\n    sumCtor_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=streamSketches[trial];\n      for (long i=0; i < n; i++) {\n        sketch.update(vIn+=INVERSE_GOLDEN_U64);\n      }\n    }\n    nanoEnd=System.nanoTime();\n    sumUpd_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=streamSketches[trial];\n      final CompressedState state=CompressedState.compress(sketch);\n      compressedStates1[trial]=state;\n      totalC+=sketch.numCoupons;\n      totalW+=state.csvLengthInts + state.cwLengthInts;\n    }\n    nanoEnd=System.nanoTime();\n    sumCom_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CompressedState state=compressedStates1[trial];\n      final long cap=state.getRequiredSerializedBytes();\n      final WritableMemory wmem=WritableMemory.allocate((int)cap);\n      state.exportToMemory(wmem);\n      memoryArr[trial]=wmem;\n    }\n    nanoEnd=System.nanoTime();\n    sumSer_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final Memory mem=memoryArr[trial];\n      final CompressedState state=importFromMemory(mem);\n      compressedStates2[trial]=state;\n    }\n    nanoEnd=System.nanoTime();\n    sumDes_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CompressedState state=compressedStates2[trial];\n      CpcSketch uncSk=null;\n      uncSk=CpcSketch.uncompress(state,ThetaUtil.DEFAULT_UPDATE_SEED);\n      unCompressedSketches[trial]=uncSk;\n    }\n    nanoEnd=System.nanoTime();\n    sumUnc_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      rtAssert(TestUtil.specialEquals(streamSketches[trial],unCompressedSketches[trial],false,false));\n    }\n    nanoEnd=System.nanoTime();\n    sumEqu_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n  }\n  final double total_S=(System.currentTimeMillis() - start) / 1E3;\n  final double avgC=(1.0 * totalC) / totalTrials;\n  final double avgCoK=avgC / k;\n  final double avgWords=(1.0 * totalW) / totalTrials;\n  final double avgBytes=(4.0 * totalW) / totalTrials;\n  final double avgCtor_nS=Math.round((double)sumCtor_nS / totalTrials);\n  final double avgUpd_nS=Math.round((double)sumUpd_nS / totalTrials);\n  final double avgUpd_nSperN=avgUpd_nS / n;\n  final double avgCom_nS=Math.round((double)sumCom_nS / totalTrials);\n  final double avgCom_nSper2C=avgCom_nS / (2.0 * avgC);\n  final double avgCom_nSperK=avgCom_nS / k;\n  final double avgSer_nS=Math.round((double)sumSer_nS / totalTrials);\n  final double avgSer_nSperW=avgSer_nS / avgWords;\n  final double avgDes_nS=Math.round((double)sumDes_nS / totalTrials);\n  final double avgDes_nSperW=avgDes_nS / avgWords;\n  final double avgUnc_nS=Math.round((double)sumUnc_nS / totalTrials);\n  final double avgUnc_nSper2C=avgUnc_nS / (2.0 * avgC);\n  final double avgUnc_nSperK=avgUnc_nS / k;\n  final double avgEqu_nS=Math.round((double)sumEqu_nS / totalTrials);\n  final double avgEqu_nSperMinNK=avgEqu_nS / minNK;\n  final int len=unCompressedSketches.length;\n  final Flavor finFlavor=unCompressedSketches[len - 1].getFlavor();\n  final String offStr=Integer.toString(unCompressedSketches[len - 1].windowOffset);\n  final String flavorOff=finFlavor.toString() + String.format(\"%2s\",offStr);\n  printf(dfmt,lgK,totalTrials,n,minNK,avgCoK,flavorOff,nOverK,avgBytes,avgCtor_nS,avgUpd_nS,avgCom_nS,avgSer_nS,avgDes_nS,avgUnc_nS,avgEqu_nS,avgUpd_nSperN,avgCom_nSper2C,avgCom_nSperK,avgSer_nSperW,avgDes_nSperW,avgUnc_nSper2C,avgUnc_nSperK,avgEqu_nSperMinNK,total_S);\n}\n",
    "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/cpc/CompressionCharacterization.java",
    "Start": 3877,
    "Stop": 9810,
    "Project_Name": "data/projects/datasketches-java",
    "Method_Name": "doTrialsAtLgKAtN"
}