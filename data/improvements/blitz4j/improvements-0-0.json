{
    "Method_Improvements": {
        "Improvements": [{
            "Improvement": "Use a constructor to initialize all fields",
            "Change_Diff": "- public MessageBatcher(String name,MessageProcessor target){\n-   this.name=BATCHER_PREFIX + name;\n-   this.target=target;\n-   queue=new ArrayBlockingQueue<T>(CONFIGURATION.getBatcherQueueMaxMessages(this.name));\n-   setBatchMaxMessages(CONFIGURATION.getBatchSize(this.name));\n-   batch=new ArrayList<Object>(maxMessages);\n-   setBatchMaxDelay(CONFIGURATION.getBatcherMaxDelay(this.name));\n-   collector=new Collector(this,this.name + COLLECTOR_SUFFIX);\n-   createProcessor(this.name);\n-   queueSizeTracer=Monitors.newTimer(\"queue_size\");\n-   batchSyncPutTracer=Monitors.newTimer(\"waitTimeforBuffer\");\n-   avgBatchSizeTracer=Monitors.newTimer(\"batch_size\");\n-   processCount=Monitors.newCounter(\"messages_processed\");\n-   threadSubmitTracer=Monitors.newTimer(\"thread_invocation_time\");\n-   processTimeTracer=Monitors.newTimer(\"message_processTime\");\n-   queueOverflowCounter=Monitors.newCounter(\"queue_overflow\");\n-   blockingProperty=CONFIGURATION.shouldWaitWhenBatcherQueueNotEmpty(this.name);\n-   collector.setDaemon(true);\n-   collector.start();\n-   try {\n-     Monitors.registerObject(this.name,this);\n-   }\n-  catch (  Throwable e) {\n-     if (CONFIGURATION.shouldPrintLoggingErrors()) {\n-       e.printStackTrace();\n-     }\n-   }\n- }",
            "Description": "Constructor has too many responsibilities. It should only assign values to the fields. Consider moving the creation and configuration of objects like queue and batch to separate methods and call those methods in the constructor.",
            "Start": 1,
            "End": 30
        }],
        "Final code": "public MessageBatcher(String name,MessageProcessor target){\n  initFields(name, target);\n  setupQueueAndBatch();\n  initMonitor();\n  startCollector();\n}\n\nprivate void initFields(String name, MessageProcessor target) {\n  this.name=BATCHER_PREFIX + name;\n  this.target=target;\n  blockingProperty=CONFIGURATION.shouldWaitWhenBatcherQueueNotEmpty(this.name);\n}\n\nprivate void setupQueueAndBatch() {\n  queue=new ArrayBlockingQueue<T>(CONFIGURATION.getBatcherQueueMaxMessages(this.name));\n  setBatchMaxMessages(CONFIGURATION.getBatchSize(this.name));\n  batch=new ArrayList<Object>(maxMessages);\n  setBatchMaxDelay(CONFIGURATION.getBatcherMaxDelay(this.name));\n  collector=new Collector(this,this.name + COLLECTOR_SUFFIX);\n  createProcessor(this.name);\n}\n\nprivate void initMonitor() {\n  queueSizeTracer=Monitors.newTimer(\"queue_size\");\n  batchSyncPutTracer=Monitors.newTimer(\"waitTimeforBuffer\");\n  avgBatchSizeTracer=Monitors.newTimer(\"batch_size\");\n  processCount=Monitors.newCounter(\"messages_processed\");\n  threadSubmitTracer=Monitors.newTimer(\"thread_invocation_time\");\n  processTimeTracer=Monitors.newTimer(\"message_processTime\");\n  queueOverflowCounter=Monitors.newCounter(\"queue_overflow\");\n  try {\n    Monitors.registerObject(this.name,this);\n  }\n  catch (  Throwable e) {\n    if (CONFIGURATION.shouldPrintLoggingErrors()) {\n      e.printStackTrace();\n    }\n  }\n}\n\nprivate void startCollector() {\n  collector.setDaemon(true);\n  collector.start();\n}"
    },
    "Old_Method": "public MessageBatcher(String name,MessageProcessor target){\n  this.name=BATCHER_PREFIX + name;\n  this.target=target;\n  queue=new ArrayBlockingQueue<T>(CONFIGURATION.getBatcherQueueMaxMessages(this.name));\n  setBatchMaxMessages(CONFIGURATION.getBatchSize(this.name));\n  batch=new ArrayList<Object>(maxMessages);\n  setBatchMaxDelay(CONFIGURATION.getBatcherMaxDelay(this.name));\n  collector=new Collector(this,this.name + COLLECTOR_SUFFIX);\n  createProcessor(this.name);\n  queueSizeTracer=Monitors.newTimer(\"queue_size\");\n  batchSyncPutTracer=Monitors.newTimer(\"waitTimeforBuffer\");\n  avgBatchSizeTracer=Monitors.newTimer(\"batch_size\");\n  processCount=Monitors.newCounter(\"messages_processed\");\n  threadSubmitTracer=Monitors.newTimer(\"thread_invocation_time\");\n  processTimeTracer=Monitors.newTimer(\"message_processTime\");\n  queueOverflowCounter=Monitors.newCounter(\"queue_overflow\");\n  blockingProperty=CONFIGURATION.shouldWaitWhenBatcherQueueNotEmpty(this.name);\n  collector.setDaemon(true);\n  collector.start();\n  try {\n    Monitors.registerObject(this.name,this);\n  }\n catch (  Throwable e) {\n    if (CONFIGURATION.shouldPrintLoggingErrors()) {\n      e.printStackTrace();\n    }\n  }\n}\n",
    "File_Path": "blitz4j/src/main/java/com/netflix/logging/messaging/MessageBatcher.java",
    "Start": 4433,
    "Stop": 5937,
    "Project_Name": "data/projects/blitz4j",
    "Method_Name": "MessageBatcher"
}