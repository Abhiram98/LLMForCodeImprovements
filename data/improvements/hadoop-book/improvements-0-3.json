{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Replace System.out.println with Logger",
                "Change_Diff": "- System.out.println(...)\n+ LOGGER.log(Level.INFO, ...)",
                "Description": "System.out.println() is not very flexible. It's always a good idea to use a fully featured logger, which can be configured to write to different outputs, can be turned off or set to different levels of severity. It also provides more context (e.g. timestamps), and can be filtered and searched in your log files.",
                "Start": 47,
                "End": 74
            },
            {
                "Improvement": "Handle exceptions properly",
                "Change_Diff": "- catch (...) {\n-   System.out.println(...);\n-   return printUsage();\n+   catch (...) {\n+   LOGGER.log(Level.ERROR, ...);\n+   throw new CustomException(...);",
                "Description": "Instead of just printing the error message, you should also handle exceptions properly. This might include logging the error, or re-throwing it up the stack. In this case, it might be appropriate to wrap the exceptions in a custom exception that provides more information about the nature of the failure.",
                "Start": 38,
                "End": 42
            },
            {
                "Improvement": "Use try-with-resources for JobClient",
                "Change_Diff": "- JobClient client=new JobClient(jobConf);\n+ try (JobClient client=new JobClient(jobConf)) {",
                "Description": "Java 7 introduced the try-with-resources statement, which ensures that each resource is closed at the end of the statement. This can be used here to ensure that the JobClient is closed.",
                "Start": 6,
                "End": 6
            }
        ],
        "Final code": "public int run(String[] args) throws Exception {\n  JobConf jobConf=new JobConf(getConf(),Sort.class);\n  jobConf.setJobName(\"sorter\");\n  jobConf.setMapperClass(IdentityMapper.class);\n  jobConf.setReducerClass(IdentityReducer.class);\n  try (JobClient client=new JobClient(jobConf)) {\n    ...\n    try {\n      ...\n    } catch (NumberFormatException except) {\n      LOGGER.log(Level.ERROR, \"Integer expected instead of \" + args[i], except);\n      throw new IllegalArgumentException(\"Integer expected instead of \" + args[i], except);\n    } catch (ArrayIndexOutOfBoundsException except) {\n      LOGGER.log(Level.ERROR, \"Required parameter missing from \" + args[i - 1], except);\n      throw new IllegalArgumentException(\"Required parameter missing from \" + args[i - 1], except);\n    }\n    ...\n    if (otherArgs.size() != 2) {\n      LOGGER.log(Level.ERROR, \"Wrong number of parameters: \" + otherArgs.size() + \" instead of 2.\");\n      return printUsage();\n    }\n    ...\n    LOGGER.log(Level.INFO, \"Running on \" + cluster.getTaskTrackers() + \" nodes to sort from \"+ FileInputFormat.getInputPaths(jobConf)[0]+ \" into \"+ FileOutputFormat.getOutputPath(jobConf)+ \" with \"+ num_reduces+ \" reduces.\");\n    Date startTime=new Date();\n    LOGGER.log(Level.INFO, \"Job started: \" + startTime);\n    jobResult=JobClient.runJob(jobConf);\n    Date end_time=new Date();\n    LOGGER.log(Level.INFO, \"Job ended: \" + end_time);\n    LOGGER.log(Level.INFO, \"The job took \" + (end_time.getTime() - startTime.getTime()) / 1000 + \" seconds.\");\n  }\n  return 0;\n}"
    },
    "Old_Method": "/** \n * The main driver for sort program. Invoke this method to submit the map/reduce job.\n * @throws IOException When there is communication problems with the job tracker.\n */\npublic int run(String[] args) throws Exception {\n  JobConf jobConf=new JobConf(getConf(),Sort.class);\n  jobConf.setJobName(\"sorter\");\n  jobConf.setMapperClass(IdentityMapper.class);\n  jobConf.setReducerClass(IdentityReducer.class);\n  JobClient client=new JobClient(jobConf);\n  ClusterStatus cluster=client.getClusterStatus();\n  int num_reduces=(int)(cluster.getMaxReduceTasks() * 0.9);\n  String sort_reduces=jobConf.get(\"test.sort.reduces_per_host\");\n  if (sort_reduces != null) {\n    num_reduces=cluster.getTaskTrackers() * Integer.parseInt(sort_reduces);\n  }\n  Class<? extends InputFormat> inputFormatClass=SequenceFileInputFormat.class;\n  Class<? extends OutputFormat> outputFormatClass=SequenceFileOutputFormat.class;\n  Class<? extends WritableComparable> outputKeyClass=BytesWritable.class;\n  Class<? extends Writable> outputValueClass=BytesWritable.class;\n  List<String> otherArgs=new ArrayList<String>();\n  InputSampler.Sampler<K,V> sampler=null;\n  for (int i=0; i < args.length; ++i) {\n    try {\n      if (\"-m\".equals(args[i])) {\n        jobConf.setNumMapTasks(Integer.parseInt(args[++i]));\n      }\n else       if (\"-r\".equals(args[i])) {\n        num_reduces=Integer.parseInt(args[++i]);\n      }\n else       if (\"-inFormat\".equals(args[i])) {\n        inputFormatClass=Class.forName(args[++i]).asSubclass(InputFormat.class);\n      }\n else       if (\"-outFormat\".equals(args[i])) {\n        outputFormatClass=Class.forName(args[++i]).asSubclass(OutputFormat.class);\n      }\n else       if (\"-outKey\".equals(args[i])) {\n        outputKeyClass=Class.forName(args[++i]).asSubclass(WritableComparable.class);\n      }\n else       if (\"-outValue\".equals(args[i])) {\n        outputValueClass=Class.forName(args[++i]).asSubclass(Writable.class);\n      }\n else       if (\"-totalOrder\".equals(args[i])) {\n        double pcnt=Double.parseDouble(args[++i]);\n        int numSamples=Integer.parseInt(args[++i]);\n        int maxSplits=Integer.parseInt(args[++i]);\n        if (0 >= maxSplits)         maxSplits=Integer.MAX_VALUE;\n        sampler=new InputSampler.RandomSampler<K,V>(pcnt,numSamples,maxSplits);\n      }\n else {\n        otherArgs.add(args[i]);\n      }\n    }\n catch (    NumberFormatException except) {\n      System.out.println(\"ERROR: Integer expected instead of \" + args[i]);\n      return printUsage();\n    }\ncatch (    ArrayIndexOutOfBoundsException except) {\n      System.out.println(\"ERROR: Required parameter missing from \" + args[i - 1]);\n      return printUsage();\n    }\n  }\n  jobConf.setNumReduceTasks(num_reduces);\n  jobConf.setInputFormat(inputFormatClass);\n  jobConf.setOutputFormat(outputFormatClass);\n  jobConf.setOutputKeyClass(outputKeyClass);\n  jobConf.setOutputValueClass(outputValueClass);\n  if (otherArgs.size() != 2) {\n    System.out.println(\"ERROR: Wrong number of parameters: \" + otherArgs.size() + \" instead of 2.\");\n    return printUsage();\n  }\n  FileInputFormat.setInputPaths(jobConf,otherArgs.get(0));\n  FileOutputFormat.setOutputPath(jobConf,new Path(otherArgs.get(1)));\n  if (sampler != null) {\n    System.out.println(\"Sampling input to effect total-order sort...\");\n    jobConf.setPartitionerClass(TotalOrderPartitioner.class);\n    Path inputDir=FileInputFormat.getInputPaths(jobConf)[0];\n    inputDir=inputDir.makeQualified(inputDir.getFileSystem(jobConf));\n    Path partitionFile=new Path(inputDir,\"_sortPartitioning\");\n    TotalOrderPartitioner.setPartitionFile(jobConf,partitionFile);\n    InputSampler.<K,V>writePartitionFile(jobConf,sampler);\n    URI partitionUri=new URI(partitionFile.toString() + \"#\" + \"_sortPartitioning\");\n    DistributedCache.addCacheFile(partitionUri,jobConf);\n    DistributedCache.createSymlink(jobConf);\n  }\n  System.out.println(\"Running on \" + cluster.getTaskTrackers() + \" nodes to sort from \"+ FileInputFormat.getInputPaths(jobConf)[0]+ \" into \"+ FileOutputFormat.getOutputPath(jobConf)+ \" with \"+ num_reduces+ \" reduces.\");\n  Date startTime=new Date();\n  System.out.println(\"Job started: \" + startTime);\n  jobResult=JobClient.runJob(jobConf);\n  Date end_time=new Date();\n  System.out.println(\"Job ended: \" + end_time);\n  System.out.println(\"The job took \" + (end_time.getTime() - startTime.getTime()) / 1000 + \" seconds.\");\n  return 0;\n}\n",
    "File_Path": "hadoop-book/src/main/java/com/hadoopilluminated/examples/Sort.java",
    "Start": 2959,
    "Stop": 7891,
    "Project_Name": "data/projects/hadoop-book",
    "Method_Name": "run"
}