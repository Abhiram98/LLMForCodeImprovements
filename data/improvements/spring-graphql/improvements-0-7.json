{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Use Java Optional instead of null",
                "Change_Diff": "- return null;\n+ return Optional.empty();",
                "Description": "Instead of returning null when no mapping is found, it would be better to use Java Optional. It can clearly tell the caller of the method that there might not be any returned value.",
                "Start": 4,
                "End": 4
            },
            {
                "Improvement": "Move the 'SourceMethodArgumentResolver' check to a separate method",
                "Change_Diff": "- if (resolver instanceof SourceMethodArgumentResolver) {\n-     typeName=parameter.getParameterType().getSimpleName();\n-     break;\n- }\n+ typeName = getTypeNameIfSourceMethodArgumentResolver(resolver, parameter);",
                "Description": "The check for whether the resolver is an instance of SourceMethodArgumentResolver and the subsequent assignment of typeName is a distinct operation that could be moved into a separate private method. This would make the code cleaner and more readable.",
                "Start": 28,
                "End": 33
            }
        ],
        "Final code": "@Nullable\nprivate Optional<MappingInfo> getMappingInfo(Method method, Object handler, Class<?> handlerType) {\n    Set<Annotation> annotations=AnnotatedElementUtils.findAllMergedAnnotations(method, new LinkedHashSet<>(Arrays.asList(BatchMapping.class, SchemaMapping.class)));\n    if (annotations.isEmpty()) {\n        return Optional.empty();\n    }\n    if (annotations.size() != 1) {\n        throw new IllegalArgumentException(\"Expected either @BatchMapping or @SchemaMapping, not both: \" + method.toGenericString());\n    }\n    String typeName;\n    String field;\n    boolean batchMapping=false;\n    int batchSize=-1;\n    HandlerMethod handlerMethod=createHandlerMethod(method,handler,handlerType);\n    Annotation annotation=annotations.iterator().next();\n    if (annotation instanceof SchemaMapping) {\n        typeName=mapping.typeName();\n        field=(StringUtils.hasText(mapping.field()) ? mapping.field() : method.getName());\n    }\n    else {\n        BatchMapping mapping=(BatchMapping)annotation;\n        typeName=mapping.typeName();\n        field=(StringUtils.hasText(mapping.field()) ? mapping.field() : method.getName());\n        batchMapping=true;\n        batchSize=mapping.maxBatchSize();\n    }\n    if (!StringUtils.hasText(typeName)) {\n        SchemaMapping mapping=AnnotatedElementUtils.findMergedAnnotation(handlerType,SchemaMapping.class);\n        if (mapping != null) {\n            typeName=mapping.typeName();\n        }\n    }\n    if (!StringUtils.hasText(typeName)) {\n        for (MethodParameter parameter : handlerMethod.getMethodParameters()) {\n            if (!batchMapping) {\n                Assert.state(this.argumentResolvers != null,\"`argumentResolvers` is not initialized\");\n                HandlerMethodArgumentResolver resolver=this.argumentResolvers.getArgumentResolver(parameter);\n                typeName = getTypeNameIfSourceMethodArgumentResolver(resolver, parameter);\n            }\n            else {\n                if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\n                    typeName=parameter.nested().getNestedParameterType().getSimpleName();\n                    break;\n                }\n            }\n        }\n    }\n    Assert.hasText(typeName,\"No parentType specified, and a source/parent method argument was also not found: \" + handlerMethod.getShortLogMessage());\n    return Optional.of(new MappingInfo(typeName,field,batchMapping,batchSize,handlerMethod));\n}\n\nprivate String getTypeNameIfSourceMethodArgumentResolver(HandlerMethodArgumentResolver resolver, MethodParameter parameter) {\n    if (resolver instanceof SourceMethodArgumentResolver) {\n        return parameter.getParameterType().getSimpleName();\n    }\n    return null;\n}"
    },
    "Old_Method": "@Nullable private MappingInfo getMappingInfo(Method method,Object handler,Class<?> handlerType){\n  Set<Annotation> annotations=AnnotatedElementUtils.findAllMergedAnnotations(method,new LinkedHashSet<>(Arrays.asList(BatchMapping.class,SchemaMapping.class)));\n  if (annotations.isEmpty()) {\n    return null;\n  }\n  if (annotations.size() != 1) {\n    throw new IllegalArgumentException(\"Expected either @BatchMapping or @SchemaMapping, not both: \" + method.toGenericString());\n  }\n  String typeName;\n  String field;\n  boolean batchMapping=false;\n  int batchSize=-1;\n  HandlerMethod handlerMethod=createHandlerMethod(method,handler,handlerType);\n  Annotation annotation=annotations.iterator().next();\n  if (annotation instanceof SchemaMapping) {\n    typeName=mapping.typeName();\n    field=(StringUtils.hasText(mapping.field()) ? mapping.field() : method.getName());\n  }\n else {\n    BatchMapping mapping=(BatchMapping)annotation;\n    typeName=mapping.typeName();\n    field=(StringUtils.hasText(mapping.field()) ? mapping.field() : method.getName());\n    batchMapping=true;\n    batchSize=mapping.maxBatchSize();\n  }\n  if (!StringUtils.hasText(typeName)) {\n    SchemaMapping mapping=AnnotatedElementUtils.findMergedAnnotation(handlerType,SchemaMapping.class);\n    if (mapping != null) {\n      typeName=mapping.typeName();\n    }\n  }\n  if (!StringUtils.hasText(typeName)) {\n    for (    MethodParameter parameter : handlerMethod.getMethodParameters()) {\n      if (!batchMapping) {\n        Assert.state(this.argumentResolvers != null,\"`argumentResolvers` is not initialized\");\n        HandlerMethodArgumentResolver resolver=this.argumentResolvers.getArgumentResolver(parameter);\n        if (resolver instanceof SourceMethodArgumentResolver) {\n          typeName=parameter.getParameterType().getSimpleName();\n          break;\n        }\n      }\n else {\n        if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\n          typeName=parameter.nested().getNestedParameterType().getSimpleName();\n          break;\n        }\n      }\n    }\n  }\n  Assert.hasText(typeName,\"No parentType specified, and a source/parent method argument was also not found: \" + handlerMethod.getShortLogMessage());\n  return new MappingInfo(typeName,field,batchMapping,batchSize,handlerMethod);\n}\n",
    "File_Path": "spring-graphql/spring-graphql/src/main/java/org/springframework/graphql/data/method/annotation/support/AnnotatedControllerConfigurer.java",
    "Start": 16586,
    "Stop": 18892,
    "Project_Name": "data/projects/spring-graphql",
    "Method_Name": "getMappingInfo"
}