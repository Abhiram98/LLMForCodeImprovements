{
    "Method_Improvements": {
        "Improvements": [{
            "Improvement": "Reduce nested blocks for readability",
            "Change_Diff": "- for (    Annotation annot : parameter.getParameterAnnotations()) {\n-      MergedAnnotations merged=MergedAnnotations.from(annot);\n-      if (merged.isPresent(Valid.class) || merged.isPresent(Constraint.class)) {\n-        requiresMethodValidation=true;\n-      }\n- else       if (annot.annotationType().equals(Validated.class)) {\n-        Class<?>[] groups=((Validated)annot).value();\n-        parameterValidator=(parameterValidator != null ? parameterValidator.andThen(new MethodParameterValidator(i,groups)) : new MethodParameterValidator(i,groups));\n-      }\n-    }\n+ for (Annotation annotation : parameter.getParameterAnnotations()) {\n+   if (!processAnnotation(annotation, i)) {\n+     continue;\n+   }\n+   requiresMethodValidation = true;\n+   if (annotation.annotationType().equals(Validated.class)) {\n+     Class<?>[] groups = ((Validated) annotation).value();\n+     parameterValidator = (parameterValidator != null ? parameterValidator.andThen(new MethodParameterValidator(i, groups)) : new MethodParameterValidator(i, groups));\n+   }\n+}",
            "Description": "Reduce the number of nested blocks in your code to improve readability. This can be achieved by breaking down complex logical structures into simpler, more manageable methods or by using 'continue' in 'for' loops to avoid deep nesting.",
            "Start": 24,
            "End": 40
        }],
        "Final code": "public BiConsumer<Object,Object[]> getValidationHelperFor(HandlerMethod handlerMethod){\n  boolean requiresMethodValidation=false;\n  Class<?>[] methodValidationGroups=null;\n  Validated validatedAnnotation=findAnnotation(handlerMethod,Validated.class);\n  if (validatedAnnotation != null) {\n    requiresMethodValidation=true;\n    methodValidationGroups=validatedAnnotation.value();\n  }\n else   if (findAnnotation(handlerMethod,Valid.class) != null) {\n    requiresMethodValidation=true;\n  }\n  BiConsumer<Object,Object[]> parameterValidator=null;\n  MethodParameter[] parameters=handlerMethod.getMethodParameters();\n  for (int i=0; i < parameters.length; i++) {\n    MethodParameter parameter=parameters[i];\n    for (Annotation annotation : parameter.getParameterAnnotations()) {\n      if (!processAnnotation(annotation, i)) {\n        continue;\n      }\n      requiresMethodValidation = true;\n      if (annotation.annotationType().equals(Validated.class)) {\n        Class<?>[] groups = ((Validated) annotation).value();\n        parameterValidator = (parameterValidator != null ? parameterValidator.andThen(new MethodParameterValidator(i, groups)) : new MethodParameterValidator(i, groups));\n      }\n    }\n  }\n  BiConsumer<Object,Object[]> result=(requiresMethodValidation ? new HandlerMethodValidator(handlerMethod,methodValidationGroups) : null);\n  if (parameterValidator != null) {\n    return (result != null ? result.andThen(parameterValidator) : parameterValidator);\n  }\n  return result;\n}\n\nprivate boolean processAnnotation(Annotation annotation, int index) {\n  MergedAnnotations merged = MergedAnnotations.from(annotation);\n  return merged.isPresent(Valid.class) || merged.isPresent(Constraint.class);\n}"
    },
    "Old_Method": "/** \n * Create a validation callback for the given  {@link HandlerMethod}, possibly  {@code null} if the method or the method parameters do not have{@link Validated},  {@link Valid}, or  {@link Constraint} annotations.\n */\n@Nullable public BiConsumer<Object,Object[]> getValidationHelperFor(HandlerMethod handlerMethod){\n  boolean requiresMethodValidation=false;\n  Class<?>[] methodValidationGroups=null;\n  Validated validatedAnnotation=findAnnotation(handlerMethod,Validated.class);\n  if (validatedAnnotation != null) {\n    requiresMethodValidation=true;\n    methodValidationGroups=validatedAnnotation.value();\n  }\n else   if (findAnnotation(handlerMethod,Valid.class) != null) {\n    requiresMethodValidation=true;\n  }\n  BiConsumer<Object,Object[]> parameterValidator=null;\n  MethodParameter[] parameters=handlerMethod.getMethodParameters();\n  for (int i=0; i < parameters.length; i++) {\n    MethodParameter parameter=parameters[i];\n    for (    Annotation annot : parameter.getParameterAnnotations()) {\n      MergedAnnotations merged=MergedAnnotations.from(annot);\n      if (merged.isPresent(Valid.class) || merged.isPresent(Constraint.class)) {\n        requiresMethodValidation=true;\n      }\n else       if (annot.annotationType().equals(Validated.class)) {\n        Class<?>[] groups=((Validated)annot).value();\n        parameterValidator=(parameterValidator != null ? parameterValidator.andThen(new MethodParameterValidator(i,groups)) : new MethodParameterValidator(i,groups));\n      }\n    }\n  }\n  BiConsumer<Object,Object[]> result=(requiresMethodValidation ? new HandlerMethodValidator(handlerMethod,methodValidationGroups) : null);\n  if (parameterValidator != null) {\n    return (result != null ? result.andThen(parameterValidator) : parameterValidator);\n  }\n  return result;\n}\n",
    "File_Path": "spring-graphql/spring-graphql/src/main/java/org/springframework/graphql/data/method/annotation/support/ValidationHelper.java",
    "Start": 2068,
    "Stop": 3894,
    "Project_Name": "data/projects/spring-graphql",
    "Method_Name": "getValidationHelperFor"
}