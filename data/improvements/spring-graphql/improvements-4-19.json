{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Extract anonymous inner classes to named classes",
                "Change_Diff": "- factories.put(typeName,new DataFetcherFactory(){\n-    @Override public DataFetcher<?> single(){\n-      return builder.single();\n-    }\n-    @Override public DataFetcher<?> many(){\n-      return builder.many();\n-    }\n-    @Override public DataFetcher<?> scrollable(){\n-      return builder.scrollable();\n-    }\n-  }\n-);\n+ factories.put(typeName, new CustomDataFetcherFactory(builder));",
                "Description": "Instead of using anonymous inner classes for DataFetcherFactory, consider extracting them into named classes. This will improve readability and testability of your code.",
                "Start": 17,
                "End": 27
            },
            {
                "Improvement": "Avoid code duplication",
                "Change_Diff": "- for (  QuerydslPredicateExecutor<?> executor : executors) {\n-    // code to create DataFetcherFactory\n-    factories.put(typeName, new CustomDataFetcherFactory(builder));\n- }\n- for (  ReactiveQuerydslPredicateExecutor<?> executor : reactiveExecutors) {\n-    // code to create DataFetcherFactory\n-    factories.put(typeName, new CustomDataFetcherFactory(builder));\n- }\n+ addFactories(executors, factories, cursorStrategy, defaultScrollSubrange);\n+ addFactories(reactiveExecutors, factories, cursorStrategy, defaultScrollSubrange);",
                "Description": "The code to create a DataFetcherFactory and add it to the factories map is duplicated for both executors and reactiveExecutors. This common logic should be extracted into a separate method to avoid code duplication.",
                "Start": 13,
                "End": 27
            }
        ],
        "Final code": "public static RuntimeWiringConfigurer autoRegistrationConfigurer(List<QuerydslPredicateExecutor<?>> executors, List<ReactiveQuerydslPredicateExecutor<?>> reactiveExecutors, @Nullable CursorStrategy<ScrollPosition> cursorStrategy, @Nullable ScrollSubrange defaultScrollSubrange) {\n    Map<String, DataFetcherFactory> factories = new HashMap<>();\n    addFactories(executors, factories, cursorStrategy, defaultScrollSubrange);\n    addFactories(reactiveExecutors, factories, cursorStrategy, defaultScrollSubrange);\n    if (logger.isTraceEnabled()) {\n        logger.trace(\"Auto-registration candidate typeNames \" + factories.keySet());\n    }\n    return new AutoRegistrationRuntimeWiringConfigurer(factories);\n}\n\nprivate static void addFactories(List<QuerydslPredicateExecutor<?>> executors, Map<String, DataFetcherFactory> factories, CursorStrategy<ScrollPosition> cursorStrategy, ScrollSubrange defaultScrollSubrange) {\n    for (QuerydslPredicateExecutor<?> executor : executors) {\n        String typeName = RepositoryUtils.getGraphQlTypeName(executor);\n        if (typeName != null) {\n            Builder builder = customize(executor, QuerydslDataFetcher.builder(executor).cursorStrategy(cursorStrategy).defaultScrollSubrange(defaultScrollSubrange).customizer(customizer(executor)));\n            factories.put(typeName, new CustomDataFetcherFactory(builder));\n        }\n    }\n}\n\nprivate static class CustomDataFetcherFactory implements DataFetcherFactory {\n    private final Builder builder;\n\n    public CustomDataFetcherFactory(Builder builder) {\n        this.builder = builder;\n    }\n\n    @Override\n    public DataFetcher<?> single() {\n        return builder.single();\n    }\n\n    @Override\n    public DataFetcher<?> many() {\n        return builder.many();\n    }\n\n    @Override\n    public DataFetcher<?> scrollable() {\n        return builder.scrollable();\n    }\n}"
    },
    "Old_Method": "/** \n * Return a  {@link RuntimeWiringConfigurer} that installs a{@link graphql.schema.idl.WiringFactory} to find queries with a returntype whose name matches to the domain type name of the given repositories and registers  {@link DataFetcher}s for them. <p><strong>Note:<\/strong> This applies only to top-level queries and repositories annotated with  {@link GraphQlRepository @GraphQlRepository}. If a repository is also an instance of  {@link QuerydslBinderCustomizer}, this is transparently detected and applied through the {@code QuerydslDataFetcher} builder  methods.\n * @param executors repositories to consider for registration\n * @param reactiveExecutors reactive repositories to consider for registration\n * @param cursorStrategy for decoding cursors in pagination requests;if  {@code null}, then  {@link Builder#cursorStrategy} defaults apply.\n * @param defaultScrollSubrange default parameters for scrolling;if  {@code null}, then  {@link Builder#defaultScrollSubrange} defaults apply.\n * @return the created configurer\n * @since 1.2.0\n */\n@SuppressWarnings({\"unchecked\",\"rawtypes\"}) public static RuntimeWiringConfigurer autoRegistrationConfigurer(List<QuerydslPredicateExecutor<?>> executors,List<ReactiveQuerydslPredicateExecutor<?>> reactiveExecutors,@Nullable CursorStrategy<ScrollPosition> cursorStrategy,@Nullable ScrollSubrange defaultScrollSubrange){\n  Map<String,DataFetcherFactory> factories=new HashMap<>();\n  for (  QuerydslPredicateExecutor<?> executor : executors) {\n    String typeName=RepositoryUtils.getGraphQlTypeName(executor);\n    if (typeName != null) {\n      Builder builder=customize(executor,QuerydslDataFetcher.builder(executor).cursorStrategy(cursorStrategy).defaultScrollSubrange(defaultScrollSubrange).customizer(customizer(executor)));\n      factories.put(typeName,new DataFetcherFactory(){\n        @Override public DataFetcher<?> single(){\n          return builder.single();\n        }\n        @Override public DataFetcher<?> many(){\n          return builder.many();\n        }\n        @Override public DataFetcher<?> scrollable(){\n          return builder.scrollable();\n        }\n      }\n);\n    }\n  }\n  for (  ReactiveQuerydslPredicateExecutor<?> executor : reactiveExecutors) {\n    String typeName=RepositoryUtils.getGraphQlTypeName(executor);\n    if (typeName != null) {\n      ReactiveBuilder builder=customize(executor,QuerydslDataFetcher.builder(executor).cursorStrategy(cursorStrategy).defaultScrollSubrange(defaultScrollSubrange).customizer(customizer(executor)));\n      factories.put(typeName,new DataFetcherFactory(){\n        @Override public DataFetcher<?> single(){\n          return builder.single();\n        }\n        @Override public DataFetcher<?> many(){\n          return builder.many();\n        }\n        @Override public DataFetcher<?> scrollable(){\n          return builder.scrollable();\n        }\n      }\n);\n    }\n  }\n  if (logger.isTraceEnabled()) {\n    logger.trace(\"Auto-registration candidate typeNames \" + factories.keySet());\n  }\n  return new AutoRegistrationRuntimeWiringConfigurer(factories);\n}\n",
    "File_Path": "spring-graphql/spring-graphql/src/main/java/org/springframework/graphql/data/query/QuerydslDataFetcher.java",
    "Start": 9439,
    "Stop": 12618,
    "Project_Name": "data/projects/spring-graphql",
    "Method_Name": "autoRegistrationConfigurer"
}