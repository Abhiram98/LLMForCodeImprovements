{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Extract common logic for building DataFetcherFactory",
                "Change_Diff": "- String typeName=RepositoryUtils.getGraphQlTypeName(executor);\n- if (typeName != null) {\n-   Builder<?,?> builder=customize(executor,builder(executor).cursorStrategy(cursorStrategy).defaultScrollSubrange(defaultScrollSubrange));\n-   factories.put(typeName,new DataFetcherFactory(){\n-     @Override public DataFetcher<?> single(){\n-       return builder.single();\n-     }\n-     @Override public DataFetcher<?> many(){\n-       return builder.many();\n-     }\n-     @Override public DataFetcher<?> scrollable(){\n-       return builder.scrollable();\n-     }\n-   }\n);",
                "Description": "There is a repetitive logic for building DataFetcherFactory between executors and reactiveExecutors. You can extract this logic into a separate method that receives executor, cursorStrategy and defaultScrollSubrange as input parameters and returns DataFetcherFactory.",
                "Start": 7,
                "End": 31
            },
            {
                "Improvement": "Use lambda expressions for DataFetcherFactory",
                "Change_Diff": "- factories.put(typeName,new DataFetcherFactory(){\n-   @Override public DataFetcher<?> single(){\n-     return builder.single();\n-   }\n-   @Override public DataFetcher<?> many(){\n-     return builder.many();\n-   }\n-   @Override public DataFetcher<?> scrollable(){\n-     return builder.scrollable();\n-   }\n- }",
                "Description": "Lambda expressions can be used to simplify the instantiation of DataFetcherFactory. This simplifies the code and makes it more readable.",
                "Start": 9,
                "End": 19
            },
            {
                "Improvement": "Use Java Stream API for adding entries to map",
                "Change_Diff": "- for (QueryByExampleExecutor<?> executor : executors) {\n-   String typeName=RepositoryUtils.getGraphQlTypeName(executor);\n-   if (typeName != null) {\n-     Builder<?,?> builder=customize(executor,builder(executor).cursorStrategy(cursorStrategy).defaultScrollSubrange(defaultScrollSubrange));\n-     factories.put(typeName,new DataFetcherFactory(){\n-       @Override public DataFetcher<?> single(){\n-         return builder.single();\n-       }\n-       @Override public DataFetcher<?> many(){\n-         return builder.many();\n-       }\n-       @Override public DataFetcher<?> scrollable(){\n-         return builder.scrollable();\n-       }\n-     }\n-   }\n- }",
                "Description": "Java Stream API can be used for adding entries to map by transforming each executor into a map entry and then collecting them into the map.",
                "Start": 6,
                "End": 21
            }
        ],
        "Final code": "public static RuntimeWiringConfigurer autoRegistrationConfigurer(List<QueryByExampleExecutor<?>> executors, List<ReactiveQueryByExampleExecutor<?>> reactiveExecutors, @Nullable CursorStrategy<ScrollPosition> cursorStrategy, @Nullable ScrollSubrange defaultScrollSubrange) {\n    Map<String, DataFetcherFactory> factories = Stream.concat(\n            executors.stream().map(executor -> buildDataFetcherFactory(executor, cursorStrategy, defaultScrollSubrange)),\n            reactiveExecutors.stream().map(executor -> buildDataFetcherFactory(executor, cursorStrategy, defaultScrollSubrange))\n    ).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n\n    if (logger.isTraceEnabled()) {\n        logger.trace(\"Auto-registration candidate typeNames \" + factories.keySet());\n    }\n\n    return new AutoRegistrationRuntimeWiringConfigurer(factories);\n}\n\nprivate static <T> Map.Entry<String, DataFetcherFactory> buildDataFetcherFactory(T executor, CursorStrategy<ScrollPosition> cursorStrategy, ScrollSubrange defaultScrollSubrange) {\n    String typeName = RepositoryUtils.getGraphQlTypeName(executor);\n    if (typeName != null) {\n        Builder<?, ?> builder = customize(executor, builder(executor).cursorStrategy(cursorStrategy).defaultScrollSubrange(defaultScrollSubrange));\n        return new AbstractMap.SimpleEntry<>(typeName, () -> {\n            return new DataFetcherFactory() {\n                @Override\n                public DataFetcher<?> single() {\n                    return builder.single();\n                }\n\n                @Override\n                public DataFetcher<?> many() {\n                    return builder.many();\n                }\n\n                @Override\n                public DataFetcher<?> scrollable() {\n                    return builder.scrollable();\n                }\n            };\n        });\n    }\n    return null;\n}"
    },
    "Old_Method": "/** \n * Return a  {@link RuntimeWiringConfigurer} that installs a{@link graphql.schema.idl.WiringFactory} to find queries with a returntype whose name matches to the domain type name of the given repositories and registers  {@link DataFetcher}s for them. <p><strong>Note:<\/strong> This applies only to top-level queries and repositories annotated with  {@link GraphQlRepository @GraphQlRepository}.\n * @param executors repositories to consider for registration\n * @param reactiveExecutors reactive repositories to consider for registration\n * @param cursorStrategy for decoding cursors in pagination requests;if  {@code null}, then  {@link Builder#cursorStrategy} defaults apply.\n * @param defaultScrollSubrange default parameters for scrolling;if  {@code null}, then  {@link Builder#defaultScrollSubrange} defaults apply.\n * @return the created configurer\n * @since 1.2.0\n */\npublic static RuntimeWiringConfigurer autoRegistrationConfigurer(List<QueryByExampleExecutor<?>> executors,List<ReactiveQueryByExampleExecutor<?>> reactiveExecutors,@Nullable CursorStrategy<ScrollPosition> cursorStrategy,@Nullable ScrollSubrange defaultScrollSubrange){\n  Map<String,DataFetcherFactory> factories=new HashMap<>();\n  for (  QueryByExampleExecutor<?> executor : executors) {\n    String typeName=RepositoryUtils.getGraphQlTypeName(executor);\n    if (typeName != null) {\n      Builder<?,?> builder=customize(executor,builder(executor).cursorStrategy(cursorStrategy).defaultScrollSubrange(defaultScrollSubrange));\n      factories.put(typeName,new DataFetcherFactory(){\n        @Override public DataFetcher<?> single(){\n          return builder.single();\n        }\n        @Override public DataFetcher<?> many(){\n          return builder.many();\n        }\n        @Override public DataFetcher<?> scrollable(){\n          return builder.scrollable();\n        }\n      }\n);\n    }\n  }\n  for (  ReactiveQueryByExampleExecutor<?> executor : reactiveExecutors) {\n    String typeName=RepositoryUtils.getGraphQlTypeName(executor);\n    if (typeName != null) {\n      ReactiveBuilder<?,?> builder=customize(executor,builder(executor).cursorStrategy(cursorStrategy).defaultScrollSubrange(defaultScrollSubrange));\n      factories.put(typeName,new DataFetcherFactory(){\n        @Override public DataFetcher<?> single(){\n          return builder.single();\n        }\n        @Override public DataFetcher<?> many(){\n          return builder.many();\n        }\n        @Override public DataFetcher<?> scrollable(){\n          return builder.scrollable();\n        }\n      }\n);\n    }\n  }\n  if (logger.isTraceEnabled()) {\n    logger.trace(\"Auto-registration candidate typeNames \" + factories.keySet());\n  }\n  return new AutoRegistrationRuntimeWiringConfigurer(factories);\n}\n",
    "File_Path": "spring-graphql/spring-graphql/src/main/java/org/springframework/graphql/data/query/QueryByExampleDataFetcher.java",
    "Start": 8299,
    "Stop": 11102,
    "Project_Name": "data/projects/spring-graphql",
    "Method_Name": "autoRegistrationConfigurer"
}