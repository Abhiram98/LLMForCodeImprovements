{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Reduce code duplication",
                "Change_Diff": "- if (annotation instanceof SchemaMapping) {\n-    typeName=mapping.typeName();\n-    field=(StringUtils.hasText(mapping.field()) ? mapping.field() : method.getName());\n-  }\n- else {\n-    BatchMapping mapping=(BatchMapping)annotation;\n-    typeName=mapping.typeName();\n-    field=(StringUtils.hasText(mapping.field()) ? mapping.field() : method.getName());\n-    batchMapping=true;\n-    batchSize=mapping.maxBatchSize();\n-  }",
                "Description": "The code block for extracting typeName and field from the annotation is almost identical for both SchemaMapping and BatchMapping. We should extract this functionality into a separate method.",
                "Start": 16,
                "End": 27
            },
            {
                "Improvement": "Use of Optional",
                "Change_Diff": "- if (!StringUtils.hasText(typeName)) {\n-    SchemaMapping mapping=AnnotatedElementUtils.findMergedAnnotation(handlerType,SchemaMapping.class);\n-    if (mapping != null) {\n-      typeName=mapping.typeName();\n-    }\n-  }\n-  if (!StringUtils.hasText(typeName)) {\n-    for (MethodParameter parameter : handlerMethod.getMethodParameters()) {\n-      if (!batchMapping) {\n-        Assert.state(this.argumentResolvers != null,\"`argumentResolvers` is not initialized\");\n-        HandlerMethodArgumentResolver resolver=this.argumentResolvers.getArgumentResolver(parameter);\n-        if (resolver instanceof SourceMethodArgumentResolver) {\n-          typeName=parameter.getParameterType().getSimpleName();\n-          break;\n-        }\n-      } else {\n-        if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\n-          typeName=parameter.nested().getNestedParameterType().getSimpleName();\n-          break;\n-        }\n-      }\n-    }\n-  }",
                "Description": "Code for finding typeName can be simplified by using Java 8 Optional. This way we can avoid multiple if checks and make code more readable.",
                "Start": 28,
                "End": 42
            }
        ],
        "Final code": "@Nullable private MappingInfo getMappingInfo(Method method,Object handler,Class<?> handlerType) {\n  Set<Annotation> annotations = AnnotatedElementUtils.findAllMergedAnnotations(method,new LinkedHashSet<>(Arrays.asList(BatchMapping.class,SchemaMapping.class)));\n  if (annotations.isEmpty()) {\n    return null;\n  }\n  if (annotations.size() != 1) {\n    throw new IllegalArgumentException(\"Expected either @BatchMapping or @SchemaMapping, not both: \" + method.toGenericString());\n  }\n  String typeName;\n  String field;\n  boolean batchMapping = false;\n  int batchSize = -1;\n  HandlerMethod handlerMethod = createHandlerMethod(method, handler, handlerType);\n  Annotation annotation = annotations.iterator().next();\n  typeName = extractTypeNameFromAnnotation(annotation);\n  field = extractFieldFromAnnotation(annotation);\n  if(annotation instanceof BatchMapping) {\n    batchMapping = true;\n    batchSize = ((BatchMapping) annotation).maxBatchSize();\n  }\n  typeName = Optional.ofNullable(typeName)\n      .orElseGet(() -> findTypeName(handlerType, batchMapping, handlerMethod));\n  Assert.hasText(typeName,\"No parentType specified, and a source/parent method argument was also not found: \" + handlerMethod.getShortLogMessage());\n  return new MappingInfo(typeName,field,batchMapping,batchSize,handlerMethod);\n}\n\nprivate String extractTypeNameFromAnnotation(Annotation annotation) {\n  if(annotation instanceof SchemaMapping) {\n    return ((SchemaMapping) annotation).typeName();\n  }\n  return ((BatchMapping) annotation).typeName();\n}\n\nprivate String extractFieldFromAnnotation(Annotation annotation) {\n  String field = ((BatchMapping) annotation).field();\n  return StringUtils.hasText(field) ? field : method.getName();\n}\n\nprivate String findTypeName(Class<?> handlerType, boolean batchMapping, HandlerMethod handlerMethod) {\n  SchemaMapping mapping = AnnotatedElementUtils.findMergedAnnotation(handlerType, SchemaMapping.class);\n  if(mapping != null) {\n    return mapping.typeName();\n  }\n  for (MethodParameter parameter : handlerMethod.getMethodParameters()) {\n    if (!batchMapping) {\n      Assert.state(this.argumentResolvers != null, \"`argumentResolvers` is not initialized\");\n      HandlerMethodArgumentResolver resolver = this.argumentResolvers.getArgumentResolver(parameter);\n      if (resolver instanceof SourceMethodArgumentResolver) {\n        return parameter.getParameterType().getSimpleName();\n      }\n    } else {\n      if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\n        return parameter.nested().getNestedParameterType().getSimpleName();\n      }\n    }\n  }\n  throw new IllegalStateException(\"No parentType specified, and a source/parent method argument was also not found: \" + handlerMethod.getShortLogMessage());\n}"
    },
    "Old_Method": "@Nullable private MappingInfo getMappingInfo(Method method,Object handler,Class<?> handlerType){\n  Set<Annotation> annotations=AnnotatedElementUtils.findAllMergedAnnotations(method,new LinkedHashSet<>(Arrays.asList(BatchMapping.class,SchemaMapping.class)));\n  if (annotations.isEmpty()) {\n    return null;\n  }\n  if (annotations.size() != 1) {\n    throw new IllegalArgumentException(\"Expected either @BatchMapping or @SchemaMapping, not both: \" + method.toGenericString());\n  }\n  String typeName;\n  String field;\n  boolean batchMapping=false;\n  int batchSize=-1;\n  HandlerMethod handlerMethod=createHandlerMethod(method,handler,handlerType);\n  Annotation annotation=annotations.iterator().next();\n  if (annotation instanceof SchemaMapping) {\n    typeName=mapping.typeName();\n    field=(StringUtils.hasText(mapping.field()) ? mapping.field() : method.getName());\n  }\n else {\n    BatchMapping mapping=(BatchMapping)annotation;\n    typeName=mapping.typeName();\n    field=(StringUtils.hasText(mapping.field()) ? mapping.field() : method.getName());\n    batchMapping=true;\n    batchSize=mapping.maxBatchSize();\n  }\n  if (!StringUtils.hasText(typeName)) {\n    SchemaMapping mapping=AnnotatedElementUtils.findMergedAnnotation(handlerType,SchemaMapping.class);\n    if (mapping != null) {\n      typeName=mapping.typeName();\n    }\n  }\n  if (!StringUtils.hasText(typeName)) {\n    for (    MethodParameter parameter : handlerMethod.getMethodParameters()) {\n      if (!batchMapping) {\n        Assert.state(this.argumentResolvers != null,\"`argumentResolvers` is not initialized\");\n        HandlerMethodArgumentResolver resolver=this.argumentResolvers.getArgumentResolver(parameter);\n        if (resolver instanceof SourceMethodArgumentResolver) {\n          typeName=parameter.getParameterType().getSimpleName();\n          break;\n        }\n      }\n else {\n        if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\n          typeName=parameter.nested().getNestedParameterType().getSimpleName();\n          break;\n        }\n      }\n    }\n  }\n  Assert.hasText(typeName,\"No parentType specified, and a source/parent method argument was also not found: \" + handlerMethod.getShortLogMessage());\n  return new MappingInfo(typeName,field,batchMapping,batchSize,handlerMethod);\n}\n",
    "File_Path": "spring-graphql/spring-graphql/src/main/java/org/springframework/graphql/data/method/annotation/support/AnnotatedControllerConfigurer.java",
    "Start": 16586,
    "Stop": 18892,
    "Project_Name": "data/projects/spring-graphql",
    "Method_Name": "getMappingInfo"
}