{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Use switch-case instead of multiple if-else statements",
                "Change_Diff": "- if (c >= 'A' && c <= 'Z') {\n  bits=c - 65;\n}\nelse if (c >= 'a' && c <= 'z') {\n  bits=c - 71;\n}\nelse if (c >= '0' && c <= '9') {\n  bits=c + 4;\n}\nelse if (c == '+' || c == '-') {\n  bits=62;\n}\nelse if (c == '/' || c == '_') {\n  bits=63;\n}\nelse if (c == '\n' || c == '\r' || c == ' ' || c == '\t') {\n  continue;\n}\nelse {\n  throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n}\n+ switch (c) {\n  case 'A' to 'Z':\n    bits = c - 65;\n    break;\n  case 'a' to 'z':\n    bits = c - 71;\n    break;\n  case '0' to '9':\n    bits = c + 4;\n    break;\n  case '+':\n  case '-':\n    bits = 62;\n    break;\n  case '/':\n  case '_':\n    bits = 63;\n    break;\n  case '\n':\n  case '\r':\n  case ' ':\n  case '\t':\n    continue mainLoop;\n  default:\n    throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n}",
                "Description": "Switch-case statements are more efficient and easy to read when dealing with conditions based on a single variable. It can be used in place of multiple if-else statements to check for character ranges and specific characters.",
                "Start": 15,
                "End": 33
            },
            {
                "Improvement": "Use a constant for the magic numbers",
                "Change_Diff": "- byte[] out=new byte[(int)(limit * 6L / 8L)];\n...\nword=(word << 6) | (byte)bits & 0xff;\n...\nif (inCount % 4 == 0) {\n  out[outCount++]=(byte)(word >> 16);\n  out[outCount++]=(byte)(word >> 8);\n  out[outCount++]=(byte)word;\n}\n...\nif (lastWordChars == 1) {\n  return null;\n}\nelse if (lastWordChars == 2) {\n  word=word << 12;\n  out[outCount++]=(byte)(word >> 16);\n}\nelse if (lastWordChars == 3) {\n  word=word << 6;\n  out[outCount++]=(byte)(word >> 16);\n  out[outCount++]=(byte)(word >> 8);\n}\n+ private static final int BYTE_SIZE = 8;\n+ private static final int WORD_SIZE = 6;\n+ byte[] out=new byte[(int)(limit * WORD_SIZE / BYTE_SIZE)];\n...\nword=(word << WORD_SIZE) | (byte)bits & 0xff;\n...\nif (inCount % BYTE_SIZE == 0) {\n  out[outCount++]=(byte)(word >> 16);\n  out[outCount++]=(byte)(word >> 8);\n  out[outCount++]=(byte)word;\n}\n...\nif (lastWordChars == 1) {\n  return null;\n}\nelse if (lastWordChars == 2) {\n  word=word << (BYTE_SIZE * 1.5);\n  out[outCount++]=(byte)(word >> 16);\n}\nelse if (lastWordChars == 3) {\n  word=word << BYTE_SIZE;\n  out[outCount++]=(byte)(word >> 16);\n  out[outCount++]=(byte)(word >> BYTE_SIZE);\n}",
                "Description": "Magic numbers make the code harder to understand and modify. Replace them with named constants to improve readability.",
                "Start": 3,
                "End": 46
            }
        ],
        "Final code": "static byte[] decode(CharSequence in){\n  int limit=in.length();\n  for (; limit > 0; limit--) {\n    char c=in.charAt(limit - 1);\n    if (c != '=' && c != '\n' && c != '\r' && c != ' ' && c != '\t') {\n      break;\n    }\n  }\n  private static final int BYTE_SIZE = 8;\n  private static final int WORD_SIZE = 6;\n  byte[] out=new byte[(int)(limit * WORD_SIZE / BYTE_SIZE)];\n  int outCount=0, inCount=0, word=0;\n  mainLoop: for (int pos=0; pos < limit; pos++) {\n    char c=in.charAt(pos);\n    int bits;\n    switch (c) {\n      case 'A' to 'Z':\n        bits = c - 65;\n        break;\n      case 'a' to 'z':\n        bits = c - 71;\n        break;\n      case '0' to '9':\n        bits = c + 4;\n        break;\n      case '+':\n      case '-':\n        bits = 62;\n        break;\n      case '/':\n      case '_':\n        bits = 63;\n        break;\n      case '\n':\n      case '\r':\n      case ' ':\n      case '\t':\n        continue mainLoop;\n      default:\n        throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n    }\n    word=(word << WORD_SIZE) | (byte)bits & 0xff;\n    inCount++;\n    if (inCount % BYTE_SIZE == 0) {\n      out[outCount++]=(byte)(word >> 16);\n      out[outCount++]=(byte)(word >> 8);\n      out[outCount++]=(byte)word;\n    }\n  }\n  int lastWordChars=inCount % 4;\n  if (lastWordChars == 1) {\n    return null;\n  }\n  else if (lastWordChars == 2) {\n    word=word << (BYTE_SIZE * 1.5);\n    out[outCount++]=(byte)(word >> 16);\n  }\n  else if (lastWordChars == 3) {\n    word=word << BYTE_SIZE;\n    out[outCount++]=(byte)(word >> 16);\n    out[outCount++]=(byte)(word >> BYTE_SIZE);\n  }\n  if (outCount == out.length)   return out;\n  return Arrays.copyOfRange(out,0,outCount);\n}"
    },
    "Old_Method": "static byte[] decode(CharSequence in){\n  int limit=in.length();\n  for (; limit > 0; limit--) {\n    char c=in.charAt(limit - 1);\n    if (c != '=' && c != '\\n' && c != '\\r' && c != ' ' && c != '\\t') {\n      break;\n    }\n  }\n  byte[] out=new byte[(int)(limit * 6L / 8L)];\n  int outCount=0;\n  int inCount=0;\n  int word=0;\n  for (int pos=0; pos < limit; pos++) {\n    char c=in.charAt(pos);\n    int bits;\n    if (c >= 'A' && c <= 'Z') {\n      bits=c - 65;\n    }\n else     if (c >= 'a' && c <= 'z') {\n      bits=c - 71;\n    }\n else     if (c >= '0' && c <= '9') {\n      bits=c + 4;\n    }\n else     if (c == '+' || c == '-') {\n      bits=62;\n    }\n else     if (c == '/' || c == '_') {\n      bits=63;\n    }\n else     if (c == '\\n' || c == '\\r' || c == ' ' || c == '\\t') {\n      continue;\n    }\n else {\n      throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n    }\n    word=(word << 6) | (byte)bits & 0xff;\n    inCount++;\n    if (inCount % 4 == 0) {\n      out[outCount++]=(byte)(word >> 16);\n      out[outCount++]=(byte)(word >> 8);\n      out[outCount++]=(byte)word;\n    }\n  }\n  int lastWordChars=inCount % 4;\n  if (lastWordChars == 1) {\n    return null;\n  }\n else   if (lastWordChars == 2) {\n    word=word << 12;\n    out[outCount++]=(byte)(word >> 16);\n  }\n else   if (lastWordChars == 3) {\n    word=word << 6;\n    out[outCount++]=(byte)(word >> 16);\n    out[outCount++]=(byte)(word >> 8);\n  }\n  if (outCount == out.length)   return out;\n  return Arrays.copyOfRange(out,0,outCount);\n}\n",
    "File_Path": "bytes-java/src/main/java/at/favre/lib/bytes/Base64.java",
    "Start": 1985,
    "Stop": 4949,
    "Project_Name": "data/projects/bytes-java",
    "Method_Name": "decode"
}