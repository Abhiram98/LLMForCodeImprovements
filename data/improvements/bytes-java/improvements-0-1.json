{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Refactor char validation to a separate method",
                "Change_Diff": "-  for (; limit > 0; limit--) {\n-    char c=in.charAt(limit - 1);\n-    if (c != '=' && c != '\n' && c != '\r' && c != ' ' && c != '\t') {\n-      break;\n-    }\n-  }\n+  limit = validateChars(in, limit);",
                "Description": "The validation of characters in the input sequence is repeated twice in the method. This duplicate code could be refactored into a separate method for better readability and maintainability.",
                "Start": 4,
                "End": 8
            },
            {
                "Improvement": "Replace magic numbers with constants",
                "Change_Diff": "-  if (c >= 'A' && c <= 'Z') {\n-    bits=c - 65;\n-  }\n else     if (c >= 'a' && c <= 'z') {\n-    bits=c - 71;\n-  }\n else     if (c >= '0' && c <= '9') {\n-    bits=c + 4;\n-  }\n else     if (c == '+' || c == '-') {\n-    bits=62;\n-  }\n else     if (c == '/' || c == '_') {\n-    bits=63;\n-  }\n+  bits = getBits(c);",
                "Description": "The code contains many magic numbers, such as 65, 71, 4, 62, 63 and so on. These numbers should be replaced with named constants to make the code more understandable.",
                "Start": 23,
                "End": 32
            }
        ],
        "Final code": "static final int CHAR_A_OFFSET = 65;\nstatic final int CHAR_a_OFFSET = 71;\nstatic final int CHAR_0_OFFSET = -4;\nstatic final int CHAR_PLUS_MINUS = 62;\nstatic final int CHAR_SLASH_UNDERSCORE = 63;\n\nstatic byte[] decode(CharSequence in){\n  int limit=in.length();\n  limit = validateChars(in, limit);\n  byte[] out=new byte[(int)(limit * 6L / 8L)];\n  int outCount=0, inCount=0, word=0;\n  for (int pos=0; pos < limit; pos++) {\n    char c=in.charAt(pos);\n    int bits = getBits(c);\n    word=(word << 6) | (byte)bits & 0xff;\n    inCount++;\n    if (inCount % 4 == 0) {\n      out[outCount++]=(byte)(word >> 16);\n      out[outCount++]=(byte)(word >> 8);\n      out[outCount++]=(byte)word;\n    }\n  }\n  processLastWordChars(inCount, word, out, outCount);\n  if (outCount == out.length)   return out;\n  return Arrays.copyOfRange(out,0,outCount);\n}\n\nprivate static int validateChars(CharSequence in, int limit) {\n  for (; limit > 0; limit--) {\n    char c=in.charAt(limit - 1);\n    if (c != '=' && c != '\n' && c != '\r' && c != ' ' && c != '\t') {\n      break;\n    }\n  }\n  return limit;\n}\n\nprivate static int getBits(char c) {\n  if (c >= 'A' && c <= 'Z') return c - CHAR_A_OFFSET;\n  else if (c >= 'a' && c <= 'z') return c - CHAR_a_OFFSET;\n  else if (c >= '0' && c <= '9') return c + CHAR_0_OFFSET;\n  else if (c == '+' || c == '-') return CHAR_PLUS_MINUS;\n  else if (c == '/' || c == '_') return CHAR_SLASH_UNDERSCORE;\n  else if (c == '\n' || c == '\r' || c == ' ' || c == '\t') return 0;\n  else throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n}\n\nprivate static void processLastWordChars(int inCount, int word, byte[] out, int outCount) {\n  int lastWordChars=inCount % 4;\n  if (lastWordChars == 1) return;\n  else if (lastWordChars == 2) {\n    word=word << 12;\n    out[outCount++]=(byte)(word >> 16);\n  }\n  else if (lastWordChars == 3) {\n    word=word << 6;\n    out[outCount++]=(byte)(word >> 16);\n    out[outCount++]=(byte)(word >> 8);\n  }\n}"
    },
    "Old_Method": "static byte[] decode(CharSequence in){\n  int limit=in.length();\n  for (; limit > 0; limit--) {\n    char c=in.charAt(limit - 1);\n    if (c != '=' && c != '\\n' && c != '\\r' && c != ' ' && c != '\\t') {\n      break;\n    }\n  }\n  byte[] out=new byte[(int)(limit * 6L / 8L)];\n  int outCount=0;\n  int inCount=0;\n  int word=0;\n  for (int pos=0; pos < limit; pos++) {\n    char c=in.charAt(pos);\n    int bits;\n    if (c >= 'A' && c <= 'Z') {\n      bits=c - 65;\n    }\n else     if (c >= 'a' && c <= 'z') {\n      bits=c - 71;\n    }\n else     if (c >= '0' && c <= '9') {\n      bits=c + 4;\n    }\n else     if (c == '+' || c == '-') {\n      bits=62;\n    }\n else     if (c == '/' || c == '_') {\n      bits=63;\n    }\n else     if (c == '\\n' || c == '\\r' || c == ' ' || c == '\\t') {\n      continue;\n    }\n else {\n      throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n    }\n    word=(word << 6) | (byte)bits & 0xff;\n    inCount++;\n    if (inCount % 4 == 0) {\n      out[outCount++]=(byte)(word >> 16);\n      out[outCount++]=(byte)(word >> 8);\n      out[outCount++]=(byte)word;\n    }\n  }\n  int lastWordChars=inCount % 4;\n  if (lastWordChars == 1) {\n    return null;\n  }\n else   if (lastWordChars == 2) {\n    word=word << 12;\n    out[outCount++]=(byte)(word >> 16);\n  }\n else   if (lastWordChars == 3) {\n    word=word << 6;\n    out[outCount++]=(byte)(word >> 16);\n    out[outCount++]=(byte)(word >> 8);\n  }\n  if (outCount == out.length)   return out;\n  return Arrays.copyOfRange(out,0,outCount);\n}\n",
    "File_Path": "bytes-java/src/main/java/at/favre/lib/bytes/Base64.java",
    "Start": 1985,
    "Stop": 4949,
    "Project_Name": "data/projects/bytes-java",
    "Method_Name": "decode"
}