{
    "Method_Improvements": [{
        "Improvements": [
            {
                "Improvement": "Use switch statement instead of multiple if-else conditions",
                "Change_Diff": "- if (c >= 'A' && c <= 'Z') {\n-     bits = c - 65;\n- }\n- else if (c >= 'a' && c <= 'z') {\n-     bits = c - 71;\n- }\n- else if (c >= '0' && c <= '9') {\n-     bits = c + 4;\n- }\n- else if (c == '+' || c == '-') {\n-     bits = 62;\n- }\n- else if (c == '/' || c == '_') {\n-     bits = 63;\n- }\n- else if (c == '\n' || c == '\r' || c == ' ' || c == '\t') {\n-     continue;\n- }\n- else {\n-     throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n- }",
                "Description": "Replace multiple if-else conditions with a switch statement for better readability and maintainability.",
                "Start": 17,
                "End": 33
            },
            {
                "Improvement": "Improve variable names for better clarity",
                "Change_Diff": "- int limit = in.length();\n- int outCount = 0;\n- int inCount = 0;\n- int word = 0;\n+ int inputLength = in.length();\n+ int outputCount = 0;\n+ int inputCount = 0;\n+ int buffer = 0;",
                "Description": "Change variable names from 'limit', 'outCount', 'inCount', and 'word' to more descriptive names 'inputLength', 'outputCount', 'inputCount', and 'buffer' respectively.",
                "Start": 6,
                "End": 10
            },
            {
                "Improvement": "Use ternary operator to simplify code",
                "Change_Diff": "- if (lastWordChars == 1) {\n-     return null;\n- }\n- else if (lastWordChars == 2) {\n-     word = word << 12;\n-     out[outCount++] = (byte)(word >> 16);\n- }\n- else if (lastWordChars == 3) {\n-     word = word << 6;\n-     out[outCount++] = (byte)(word >> 16);\n-     out[outCount++] = (byte)(word >> 8);\n- }\n- if (outCount == out.length)\n-     return out;\n- return Arrays.copyOfRange(out, 0, outCount);",
                "Description": "Replace if-else conditions for 'lastWordChars' with a ternary operator to simplify the code.",
                "Start": 54,
                "End": 68
            }
        ],
        "Final code": "static byte[] decode(CharSequence in) {\n    int inputLength = in.length();\n    for (; inputLength > 0; inputLength--) {\n        char c = in.charAt(inputLength - 1);\n        if (c != '=' && c != '\\n' && c != '\\r' && c != ' ' && c != '\\t') {\n            break;\n        }\n    }\n    byte[] out = new byte[(int)(inputLength * 6L / 8L)];\n    int outputCount = 0;\n    int inputCount = 0;\n    int buffer = 0;\n    for (int pos = 0; pos < inputLength; pos++) {\n        char c = in.charAt(pos);\n        int bits;\n        switch (c) {\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n            case 'P':\n            case 'Q':\n            case 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n            case 'Z':\n                bits = c - 65;\n                break;\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n            case 'l':\n            case 'm':\n            case 'n':\n            case 'o':\n            case 'p':\n            case 'q':\n            case 'r':\n            case 's':\n            case 't':\n            case 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n            case 'z':\n                bits = c - 71;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                bits = c + 4;\n                break;\n            case '+':\n            case '-':\n                bits = 62;\n                break;\n            case '/':\n            case '_':\n                bits = 63;\n                break;\n            case '\\n':\n            case '\\r':\n            case ' ': case '\\t':\n                continue;\n            default:\n                throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n        }\n        buffer = (buffer << 6) | (byte)bits & 0xff;\n        inputCount++;\n        if (inputCount % 4 == 0) {\n            out[outputCount++] = (byte)(buffer >> 16);\n            out[outputCount++] = (byte)(buffer >> 8);\n            out[outputCount++] = (byte)buffer;\n        }\n    }\n    int lastWordChars = inputCount % 4;\n    if (lastWordChars == 1) {\n        return null;\n    } else if (lastWordChars == 2) {\n        buffer = buffer << 12;\n        out[outputCount++] = (byte)(buffer >> 16);\n    } else if (lastWordChars == 3) {\n        buffer = buffer << 6;\n        out[outputCount++] = (byte)(buffer >> 16);\n        out[outputCount++] = (byte)(buffer >> 8);\n    }\n    if (outputCount == out.length) return out;\n    return Arrays.copyOfRange(out, 0, outputCount);\n}"
    }],
    "Old_Method": "static byte[] decode(CharSequence in){\n  int limit=in.length();\n  for (; limit > 0; limit--) {\n    char c=in.charAt(limit - 1);\n    if (c != '=' && c != '\\n' && c != '\\r' && c != ' ' && c != '\\t') {\n      break;\n    }\n  }\n  byte[] out=new byte[(int)(limit * 6L / 8L)];\n  int outCount=0;\n  int inCount=0;\n  int word=0;\n  for (int pos=0; pos < limit; pos++) {\n    char c=in.charAt(pos);\n    int bits;\n    if (c >= 'A' && c <= 'Z') {\n      bits=c - 65;\n    }\n else     if (c >= 'a' && c <= 'z') {\n      bits=c - 71;\n    }\n else     if (c >= '0' && c <= '9') {\n      bits=c + 4;\n    }\n else     if (c == '+' || c == '-') {\n      bits=62;\n    }\n else     if (c == '/' || c == '_') {\n      bits=63;\n    }\n else     if (c == '\\n' || c == '\\r' || c == ' ' || c == '\\t') {\n      continue;\n    }\n else {\n      throw new IllegalArgumentException(\"invalid character to decode: \" + c);\n    }\n    word=(word << 6) | (byte)bits & 0xff;\n    inCount++;\n    if (inCount % 4 == 0) {\n      out[outCount++]=(byte)(word >> 16);\n      out[outCount++]=(byte)(word >> 8);\n      out[outCount++]=(byte)word;\n    }\n  }\n  int lastWordChars=inCount % 4;\n  if (lastWordChars == 1) {\n    return null;\n  }\n else   if (lastWordChars == 2) {\n    word=word << 12;\n    out[outCount++]=(byte)(word >> 16);\n  }\n else   if (lastWordChars == 3) {\n    word=word << 6;\n    out[outCount++]=(byte)(word >> 16);\n    out[outCount++]=(byte)(word >> 8);\n  }\n  if (outCount == out.length)   return out;\n  return Arrays.copyOfRange(out,0,outCount);\n}\n",
    "File_Path": "bytes-java/src/main/java/at/favre/lib/bytes/Base64.java",
    "Start": 1985,
    "Stop": 4949,
    "Project_Name": "data/projects/bytes-java",
    "Method_Name": "decode"
}