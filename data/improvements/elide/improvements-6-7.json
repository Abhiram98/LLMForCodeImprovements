{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Refactor anonymous classes into separate methods",
                "Change_Diff": "- annotations.put(ColumnMeta.class,new ColumnMeta(){...}\n- annotations.put(DimensionFormula.class,new DimensionFormula(){...}\n- annotations.put(ReadPermission.class,new ReadPermission(){...}\n- annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n- annotations.put(Temporal.class,new Temporal(){...}\n+ annotations.put(ColumnMeta.class, createColumnMeta(dimension));\n+ annotations.put(DimensionFormula.class, createDimensionFormula(dimension));\n+ if (StringUtils.isNotEmpty(readPermission)) {\n+     annotations.put(ReadPermission.class, createReadPermission(readPermission));\n+ }\n+ if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) {\n+     annotations.put(Enumerated.class, getEnumeratedAnnotation(EnumType.ORDINAL));\n+ }\n+ if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) {\n+     annotations.put(Temporal.class, createTemporal(dimension));\n+ }",
                "Description": "The method is quite large and hard to read due to the use of anonymous classes. Creating separate methods for these classes would increase readability and maintainability of the code.",
                "Start": 3,
                "End": 82
            },
            {
                "Improvement": "Replace magic strings with constants",
                "Change_Diff": "- if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) {...\n- if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) {...\n+ if (dimension.getType().toUpperCase(Locale.ROOT).equals(CONST_ENUM_ORDINAL)) {...\n+ if (dimension.getType().toUpperCase(Locale.ROOT).equals(CONST_TIME)) {...",
                "Description": "Magic strings are hard-coded strings that appear directly in the code. They can be harder to maintain and can cause errors if mistyped. Replacing them with constants can make the code more maintainable and less error-prone.",
                "Start": 60,
                "End": 71
            }
        ],
        "Final code": "private static final String CONST_ENUM_ORDINAL = \"ENUM_ORDINAL\";\nprivate static final String CONST_TIME = \"TIME\";\n\nprivate static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Dimension dimension){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class, createColumnMeta(dimension));\n  annotations.put(DimensionFormula.class, createDimensionFormula(dimension));\n\n  String readPermission=dimension.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) {\n    annotations.put(ReadPermission.class, createReadPermission(readPermission));\n  }\n\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(CONST_ENUM_ORDINAL)) {\n    annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n  }\n\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(CONST_TIME)) {\n    annotations.put(Temporal.class, createTemporal(dimension));\n  }\n\n  return annotations;\n}\n\nprivate ColumnMeta createColumnMeta(Dimension dimension) {...}\nprivate DimensionFormula createDimensionFormula(Dimension dimension) {...}\nprivate ReadPermission createReadPermission(String readPermission) {...}\nprivate Temporal createTemporal(Dimension dimension) {...}"
    },
    "Old_Method": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Dimension dimension){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class,new ColumnMeta(){\n    @Override public Class<? extends Annotation> annotationType(){\n      return ColumnMeta.class;\n    }\n    @Override public String friendlyName(){\n      return dimension.getFriendlyName();\n    }\n    @Override public String description(){\n      return dimension.getDescription();\n    }\n    @Override public String category(){\n      return dimension.getCategory();\n    }\n    @Override public TableSource tableSource(){\n      return buildTableSource(dimension.getTableSource());\n    }\n    @Override public String[] tags(){\n      return dimension.getTags().toArray(new String[0]);\n    }\n    @Override public String[] values(){\n      return dimension.getValues().toArray(new String[0]);\n    }\n    @Override public boolean isHidden(){\n      return dimension.getHidden() != null && dimension.getHidden();\n    }\n    @Override public String filterTemplate(){\n      return dimension.getFilterTemplate();\n    }\n    @Override public CardinalitySize size(){\n      if (StringUtils.isEmpty(dimension.getCardinality())) {\n        return CardinalitySize.UNKNOWN;\n      }\n      return CardinalitySize.valueOf(dimension.getCardinality().toUpperCase(Locale.ENGLISH));\n    }\n  }\n);\n  annotations.put(DimensionFormula.class,new DimensionFormula(){\n    @Override public ArgumentDefinition[] arguments(){\n      return getArgumentDefinitions(dimension.getArguments());\n    }\n    @Override public Class<? extends Annotation> annotationType(){\n      return DimensionFormula.class;\n    }\n    @Override public String value(){\n      return trimColumnReferences(dimension.getDefinition());\n    }\n  }\n);\n  String readPermission=dimension.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) {\n    annotations.put(ReadPermission.class,new ReadPermission(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return ReadPermission.class;\n      }\n      @Override public String expression(){\n        return readPermission;\n      }\n    }\n);\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) {\n    annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) {\n    annotations.put(Temporal.class,new Temporal(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return Temporal.class;\n      }\n      @Override public TimeGrainDefinition[] grains(){\n        int numGrains=dimension.getGrains() == null ? 0 : dimension.getGrains().size();\n        TimeGrainDefinition[] definitions=new TimeGrainDefinition[numGrains];\n        for (int idx=0; idx < numGrains; idx++) {\n          Grain grain=dimension.getGrains().get(idx);\n          definitions[idx]=new TimeGrainDefinition(){\n            @Override public Class<? extends Annotation> annotationType(){\n              return TimeGrainDefinition.class;\n            }\n            @Override public TimeGrain grain(){\n              if (grain.getType() == null) {\n                return TimeGrain.DAY;\n              }\n              return TimeGrain.valueOf(grain.getType().name());\n            }\n            @Override public String expression(){\n              String sql=grain.getSql();\n              if (StringUtils.isEmpty(sql)) {\n                return \"{{$$column.expr}}\";\n              }\n              return grain.getSql();\n            }\n          }\n;\n        }\n        return definitions;\n      }\n      @Override public String timeZone(){\n        return \"UTC\";\n      }\n    }\n);\n  }\n  return annotations;\n}\n",
    "File_Path": "elide/elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/dynamic/TableType.java",
    "Start": 21178,
    "Stop": 26304,
    "Project_Name": "data/projects/elide",
    "Method_Name": "buildAnnotations"
}