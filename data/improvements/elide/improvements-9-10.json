{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Remove redundant null check",
                "Change_Diff": "- return measure.getHidden() != null && measure.getHidden();\n+ return Boolean.TRUE.equals(measure.getHidden());",
                "Description": "The null check before invoking `measure.getHidden()` method is not necessary, as Boolean object is automatically null-safe.",
                "Start": 23,
                "End": 23
            },
            {
                "Improvement": "Use String.isBlank() instead of StringUtils.isEmpty()",
                "Change_Diff": "- if (StringUtils.isEmpty(measure.getMaker())) {\n+ if (measure.getMaker().isBlank()) {",
                "Description": "It's better to use `String.isBlank()` method instead of `StringUtils.isEmpty()` to also handle strings that are filled with whitespaces.",
                "Start": 44,
                "End": 44
            },
            {
                "Improvement": "Use String.isBlank() instead of StringUtils.isNotEmpty()",
                "Change_Diff": "- if (StringUtils.isNotEmpty(readPermission)) {\n+ if (!readPermission.isBlank()) {",
                "Description": "It's better to use `String.isBlank()` method instead of `StringUtils.isNotEmpty()` to also handle strings that are filled with whitespaces.",
                "Start": 58,
                "End": 58
            }
        ],
        "Final code": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Measure measure){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class,new ColumnMeta(){\n    @Override public Class<? extends Annotation> annotationType(){\n      return ColumnMeta.class;\n    }\n    @Override public String friendlyName(){\n      return measure.getFriendlyName();\n    }\n    @Override public String description(){\n      return measure.getDescription();\n    }\n    @Override public String category(){\n      return measure.getCategory();\n    }\n    @Override public TableSource tableSource(){\n      return buildTableSource(null);\n    }\n    @Override public String[] tags(){\n      return measure.getTags().toArray(new String[0]);\n    }\n    @Override public String[] values(){\n      return new String[0];\n    }\n    @Override public boolean isHidden(){\n      return Boolean.TRUE.equals(measure.getHidden());\n    }\n    @Override public String filterTemplate(){\n      return measure.getFilterTemplate();\n    }\n    @Override public CardinalitySize size(){\n      return CardinalitySize.UNKNOWN;\n    }\n  }\n);\n  annotations.put(MetricFormula.class,new MetricFormula(){\n    @Override public ArgumentDefinition[] arguments(){\n      return getArgumentDefinitions(measure.getArguments());\n    }\n    @Override public Class<? extends Annotation> annotationType(){\n      return MetricFormula.class;\n    }\n    @Override public String value(){\n      if (measure.getDefinition() != null) {\n        return trimColumnReferences(measure.getDefinition());\n      }\n else {\n        return \"\";\n      }\n    }\n    @Override public Class<? extends MetricProjectionMaker> maker(){\n      if (measure.getMaker().isBlank()) {\n        return DefaultMetricProjectionMaker.class;\n      }\n      try {\n        return Class.forName(measure.getMaker()).asSubclass(MetricProjectionMaker.class);\n      }\n catch (ClassNotFoundException e) {\n        throw new IllegalStateException(e);\n      }\n    }\n  }\n);\n  String readPermission=measure.getReadAccess();\n  if (!readPermission.isBlank()) {\n    annotations.put(ReadPermission.class,new ReadPermission(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return ReadPermission.class;\n      }\n      @Override public String expression(){\n        return readPermission;\n      }\n    }\n);\n  }\n  return annotations;\n}"
    },
    "Old_Method": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Measure measure){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class,new ColumnMeta(){\n    @Override public Class<? extends Annotation> annotationType(){\n      return ColumnMeta.class;\n    }\n    @Override public String friendlyName(){\n      return measure.getFriendlyName();\n    }\n    @Override public String description(){\n      return measure.getDescription();\n    }\n    @Override public String category(){\n      return measure.getCategory();\n    }\n    @Override public TableSource tableSource(){\n      return buildTableSource(null);\n    }\n    @Override public String[] tags(){\n      return measure.getTags().toArray(new String[0]);\n    }\n    @Override public String[] values(){\n      return new String[0];\n    }\n    @Override public boolean isHidden(){\n      return measure.getHidden() != null && measure.getHidden();\n    }\n    @Override public String filterTemplate(){\n      return measure.getFilterTemplate();\n    }\n    @Override public CardinalitySize size(){\n      return CardinalitySize.UNKNOWN;\n    }\n  }\n);\n  annotations.put(MetricFormula.class,new MetricFormula(){\n    @Override public ArgumentDefinition[] arguments(){\n      return getArgumentDefinitions(measure.getArguments());\n    }\n    @Override public Class<? extends Annotation> annotationType(){\n      return MetricFormula.class;\n    }\n    @Override public String value(){\n      if (measure.getDefinition() != null) {\n        return trimColumnReferences(measure.getDefinition());\n      }\n else {\n        return \"\";\n      }\n    }\n    @Override public Class<? extends MetricProjectionMaker> maker(){\n      if (StringUtils.isEmpty(measure.getMaker())) {\n        return DefaultMetricProjectionMaker.class;\n      }\n      try {\n        return Class.forName(measure.getMaker()).asSubclass(MetricProjectionMaker.class);\n      }\n catch (      ClassNotFoundException e) {\n        throw new IllegalStateException(e);\n      }\n    }\n  }\n);\n  String readPermission=measure.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) {\n    annotations.put(ReadPermission.class,new ReadPermission(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return ReadPermission.class;\n      }\n      @Override public String expression(){\n        return readPermission;\n      }\n    }\n);\n  }\n  return annotations;\n}\n",
    "File_Path": "elide/elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/dynamic/TableType.java",
    "Start": 16885,
    "Stop": 20168,
    "Project_Name": "data/projects/elide",
    "Method_Name": "buildAnnotations"
}