{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Reduce code duplication",
                "Change_Diff": "- if (op.equals(HASMEMBER_OP) || op.equals(HASNOMEMBER_OP)) {\n...\n}\nif (op.equals(SUBSETOF_OP) || op.equals(NOTSUBSETOF_OP)) {\n...\n}\nif (op.equals(SUPERSETOF_OP) || op.equals(NOTSUPERSETOF_OP)) {\n...\n}\n+ validateCollectionTypeOperation(op, path);",
                "Description": "The code blocks for HASMEMBER_OP, HASNOMEMBER_OP, SUBSETOF_OP, NOTSUBSETOF_OP, SUPERSETOF_OP, NOTSUPERSETOF_OP are identical. This is a clear sign of code duplication and can be extracted into a method.",
                "Start": 22,
                "End": 49
            },
            {
                "Improvement": "Extract complex expressions into variables or methods",
                "Change_Diff": "- if (FilterPredicate.toManyInPath(dictionary,path) && !allowNestedToManyAssociations) {\n+ boolean hasToManyInPathAndNotAllowed = FilterPredicate.toManyInPath(dictionary,path) && !allowNestedToManyAssociations;\n+ if (hasToManyInPathAndNotAllowed) {",
                "Description": "The expression 'FilterPredicate.toManyInPath(dictionary,path) && !allowNestedToManyAssociations' is complex and used in a conditional statement. It can be extracted into a method or variable for better readability.",
                "Start": 50,
                "End": 52
            },
            {
                "Improvement": "Reduce complexity of argument coercion",
                "Change_Diff": "- values=arguments.stream().map(argument -> ...\n+ values = coerceArguments(arguments, relationshipType);",
                "Description": "The map operation used to coerce arguments into their appropriate types is very complex and hard to understand. It can be extracted into a separate method for better readability and maintainability.",
                "Start": 64,
                "End": 71
            }
        ],
        "Final code": "public FilterExpression visit(ComparisonNode node, Type entityType) {\n...\nvalidateCollectionTypeOperation(op, path);\nboolean hasToManyInPathAndNotAllowed = FilterPredicate.toManyInPath(dictionary,path) && !allowNestedToManyAssociations;\nif (hasToManyInPathAndNotAllowed) {\n...\n}\nvalues = coerceArguments(arguments, relationshipType);\n...\n}"
    },
    "Old_Method": "@Override public FilterExpression visit(ComparisonNode node,Type entityType){\n  ComparisonOperator op=node.getOperator();\n  String relationship=node.getSelector();\n  List<String> arguments=node.getArguments();\n  Path path;\n  if (relationship.contains(\".\") || relationship.contains(\"[\")) {\n    path=buildPath(entityType,relationship);\n  }\n else {\n    path=buildAttribute(entityType,relationship);\n  }\n  if (op.equals(ISEMPTY_OP)) {\n    if (FilterPredicate.toManyInPathExceptLastPathElement(dictionary,path)) {\n      throw new RSQLParseException(String.format(\"Invalid association %s. toMany association has to be the target collection.\",relationship));\n    }\n    return buildIsEmptyOperator(path,arguments);\n  }\n  if (op.equals(HASMEMBER_OP) || op.equals(HASNOMEMBER_OP)) {\n    if (FilterPredicate.toManyInPath(dictionary,path)) {\n      if (FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n        throw new RSQLParseException(\"Invalid Path: Last Path Element cannot be a collection type\");\n      }\n    }\n else     if (!FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n      throw new RSQLParseException(\"Invalid Path: Last Path Element has to be a collection type\");\n    }\n  }\n  if (op.equals(SUBSETOF_OP) || op.equals(NOTSUBSETOF_OP)) {\n    if (FilterPredicate.toManyInPath(dictionary,path)) {\n      if (FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n        throw new RSQLParseException(\"Invalid Path: Last Path Element cannot be a collection type\");\n      }\n    }\n else     if (!FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n      throw new RSQLParseException(\"Invalid Path: Last Path Element has to be a collection type\");\n    }\n  }\n  if (op.equals(SUPERSETOF_OP) || op.equals(NOTSUPERSETOF_OP)) {\n    if (FilterPredicate.toManyInPath(dictionary,path)) {\n      if (FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n        throw new RSQLParseException(\"Invalid Path: Last Path Element cannot be a collection type\");\n      }\n    }\n else     if (!FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n      throw new RSQLParseException(\"Invalid Path: Last Path Element has to be a collection type\");\n    }\n  }\n  if (FilterPredicate.toManyInPath(dictionary,path) && !allowNestedToManyAssociations) {\n    throw new RSQLParseException(String.format(\"Invalid association %s\",relationship));\n  }\n  if (op.equals(ISNULL_OP)) {\n    return buildIsNullOperator(path,arguments);\n  }\n  Type<?> relationshipType=path.lastElement().map(Path.PathElement::getFieldType).orElseThrow(() -> new IllegalStateException(\"Path must not be empty\"));\n  List<Object> values=arguments.stream().map(argument -> isPrimitiveNumberType(relationshipType) || NUMBER_TYPE.isAssignableFrom(relationshipType) ? argument.replace(\"*\",\"\") : argument).map((argument) -> {\n    try {\n      return CoerceUtil.coerce(argument,relationshipType);\n    }\n catch (    InvalidValueException e) {\n      if (coerceValues) {\n        throw e;\n      }\n      return argument;\n    }\n  }\n).collect(Collectors.toList());\n  if (op.equals(RSQLOperators.EQUAL) || op.equals(RSQLOperators.IN)) {\n    return equalityExpression(arguments.get(0),path,values,true);\n  }\n  if (op.equals(INI)) {\n    return equalityExpression(arguments.get(0),path,values,false);\n  }\n  if (op.equals(RSQLOperators.NOT_EQUAL) || op.equals(RSQLOperators.NOT_IN)) {\n    return new NotFilterExpression(equalityExpression(arguments.get(0),path,values,true));\n  }\n  if (op.equals(NOT_INI)) {\n    return new NotFilterExpression(equalityExpression(arguments.get(0),path,values,false));\n  }\n  if (OPERATOR_MAP.containsKey(op)) {\n    return new FilterPredicate(path,OPERATOR_MAP.get(op),values);\n  }\n  throw new RSQLParseException(String.format(\"Invalid Operator %s\",op.getSymbol()));\n}\n",
    "File_Path": "elide/elide-core/src/main/java/com/yahoo/elide/core/filter/dialect/RSQLFilterDialect.java",
    "Start": 21320,
    "Stop": 26983,
    "Project_Name": "data/projects/elide",
    "Method_Name": "visit"
}