{
    "Method_Improvements": {
        "Improvements": [{
            "Improvement": "Refactor anonymous inner classes to separate methods",
            "Change_Diff": "- annotations.put(ColumnMeta.class,new ColumnMeta(){...}\n- annotations.put(MetricFormula.class,new MetricFormula(){...}\n- annotations.put(ReadPermission.class,new ReadPermission(){...}\n+ annotations.put(ColumnMeta.class, buildColumnMeta(measure));\n+ annotations.put(MetricFormula.class, buildMetricFormula(measure));\n+ if (StringUtils.isNotEmpty(measure.getReadAccess())) {\n+    annotations.put(ReadPermission.class, buildReadPermission(measure.getReadAccess()));\n+ }",
            "Description": "The method buildAnnotations(Measure measure) is too large and is doing too many things. It would be better to refactor the anonymous inner classes into separate methods to improve readability and maintainability.",
            "Start": 2,
            "End": 72
        }],
        "Final code": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Measure measure){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class, buildColumnMeta(measure));\n  annotations.put(MetricFormula.class, buildMetricFormula(measure));\n  if (StringUtils.isNotEmpty(measure.getReadAccess())) {\n    annotations.put(ReadPermission.class, buildReadPermission(measure.getReadAccess()));\n  }\n  return annotations;\n}\n\nprivate static ColumnMeta buildColumnMeta(Measure measure) {\n  return new ColumnMeta(){...};\n}\n\nprivate static MetricFormula buildMetricFormula(Measure measure) {\n  return new MetricFormula(){...};\n}\n\nprivate static ReadPermission buildReadPermission(String readPermission) {\n  return new ReadPermission(){...};\n}"
    },
    "Old_Method": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Measure measure){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class,new ColumnMeta(){\n    @Override public Class<? extends Annotation> annotationType(){\n      return ColumnMeta.class;\n    }\n    @Override public String friendlyName(){\n      return measure.getFriendlyName();\n    }\n    @Override public String description(){\n      return measure.getDescription();\n    }\n    @Override public String category(){\n      return measure.getCategory();\n    }\n    @Override public TableSource tableSource(){\n      return buildTableSource(null);\n    }\n    @Override public String[] tags(){\n      return measure.getTags().toArray(new String[0]);\n    }\n    @Override public String[] values(){\n      return new String[0];\n    }\n    @Override public boolean isHidden(){\n      return measure.getHidden() != null && measure.getHidden();\n    }\n    @Override public String filterTemplate(){\n      return measure.getFilterTemplate();\n    }\n    @Override public CardinalitySize size(){\n      return CardinalitySize.UNKNOWN;\n    }\n  }\n);\n  annotations.put(MetricFormula.class,new MetricFormula(){\n    @Override public ArgumentDefinition[] arguments(){\n      return getArgumentDefinitions(measure.getArguments());\n    }\n    @Override public Class<? extends Annotation> annotationType(){\n      return MetricFormula.class;\n    }\n    @Override public String value(){\n      if (measure.getDefinition() != null) {\n        return trimColumnReferences(measure.getDefinition());\n      }\n else {\n        return \"\";\n      }\n    }\n    @Override public Class<? extends MetricProjectionMaker> maker(){\n      if (StringUtils.isEmpty(measure.getMaker())) {\n        return DefaultMetricProjectionMaker.class;\n      }\n      try {\n        return Class.forName(measure.getMaker()).asSubclass(MetricProjectionMaker.class);\n      }\n catch (      ClassNotFoundException e) {\n        throw new IllegalStateException(e);\n      }\n    }\n  }\n);\n  String readPermission=measure.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) {\n    annotations.put(ReadPermission.class,new ReadPermission(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return ReadPermission.class;\n      }\n      @Override public String expression(){\n        return readPermission;\n      }\n    }\n);\n  }\n  return annotations;\n}\n",
    "File_Path": "elide/elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/dynamic/TableType.java",
    "Start": 16885,
    "Stop": 20168,
    "Project_Name": "data/projects/elide",
    "Method_Name": "buildAnnotations"
}