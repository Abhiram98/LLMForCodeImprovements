{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Replace Anonymous Classes with Lambda Expressions",
                "Change_Diff": "- annotations.put(ColumnMeta.class,new ColumnMeta(){...});\n- annotations.put(DimensionFormula.class,new DimensionFormula(){...});\n- annotations.put(ReadPermission.class,new ReadPermission(){...});\n- annotations.put(Temporal.class,new Temporal(){...});\n+ annotations.put(ColumnMeta.class,() -> new ColumnMeta(...));\n+ annotations.put(DimensionFormula.class,() -> new DimensionFormula(...));\n+ annotations.put(ReadPermission.class,() -> new ReadPermission(...));\n+ annotations.put(Temporal.class,() -> new Temporal(...));",
                "Description": "Java 8 introduced lambda expressions, which can replace most uses of anonymous classes. They are more concise and read more like the procedural code they represent. They also eliminate a lot of boilerplate code.",
                "Start": 4,
                "End": 71
            },
            {
                "Improvement": "Replace the usage of String#toUpperCase(Locale.ENGLISH) with String#equalsIgnoreCase(String)",
                "Change_Diff": "- if (dimension.getType().toUpperCase(Locale.ENGLISH).equals(ENUM_ORDINAL))\n+ if (dimension.getType().equalsIgnoreCase(ENUM_ORDINAL))",
                "Description": "The equalsIgnoreCase method checks whether two String are equal or not ignoring the case considerations. It returns true if the argument is not null and it represents an equivalent String ignoring case, else false.",
                "Start": 59,
                "End": 59
            },
            {
                "Improvement": "Use Optional class for null safety",
                "Change_Diff": "- int numGrains=dimension.getGrains() == null ? 0 : dimension.getGrains().size();\n+ int numGrains=Optional.ofNullable(dimension.getGrains()).map(Collection::size).orElse(0);",
                "Description": "The Optional class in Java is a container object that may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value. Otherwise, it helps to avoid null pointer exceptions.",
                "Start": 69,
                "End": 69
            }
        ],
        "Final code": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Dimension dimension){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class,() -> new ColumnMeta(...));\n...\n  if (dimension.getType().equalsIgnoreCase(ENUM_ORDINAL)) {\n    annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n  }\n...\n  int numGrains=Optional.ofNullable(dimension.getGrains()).map(Collection::size).orElse(0);\n...\n  return annotations;\n}"
    },
    "Old_Method": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Dimension dimension){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class,new ColumnMeta(){\n    @Override public Class<? extends Annotation> annotationType(){\n      return ColumnMeta.class;\n    }\n    @Override public String friendlyName(){\n      return dimension.getFriendlyName();\n    }\n    @Override public String description(){\n      return dimension.getDescription();\n    }\n    @Override public String category(){\n      return dimension.getCategory();\n    }\n    @Override public TableSource tableSource(){\n      return buildTableSource(dimension.getTableSource());\n    }\n    @Override public String[] tags(){\n      return dimension.getTags().toArray(new String[0]);\n    }\n    @Override public String[] values(){\n      return dimension.getValues().toArray(new String[0]);\n    }\n    @Override public boolean isHidden(){\n      return dimension.getHidden() != null && dimension.getHidden();\n    }\n    @Override public String filterTemplate(){\n      return dimension.getFilterTemplate();\n    }\n    @Override public CardinalitySize size(){\n      if (StringUtils.isEmpty(dimension.getCardinality())) {\n        return CardinalitySize.UNKNOWN;\n      }\n      return CardinalitySize.valueOf(dimension.getCardinality().toUpperCase(Locale.ENGLISH));\n    }\n  }\n);\n  annotations.put(DimensionFormula.class,new DimensionFormula(){\n    @Override public ArgumentDefinition[] arguments(){\n      return getArgumentDefinitions(dimension.getArguments());\n    }\n    @Override public Class<? extends Annotation> annotationType(){\n      return DimensionFormula.class;\n    }\n    @Override public String value(){\n      return trimColumnReferences(dimension.getDefinition());\n    }\n  }\n);\n  String readPermission=dimension.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) {\n    annotations.put(ReadPermission.class,new ReadPermission(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return ReadPermission.class;\n      }\n      @Override public String expression(){\n        return readPermission;\n      }\n    }\n);\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) {\n    annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) {\n    annotations.put(Temporal.class,new Temporal(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return Temporal.class;\n      }\n      @Override public TimeGrainDefinition[] grains(){\n        int numGrains=dimension.getGrains() == null ? 0 : dimension.getGrains().size();\n        TimeGrainDefinition[] definitions=new TimeGrainDefinition[numGrains];\n        for (int idx=0; idx < numGrains; idx++) {\n          Grain grain=dimension.getGrains().get(idx);\n          definitions[idx]=new TimeGrainDefinition(){\n            @Override public Class<? extends Annotation> annotationType(){\n              return TimeGrainDefinition.class;\n            }\n            @Override public TimeGrain grain(){\n              if (grain.getType() == null) {\n                return TimeGrain.DAY;\n              }\n              return TimeGrain.valueOf(grain.getType().name());\n            }\n            @Override public String expression(){\n              String sql=grain.getSql();\n              if (StringUtils.isEmpty(sql)) {\n                return \"{{$$column.expr}}\";\n              }\n              return grain.getSql();\n            }\n          }\n;\n        }\n        return definitions;\n      }\n      @Override public String timeZone(){\n        return \"UTC\";\n      }\n    }\n);\n  }\n  return annotations;\n}\n",
    "File_Path": "elide/elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/dynamic/TableType.java",
    "Start": 21178,
    "Stop": 26304,
    "Project_Name": "data/projects/elide",
    "Method_Name": "buildAnnotations"
}