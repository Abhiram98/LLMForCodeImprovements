{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Replace anonymous classes with lambda expressions",
                "Change_Diff": "- new ColumnMeta(){...}\n+ () -> ColumnMeta {...}\n- new DimensionFormula(){...}\n+ () -> DimensionFormula {...}\n- new ReadPermission(){...}\n+ () -> ReadPermission {...}\n- new Temporal(){...}\n+ () -> Temporal {...}",
                "Description": "Java 8 introduced lambda expressions, which provide a clear and concise way to represent one method interface using an expression. Lambda expressions make the code more readable and less bulky. Replace anonymous classes with lambda expressions where possible.",
                "Start": 3,
                "End": 52
            },
            {
                "Improvement": "Use Optional instead of null checks",
                "Change_Diff": "- return dimension.getHidden() != null && dimension.getHidden();\n+ return Optional.ofNullable(dimension.getHidden()).orElse(false);\n- if (grain.getType() == null) {\n+ if (!Optional.ofNullable(grain.getType()).isPresent()) {",
                "Description": "To avoid NullPointerExceptions, use Optional to wrap the return value of methods which may return null. In this code, dimension.getHidden() and grain.getType() may return null, so replace the null check with Optional.",
                "Start": 17,
                "End": 52
            },
            {
                "Improvement": "Use String constants for repeatedly used strings",
                "Change_Diff": "- if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) {...}\n+ if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL_CONSTANT)) {...}\n- if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) {...}\n+ if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME_CONSTANT)) {...}",
                "Description": "For improved readability and maintainability, replace repeatedly used strings such as 'ENUM_ORDINAL' and 'TIME' with string constants.",
                "Start": 42,
                "End": 50
            }
        ],
        "Final code": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Dimension dimension){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class, () -> new ColumnMeta {...} );\n  annotations.put(DimensionFormula.class, () -> new DimensionFormula {...} );\n  String readPermission=dimension.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) {\n    annotations.put(ReadPermission.class, () -> new ReadPermission {...} );\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL_CONSTANT)) {\n    annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME_CONSTANT)) {\n    annotations.put(Temporal.class, () -> new Temporal {...} );\n  }\n  return annotations;\n}"
    },
    "Old_Method": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Dimension dimension){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class,new ColumnMeta(){\n    @Override public Class<? extends Annotation> annotationType(){\n      return ColumnMeta.class;\n    }\n    @Override public String friendlyName(){\n      return dimension.getFriendlyName();\n    }\n    @Override public String description(){\n      return dimension.getDescription();\n    }\n    @Override public String category(){\n      return dimension.getCategory();\n    }\n    @Override public TableSource tableSource(){\n      return buildTableSource(dimension.getTableSource());\n    }\n    @Override public String[] tags(){\n      return dimension.getTags().toArray(new String[0]);\n    }\n    @Override public String[] values(){\n      return dimension.getValues().toArray(new String[0]);\n    }\n    @Override public boolean isHidden(){\n      return dimension.getHidden() != null && dimension.getHidden();\n    }\n    @Override public String filterTemplate(){\n      return dimension.getFilterTemplate();\n    }\n    @Override public CardinalitySize size(){\n      if (StringUtils.isEmpty(dimension.getCardinality())) {\n        return CardinalitySize.UNKNOWN;\n      }\n      return CardinalitySize.valueOf(dimension.getCardinality().toUpperCase(Locale.ENGLISH));\n    }\n  }\n);\n  annotations.put(DimensionFormula.class,new DimensionFormula(){\n    @Override public ArgumentDefinition[] arguments(){\n      return getArgumentDefinitions(dimension.getArguments());\n    }\n    @Override public Class<? extends Annotation> annotationType(){\n      return DimensionFormula.class;\n    }\n    @Override public String value(){\n      return trimColumnReferences(dimension.getDefinition());\n    }\n  }\n);\n  String readPermission=dimension.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) {\n    annotations.put(ReadPermission.class,new ReadPermission(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return ReadPermission.class;\n      }\n      @Override public String expression(){\n        return readPermission;\n      }\n    }\n);\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) {\n    annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) {\n    annotations.put(Temporal.class,new Temporal(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return Temporal.class;\n      }\n      @Override public TimeGrainDefinition[] grains(){\n        int numGrains=dimension.getGrains() == null ? 0 : dimension.getGrains().size();\n        TimeGrainDefinition[] definitions=new TimeGrainDefinition[numGrains];\n        for (int idx=0; idx < numGrains; idx++) {\n          Grain grain=dimension.getGrains().get(idx);\n          definitions[idx]=new TimeGrainDefinition(){\n            @Override public Class<? extends Annotation> annotationType(){\n              return TimeGrainDefinition.class;\n            }\n            @Override public TimeGrain grain(){\n              if (grain.getType() == null) {\n                return TimeGrain.DAY;\n              }\n              return TimeGrain.valueOf(grain.getType().name());\n            }\n            @Override public String expression(){\n              String sql=grain.getSql();\n              if (StringUtils.isEmpty(sql)) {\n                return \"{{$$column.expr}}\";\n              }\n              return grain.getSql();\n            }\n          }\n;\n        }\n        return definitions;\n      }\n      @Override public String timeZone(){\n        return \"UTC\";\n      }\n    }\n);\n  }\n  return annotations;\n}\n",
    "File_Path": "elide/elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/dynamic/TableType.java",
    "Start": 21178,
    "Stop": 26304,
    "Project_Name": "data/projects/elide",
    "Method_Name": "buildAnnotations"
}