{
    "Method_Improvements": {
        "Improvements": [{
            "Improvement": "Extract complex logic into helper methods",
            "Change_Diff": "- annotations.put(ColumnMeta.class,new ColumnMeta(){...};\n- annotations.put(DimensionFormula.class,new DimensionFormula(){...};\n- annotations.put(ReadPermission.class,new ReadPermission(){...};\n- annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n- annotations.put(Temporal.class,new Temporal(){...};\n+ annotations.put(ColumnMeta.class, buildColumnMetaAnnotation(dimension));\n+ annotations.put(DimensionFormula.class, buildDimensionFormulaAnnotation(dimension));\n+ if (StringUtils.isNotEmpty(readPermission)) { annotations.put(ReadPermission.class, buildReadPermissionAnnotation(readPermission)); }\n+ if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) { annotations.put(Enumerated.class, getEnumeratedAnnotation(EnumType.ORDINAL)); }\n+ if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) { annotations.put(Temporal.class, buildTemporalAnnotation(dimension)); }",
            "Description": "The method buildAnnotations is quite complex and long, resulting in decreased readability and maintainability. The logic for generating each Annotation can be extracted into separate helper methods to improve code organization and readability.",
            "Start": 4,
            "End": 90
        }],
        "Final code": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Dimension dimension){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class, buildColumnMetaAnnotation(dimension));\n  annotations.put(DimensionFormula.class, buildDimensionFormulaAnnotation(dimension));\n  String readPermission=dimension.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) { annotations.put(ReadPermission.class, buildReadPermissionAnnotation(readPermission)); }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) { annotations.put(Enumerated.class, getEnumeratedAnnotation(EnumType.ORDINAL)); }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) { annotations.put(Temporal.class, buildTemporalAnnotation(dimension)); }\n  return annotations;\n}\n\nprivate static ColumnMeta buildColumnMetaAnnotation(Dimension dimension) { /* code to generate ColumnMeta annotation */ }\nprivate static DimensionFormula buildDimensionFormulaAnnotation(Dimension dimension) { /* code to generate DimensionFormula annotation */ }\nprivate static ReadPermission buildReadPermissionAnnotation(String readPermission) { /* code to generate ReadPermission annotation */ }\nprivate static Enumerated getEnumeratedAnnotation(EnumType enumType) { /* code to generate Enumerated annotation */ }\nprivate static Temporal buildTemporalAnnotation(Dimension dimension) { /* code to generate Temporal annotation */ }"
    },
    "Old_Method": "private static Map<Class<? extends Annotation>,Annotation> buildAnnotations(Dimension dimension){\n  Map<Class<? extends Annotation>,Annotation> annotations=new HashMap<>();\n  annotations.put(ColumnMeta.class,new ColumnMeta(){\n    @Override public Class<? extends Annotation> annotationType(){\n      return ColumnMeta.class;\n    }\n    @Override public String friendlyName(){\n      return dimension.getFriendlyName();\n    }\n    @Override public String description(){\n      return dimension.getDescription();\n    }\n    @Override public String category(){\n      return dimension.getCategory();\n    }\n    @Override public TableSource tableSource(){\n      return buildTableSource(dimension.getTableSource());\n    }\n    @Override public String[] tags(){\n      return dimension.getTags().toArray(new String[0]);\n    }\n    @Override public String[] values(){\n      return dimension.getValues().toArray(new String[0]);\n    }\n    @Override public boolean isHidden(){\n      return dimension.getHidden() != null && dimension.getHidden();\n    }\n    @Override public String filterTemplate(){\n      return dimension.getFilterTemplate();\n    }\n    @Override public CardinalitySize size(){\n      if (StringUtils.isEmpty(dimension.getCardinality())) {\n        return CardinalitySize.UNKNOWN;\n      }\n      return CardinalitySize.valueOf(dimension.getCardinality().toUpperCase(Locale.ENGLISH));\n    }\n  }\n);\n  annotations.put(DimensionFormula.class,new DimensionFormula(){\n    @Override public ArgumentDefinition[] arguments(){\n      return getArgumentDefinitions(dimension.getArguments());\n    }\n    @Override public Class<? extends Annotation> annotationType(){\n      return DimensionFormula.class;\n    }\n    @Override public String value(){\n      return trimColumnReferences(dimension.getDefinition());\n    }\n  }\n);\n  String readPermission=dimension.getReadAccess();\n  if (StringUtils.isNotEmpty(readPermission)) {\n    annotations.put(ReadPermission.class,new ReadPermission(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return ReadPermission.class;\n      }\n      @Override public String expression(){\n        return readPermission;\n      }\n    }\n);\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(ENUM_ORDINAL)) {\n    annotations.put(Enumerated.class,getEnumeratedAnnotation(EnumType.ORDINAL));\n  }\n  if (dimension.getType().toUpperCase(Locale.ROOT).equals(TIME)) {\n    annotations.put(Temporal.class,new Temporal(){\n      @Override public Class<? extends Annotation> annotationType(){\n        return Temporal.class;\n      }\n      @Override public TimeGrainDefinition[] grains(){\n        int numGrains=dimension.getGrains() == null ? 0 : dimension.getGrains().size();\n        TimeGrainDefinition[] definitions=new TimeGrainDefinition[numGrains];\n        for (int idx=0; idx < numGrains; idx++) {\n          Grain grain=dimension.getGrains().get(idx);\n          definitions[idx]=new TimeGrainDefinition(){\n            @Override public Class<? extends Annotation> annotationType(){\n              return TimeGrainDefinition.class;\n            }\n            @Override public TimeGrain grain(){\n              if (grain.getType() == null) {\n                return TimeGrain.DAY;\n              }\n              return TimeGrain.valueOf(grain.getType().name());\n            }\n            @Override public String expression(){\n              String sql=grain.getSql();\n              if (StringUtils.isEmpty(sql)) {\n                return \"{{$$column.expr}}\";\n              }\n              return grain.getSql();\n            }\n          }\n;\n        }\n        return definitions;\n      }\n      @Override public String timeZone(){\n        return \"UTC\";\n      }\n    }\n);\n  }\n  return annotations;\n}\n",
    "File_Path": "elide/elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/dynamic/TableType.java",
    "Start": 21178,
    "Stop": 26304,
    "Project_Name": "data/projects/elide",
    "Method_Name": "buildAnnotations"
}