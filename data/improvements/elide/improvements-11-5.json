{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Avoid `throws Exception` in the method signature",
                "Change_Diff": "- public void init() throws Exception {\n+ public void init() throws IOException, IllegalAccessException, InstantiationException {",
                "Description": "It is generally a bad practice to throw `Exception` as it can mask different types of exceptions that can occur during the execution of this method. Instead, it would be better to specify the exact types of exceptions that can be thrown.",
                "Start": 1,
                "End": 1
            },
            {
                "Improvement": "Replace multiple map initializations with a single line",
                "Change_Diff": "- Map<String,Class<? extends Check>> checks=new HashMap<>();\n- if (getAnalyticProperties().enableDynamicModelConfigAPI()) {\n- checks.put(ConfigChecks.CAN_CREATE_CONFIG,ConfigChecks.CanCreate.class);\n- checks.put(ConfigChecks.CAN_READ_CONFIG,ConfigChecks.CanRead.class);\n- checks.put(ConfigChecks.CAN_DELETE_CONFIG,ConfigChecks.CanDelete.class);\n- checks.put(ConfigChecks.CAN_UPDATE_CONFIG,ConfigChecks.CanNotUpdate.class);\n+ Map<String,Class<? extends Check>> checks = getAnalyticProperties().enableDynamicModelConfigAPI() ? Map.of(ConfigChecks.CAN_CREATE_CONFIG, ConfigChecks.CanCreate.class, ConfigChecks.CAN_READ_CONFIG, ConfigChecks.CanRead.class, ConfigChecks.CAN_DELETE_CONFIG, ConfigChecks.CanDelete.class, ConfigChecks.CAN_UPDATE_CONFIG, ConfigChecks.CanNotUpdate.class) : new HashMap<>();",
                "Description": "The map `checks` is initialized and then populated with values. This could be simplified by initializing and populating the map in a single line using `Map.of`.",
                "Start": 5,
                "End": 10
            }
        ],
        "Final code": "@BeforeAll public void init() throws IOException, IllegalAccessException, InstantiationException {\n  configRoot=Paths.get(Files.createTempDirectory(\"test\").toFile().getAbsolutePath(),\"1\",\"2\",\"3\",\"4\",\"5\");\n  Files.createDirectories(configRoot);\n  settings=new ElideStandaloneTestSettings(){\n    @Override public EntityDictionary getEntityDictionary(ServiceLocator injector,ClassScanner scanner,Optional<DynamicConfiguration> dynamicConfiguration,Set<Type<?>> entitiesToExclude){\n      Map<String,Class<? extends Check>> checks = getAnalyticProperties().enableDynamicModelConfigAPI() ? Map.of(ConfigChecks.CAN_CREATE_CONFIG, ConfigChecks.CanCreate.class, ConfigChecks.CAN_READ_CONFIG, ConfigChecks.CanRead.class, ConfigChecks.CAN_DELETE_CONFIG, ConfigChecks.CanDelete.class, ConfigChecks.CAN_UPDATE_CONFIG, ConfigChecks.CanNotUpdate.class) : new HashMap<>();\n      EntityDictionary dictionary=new EntityDictionary(checks,new HashMap<>(),new Injector(){\n        @Override public void inject(Object entity){\n          injector.inject(entity);\n        }\n        @Override public <T>T instantiate(Class<T> cls){\n          return injector.create(cls);\n        }\n      },CoerceUtil::lookup,entitiesToExclude,scanner);\n      dynamicConfiguration.map(DynamicConfiguration::getRoles).orElseGet(Collections::emptySet).forEach(role -> dictionary.addRoleCheck(role,new Role.RoleMemberCheck(role)));\n      return dictionary;\n    }\n    @Override public ElideStandaloneAnalyticSettings getAnalyticProperties(){\n      return new ElideStandaloneAnalyticSettings(){\n        @Override public boolean enableDynamicModelConfig(){\n          return true;\n        }\n        @Override public boolean enableDynamicModelConfigAPI(){\n          return true;\n        }\n        @Override public String getDynamicConfigPath(){\n          return configRoot.toFile().getAbsolutePath();\n        }\n        @Override public boolean enableAggregationDataStore(){\n          return true;\n        }\n        @Override public boolean enableMetaDataStore(){\n          return true;\n        }\n      };\n    }\n  };\n  elide=new ElideStandalone(settings);\n  elide.start(false);\n}"
    },
    "Old_Method": "@BeforeAll public void init() throws Exception {\n  configRoot=Paths.get(Files.createTempDirectory(\"test\").toFile().getAbsolutePath(),\"1\",\"2\",\"3\",\"4\",\"5\");\n  Files.createDirectories(configRoot);\n  settings=new ElideStandaloneTestSettings(){\n    @Override public EntityDictionary getEntityDictionary(    ServiceLocator injector,    ClassScanner scanner,    Optional<DynamicConfiguration> dynamicConfiguration,    Set<Type<?>> entitiesToExclude){\n      Map<String,Class<? extends Check>> checks=new HashMap<>();\n      if (getAnalyticProperties().enableDynamicModelConfigAPI()) {\n        checks.put(ConfigChecks.CAN_CREATE_CONFIG,ConfigChecks.CanCreate.class);\n        checks.put(ConfigChecks.CAN_READ_CONFIG,ConfigChecks.CanRead.class);\n        checks.put(ConfigChecks.CAN_DELETE_CONFIG,ConfigChecks.CanDelete.class);\n        checks.put(ConfigChecks.CAN_UPDATE_CONFIG,ConfigChecks.CanNotUpdate.class);\n      }\n      EntityDictionary dictionary=new EntityDictionary(checks,new HashMap<>(),new Injector(){\n        @Override public void inject(        Object entity){\n          injector.inject(entity);\n        }\n        @Override public <T>T instantiate(        Class<T> cls){\n          return injector.create(cls);\n        }\n      }\n,CoerceUtil::lookup,entitiesToExclude,scanner);\n      dynamicConfiguration.map(DynamicConfiguration::getRoles).orElseGet(Collections::emptySet).forEach(role -> dictionary.addRoleCheck(role,new Role.RoleMemberCheck(role)));\n      return dictionary;\n    }\n    @Override public ElideStandaloneAnalyticSettings getAnalyticProperties(){\n      return new ElideStandaloneAnalyticSettings(){\n        @Override public boolean enableDynamicModelConfig(){\n          return true;\n        }\n        @Override public boolean enableDynamicModelConfigAPI(){\n          return true;\n        }\n        @Override public String getDynamicConfigPath(){\n          return configRoot.toFile().getAbsolutePath();\n        }\n        @Override public boolean enableAggregationDataStore(){\n          return true;\n        }\n        @Override public boolean enableMetaDataStore(){\n          return true;\n        }\n      }\n;\n    }\n  }\n;\n  elide=new ElideStandalone(settings);\n  elide.start(false);\n}\n",
    "File_Path": "elide/elide-standalone/src/test/java/example/ElideStandaloneConfigStoreTest.java",
    "Start": 2770,
    "Stop": 6011,
    "Project_Name": "data/projects/elide",
    "Method_Name": "init"
}