{
    "Method_Improvements": {
        "Improvements": [
            {
                "Improvement": "Refactor repeated code blocks",
                "Change_Diff": "- if (op.equals(HASMEMBER_OP) || op.equals(HASNOMEMBER_OP)) {\n+ if (isMemberOperator(op)) {\n- if (op.equals(SUBSETOF_OP) || op.equals(NOTSUBSETOF_OP)) {\n+ if (isSubsetOperator(op)) {\n- if (op.equals(SUPERSETOF_OP) || op.equals(NOTSUPERSETOF_OP)) {\n+ if (isSupersetOperator(op)) {",
                "Description": "There are repeated code blocks that check for the same conditions and throw the same exceptions. These can be refactored for brevity and readability.",
                "Start": 17,
                "End": 40
            },
            {
                "Improvement": "Extract complex expressions to methods",
                "Change_Diff": "- Type<?> relationshipType=path.lastElement().map(Path.PathElement::getFieldType).orElseThrow(() -> new IllegalStateException(\"Path must not be empty\"));\n+ Type<?> relationshipType = getRelationshipType(path);",
                "Description": "There are several complex expressions that could be better understood if they were wrapped in a method with a descriptive name.",
                "Start": 47,
                "End": 59
            },
            {
                "Improvement": "Refactor nested conditionals",
                "Change_Diff": "- if (op.equals(HASMEMBER_OP) || op.equals(HASNOMEMBER_OP)) {\n+ if (isMemberOperator(op)) {\n- if (op.equals(SUBSETOF_OP) || op.equals(NOTSUBSETOF_OP)) {\n+ if (isSubsetOperator(op)) {\n- if (op.equals(SUPERSETOF_OP) || op.equals(NOTSUPERSETOF_OP)) {\n+ if (isSupersetOperator(op)) {",
                "Description": "The if-else statements are nested and could be refactored for better readability.",
                "Start": 17,
                "End": 40
            }
        ],
        "Final code": "@Override\npublic FilterExpression visit(ComparisonNode node, Type entityType){\n  ComparisonOperator op = node.getOperator();\n  String relationship = node.getSelector();\n  List<String> arguments = node.getArguments();\n  Path path = buildPathBasedOnRelationship(entityType, relationship);\n\n  if (isMemberOperator(op) || isSubsetOperator(op) || isSupersetOperator(op)) {\n    validatePath(dictionary, path);\n  }\n\n  if (FilterPredicate.toManyInPath(dictionary, path) && !allowNestedToManyAssociations) {\n    throw new RSQLParseException(String.format(\"Invalid association %s\", relationship));\n  }\n\n  if (op.equals(ISNULL_OP)) {\n    return buildIsNullOperator(path, arguments);\n  }\n\n  Type<?> relationshipType = getRelationshipType(path);\n\n  List<Object> values = buildValues(arguments, relationshipType);\n\n  if (op.equals(RSQLOperators.EQUAL) || op.equals(RSQLOperators.IN)) {\n    return equalityExpression(arguments.get(0), path, values, true);\n  }\n\n  if (op.equals(INI)) {\n    return equalityExpression(arguments.get(0), path, values, false);\n  }\n\n  if (op.equals(RSQLOperators.NOT_EQUAL) || op.equals(RSQLOperators.NOT_IN)) {\n    return new NotFilterExpression(equalityExpression(arguments.get(0), path, values, true));\n  }\n\n  if (op.equals(NOT_INI)) {\n    return new NotFilterExpression(equalityExpression(arguments.get(0), path, values, false));\n  }\n\n  if (OPERATOR_MAP.containsKey(op)) {\n    return new FilterPredicate(path, OPERATOR_MAP.get(op), values);\n  }\n\n  throw new RSQLParseException(String.format(\"Invalid Operator %s\", op.getSymbol()));\n}"
    },
    "Old_Method": "@Override public FilterExpression visit(ComparisonNode node,Type entityType){\n  ComparisonOperator op=node.getOperator();\n  String relationship=node.getSelector();\n  List<String> arguments=node.getArguments();\n  Path path;\n  if (relationship.contains(\".\") || relationship.contains(\"[\")) {\n    path=buildPath(entityType,relationship);\n  }\n else {\n    path=buildAttribute(entityType,relationship);\n  }\n  if (op.equals(ISEMPTY_OP)) {\n    if (FilterPredicate.toManyInPathExceptLastPathElement(dictionary,path)) {\n      throw new RSQLParseException(String.format(\"Invalid association %s. toMany association has to be the target collection.\",relationship));\n    }\n    return buildIsEmptyOperator(path,arguments);\n  }\n  if (op.equals(HASMEMBER_OP) || op.equals(HASNOMEMBER_OP)) {\n    if (FilterPredicate.toManyInPath(dictionary,path)) {\n      if (FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n        throw new RSQLParseException(\"Invalid Path: Last Path Element cannot be a collection type\");\n      }\n    }\n else     if (!FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n      throw new RSQLParseException(\"Invalid Path: Last Path Element has to be a collection type\");\n    }\n  }\n  if (op.equals(SUBSETOF_OP) || op.equals(NOTSUBSETOF_OP)) {\n    if (FilterPredicate.toManyInPath(dictionary,path)) {\n      if (FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n        throw new RSQLParseException(\"Invalid Path: Last Path Element cannot be a collection type\");\n      }\n    }\n else     if (!FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n      throw new RSQLParseException(\"Invalid Path: Last Path Element has to be a collection type\");\n    }\n  }\n  if (op.equals(SUPERSETOF_OP) || op.equals(NOTSUPERSETOF_OP)) {\n    if (FilterPredicate.toManyInPath(dictionary,path)) {\n      if (FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n        throw new RSQLParseException(\"Invalid Path: Last Path Element cannot be a collection type\");\n      }\n    }\n else     if (!FilterPredicate.isLastPathElementAssignableFrom(dictionary,path,COLLECTION_TYPE)) {\n      throw new RSQLParseException(\"Invalid Path: Last Path Element has to be a collection type\");\n    }\n  }\n  if (FilterPredicate.toManyInPath(dictionary,path) && !allowNestedToManyAssociations) {\n    throw new RSQLParseException(String.format(\"Invalid association %s\",relationship));\n  }\n  if (op.equals(ISNULL_OP)) {\n    return buildIsNullOperator(path,arguments);\n  }\n  Type<?> relationshipType=path.lastElement().map(Path.PathElement::getFieldType).orElseThrow(() -> new IllegalStateException(\"Path must not be empty\"));\n  List<Object> values=arguments.stream().map(argument -> isPrimitiveNumberType(relationshipType) || NUMBER_TYPE.isAssignableFrom(relationshipType) ? argument.replace(\"*\",\"\") : argument).map((argument) -> {\n    try {\n      return CoerceUtil.coerce(argument,relationshipType);\n    }\n catch (    InvalidValueException e) {\n      if (coerceValues) {\n        throw e;\n      }\n      return argument;\n    }\n  }\n).collect(Collectors.toList());\n  if (op.equals(RSQLOperators.EQUAL) || op.equals(RSQLOperators.IN)) {\n    return equalityExpression(arguments.get(0),path,values,true);\n  }\n  if (op.equals(INI)) {\n    return equalityExpression(arguments.get(0),path,values,false);\n  }\n  if (op.equals(RSQLOperators.NOT_EQUAL) || op.equals(RSQLOperators.NOT_IN)) {\n    return new NotFilterExpression(equalityExpression(arguments.get(0),path,values,true));\n  }\n  if (op.equals(NOT_INI)) {\n    return new NotFilterExpression(equalityExpression(arguments.get(0),path,values,false));\n  }\n  if (OPERATOR_MAP.containsKey(op)) {\n    return new FilterPredicate(path,OPERATOR_MAP.get(op),values);\n  }\n  throw new RSQLParseException(String.format(\"Invalid Operator %s\",op.getSymbol()));\n}\n",
    "File_Path": "elide/elide-core/src/main/java/com/yahoo/elide/core/filter/dialect/RSQLFilterDialect.java",
    "Start": 21320,
    "Stop": 26983,
    "Project_Name": "data/projects/elide",
    "Method_Name": "visit"
}