[
    {
        "Old_Method": "/** \n * Returns a human readable string summary of the internal state of the given Memory. Used primarily in testing.\n * @param mem the given Memory\n * @param sketchType the sketch type: FLOATS_SKETCH, DOUBLES_SKETCH, or ITEMS_SKETCH.\n * @param includeData if true, includes detail of retained data.\n * @param serDe must be supplied for KllItemsSketch, otherwise can be null.\n * @return the summary string.\n */\nstatic <T>String toString(final Memory mem,final SketchType sketchType,final boolean includeData,final ArrayOfItemsSerDe<T> serDe){\n  if (sketchType == ITEMS_SKETCH) {\n    Objects.requireNonNull(serDe,\"SerDe parameter must not be null for ITEMS_SKETCH.\");\n  }\n  final KllMemoryValidate memVal=new KllMemoryValidate(mem,sketchType,serDe);\n  final SketchStructure myStructure=memVal.sketchStructure;\n  final int flags=memVal.flags & 0XFF;\n  final String flagsStr=(flags) + \", 0x\" + (Integer.toHexString(flags))+ \", \"+ zeroPad(Integer.toBinaryString(flags),8);\n  final int preInts=memVal.preInts;\n  final boolean emptyFlag=memVal.emptyFlag;\n  final int sketchBytes=memVal.sketchBytes;\n  final int typeBytes=sketchType == DOUBLES_SKETCH ? Double.BYTES : Float.BYTES;\n  final int familyID=getMemoryFamilyID(mem);\n  final String famName=idToFamily(familyID).toString();\n  final StringBuilder sb=new StringBuilder();\n  sb.append(Util.LS).append(\"### KLL SKETCH MEMORY SUMMARY:\").append(LS);\n  sb.append(\"Sketch Type                          : \").append(sketchType.toString()).append(LS);\n  sb.append(\"SketchStructure                      : \").append(myStructure.toString()).append(LS);\n  sb.append(\"Byte   0       : Preamble Ints       : \").append(preInts).append(LS);\n  sb.append(\"Byte   1       : SerVer              : \").append(memVal.serVer).append(LS);\n  sb.append(\"Byte   2       : FamilyID            : \").append(memVal.familyID).append(LS);\n  sb.append(\"               : FamilyName          : \").append(famName).append(LS);\n  sb.append(\"Byte   3       : Flags Field         : \").append(flagsStr).append(LS);\n  sb.append(\"            Bit: Flag Name           : \").append(LS);\n  sb.append(\"              0: EMPTY               : \").append(emptyFlag).append(LS);\n  sb.append(\"              1: LEVEL_ZERO_SORTED   : \").append(memVal.level0SortedFlag).append(LS);\n  sb.append(\"Bytes  4-5     : K                   : \").append(memVal.k).append(LS);\n  sb.append(\"Byte   6       : Min Level Cap, M    : \").append(memVal.m).append(LS);\n  sb.append(\"Byte   7       : (Reserved)          : \").append(LS);\n  final long n=memVal.n;\n  final int minK=memVal.minK;\n  final int numLevels=memVal.numLevels;\n  final int[] levelsArr=memVal.levelsArr;\n  final int retainedItems=levelsArr[numLevels] - levelsArr[0];\n  if (myStructure == COMPACT_FULL || myStructure == UPDATABLE) {\n    sb.append(\"Bytes  8-15    : N                   : \").append(n).append(LS);\n    sb.append(\"Bytes 16-17    : MinK                : \").append(minK).append(LS);\n    sb.append(\"Byte  18       : NumLevels           : \").append(numLevels).append(LS);\n  }\n else {\n    sb.append(\"Assumed        : N                   : \").append(n).append(LS);\n    sb.append(\"Assumed        : MinK                : \").append(minK).append(LS);\n    sb.append(\"Assumed        : NumLevels           : \").append(numLevels).append(LS);\n  }\n  sb.append(\"PreambleBytes                        : \").append(preInts * Integer.BYTES).append(LS);\n  sb.append(\"Sketch Bytes                         : \").append(sketchBytes).append(LS);\n  sb.append(\"Memory Capacity Bytes                : \").append(mem.getCapacity()).append(LS);\n  sb.append(\"### END KLL Sketch Memory Summary\").append(LS);\n  if (includeData) {\n    sb.append(LS);\n    sb.append(\"### START KLL DATA:\").append(LS);\n    int offsetBytes=0;\n    if (myStructure == UPDATABLE) {\n      sb.append(\"LEVELS ARR:\").append(LS);\n      offsetBytes=DATA_START_ADR;\n      for (int i=0; i < numLevels + 1; i++) {\n        sb.append(i + \", \" + mem.getInt(offsetBytes)).append(LS);\n        offsetBytes+=Integer.BYTES;\n      }\n      sb.append(\"MIN/MAX:\").append(LS);\n      if (sketchType == DOUBLES_SKETCH) {\n        sb.append(mem.getDouble(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n        sb.append(mem.getDouble(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        sb.append(mem.getFloat(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n        sb.append(mem.getFloat(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n      }\n else {\n        sb.append(\"<<<Updatable Structure is not suppported by ItemsSketch>>>\").append(LS);\n      }\n      sb.append(\"ALL DATA (including free space)\").append(LS);\n      final int itemsSpace=(sketchBytes - offsetBytes) / typeBytes;\n      if (sketchType == DOUBLES_SKETCH) {\n        for (int i=0; i < itemsSpace; i++) {\n          sb.append(i + \", \" + mem.getDouble(offsetBytes)).append(LS);\n          offsetBytes+=typeBytes;\n        }\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        for (int i=0; i < itemsSpace; i++) {\n          sb.append(mem.getFloat(offsetBytes)).append(LS);\n          offsetBytes+=typeBytes;\n        }\n      }\n else {\n        sb.append(\"<<<Updatable Structure is not suppported by ItemsSketch>>>\").append(LS);\n      }\n    }\n else     if (myStructure == COMPACT_FULL) {\n      sb.append(\"LEVELS ARR:\").append(LS);\n      offsetBytes=DATA_START_ADR;\n      int j;\n      for (j=0; j < numLevels; j++) {\n        sb.append(j + \", \" + mem.getInt(offsetBytes)).append(LS);\n        offsetBytes+=Integer.BYTES;\n      }\n      sb.append(j + \", \" + levelsArr[numLevels]);\n      sb.append(\" (Top level of Levels Array is absent in Memory)\").append(LS);\n      sb.append(\"MIN/MAX:\").append(LS);\n      if (sketchType == DOUBLES_SKETCH) {\n        sb.append(mem.getDouble(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n        sb.append(mem.getDouble(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        sb.append(mem.getFloat(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n        sb.append(mem.getFloat(offsetBytes)).append(LS);\n        offsetBytes+=typeBytes;\n      }\n else {\n        sb.append(serDe.deserializeFromMemory(mem,offsetBytes,1)[0]).append(LS);\n        offsetBytes+=serDe.sizeOf(mem,offsetBytes,1);\n        sb.append(serDe.deserializeFromMemory(mem,offsetBytes,1)[0]).append(LS);\n        offsetBytes+=serDe.sizeOf(mem,offsetBytes,1);\n      }\n      sb.append(\"RETAINED DATA\").append(LS);\n      final int itemSpace=(sketchBytes - offsetBytes) / typeBytes;\n      if (sketchType == DOUBLES_SKETCH) {\n        for (int i=0; i < itemSpace; i++) {\n          sb.append(i + \", \" + mem.getDouble(offsetBytes)).append(LS);\n          offsetBytes+=typeBytes;\n        }\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        for (int i=0; i < itemSpace; i++) {\n          sb.append(i + \", \" + mem.getFloat(offsetBytes)).append(LS);\n          offsetBytes+=typeBytes;\n        }\n      }\n else {\n        final T[] itemsArr=serDe.deserializeFromMemory(mem,offsetBytes,retainedItems);\n        for (int i=0; i < itemsArr.length; i++) {\n          sb.append(i + \", \" + serDe.toString(itemsArr[i])).append(LS);\n        }\n        offsetBytes+=serDe.sizeOf(mem,offsetBytes,retainedItems);\n      }\n    }\n else     if (myStructure == COMPACT_SINGLE) {\n      sb.append(\"SINGLE ITEM DATUM: \");\n      if (sketchType == DOUBLES_SKETCH) {\n        sb.append(mem.getDouble(DATA_START_ADR_SINGLE_ITEM)).append(LS);\n      }\n else       if (sketchType == FLOATS_SKETCH) {\n        sb.append(mem.getFloat(DATA_START_ADR_SINGLE_ITEM)).append(LS);\n      }\n else {\n        sb.append(serDe.deserializeFromMemory(mem,DATA_START_ADR_SINGLE_ITEM,1)[0]).append(LS);\n      }\n    }\n else {\n      sb.append(\"EMPTY, NO DATA\").append(LS);\n    }\n    sb.append(\"### END KLL DATA:\").append(LS);\n  }\n  return sb.toString();\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/kll/KllPreambleUtil.java",
        "Start": 9526,
        "Stop": 18095,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "toString"
    },
    {
        "Old_Method": "/** \n * Returns a human readable string summary of the preamble state of the given Memory. Note: other than making sure that the given Memory size is large enough for just the preamble, this does not do much value checking of the contents of the preamble as this is primarily a tool for debugging the preamble visually.\n * @param mem the given Memory.\n * @return the summary preamble string.\n */\nstatic String preambleToString(final Memory mem){\n  final int preLongs=getAndCheckPreLongs(mem);\n  final int rfId=extractLgResizeFactor(mem);\n  final ResizeFactor rf=ResizeFactor.getRF(rfId);\n  final int serVer=extractSerVer(mem);\n  final int familyId=extractFamilyID(mem);\n  final Family family=Family.idToFamily(familyId);\n  final int lgNomLongs=extractLgNomLongs(mem);\n  final int lgArrLongs=extractLgArrLongs(mem);\n  final int flags=extractFlags(mem);\n  final String flagsStr=(flags) + \", 0x\" + (Integer.toHexString(flags))+ \", \"+ zeroPad(Integer.toBinaryString(flags),8);\n  final String nativeOrder=ByteOrder.nativeOrder().toString();\n  final boolean bigEndian=(flags & BIG_ENDIAN_FLAG_MASK) > 0;\n  final boolean readOnly=(flags & READ_ONLY_FLAG_MASK) > 0;\n  final boolean empty=(flags & EMPTY_FLAG_MASK) > 0;\n  final boolean compact=(flags & COMPACT_FLAG_MASK) > 0;\n  final boolean ordered=(flags & ORDERED_FLAG_MASK) > 0;\n  final boolean singleItem=(flags & SINGLEITEM_FLAG_MASK) > 0;\n  final int seedHash=extractSeedHash(mem);\n  int curCount=singleItem ? 1 : 0;\n  float p=(float)1.0;\n  long thetaLong=Long.MAX_VALUE;\n  long thetaULong=thetaLong;\n  if (preLongs == 2) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n  }\n else   if (preLongs == 3) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n    thetaLong=extractThetaLong(mem);\n    thetaULong=thetaLong;\n  }\n else   if (preLongs == 4) {\n    curCount=extractCurCount(mem);\n    p=extractP(mem);\n    thetaLong=extractThetaLong(mem);\n    thetaULong=extractUnionThetaLong(mem);\n  }\n  final double thetaDbl=thetaLong / Util.LONG_MAX_VALUE_AS_DOUBLE;\n  final String thetaHex=zeroPad(Long.toHexString(thetaLong),16);\n  final double thetaUDbl=thetaULong / Util.LONG_MAX_VALUE_AS_DOUBLE;\n  final String thetaUHex=zeroPad(Long.toHexString(thetaULong),16);\n  final StringBuilder sb=new StringBuilder();\n  sb.append(LS);\n  sb.append(\"### SKETCH PREAMBLE SUMMARY:\").append(LS);\n  sb.append(\"Native Byte Order             : \").append(nativeOrder).append(LS);\n  sb.append(\"Byte  0: Preamble Longs       : \").append(preLongs).append(LS);\n  sb.append(\"Byte  0: ResizeFactor         : \").append(rfId + \", \" + rf.toString()).append(LS);\n  sb.append(\"Byte  1: Serialization Version: \").append(serVer).append(LS);\n  sb.append(\"Byte  2: Family               : \").append(familyId + \", \" + family.toString()).append(LS);\n  sb.append(\"Byte  3: LgNomLongs           : \").append(lgNomLongs).append(LS);\n  sb.append(\"Byte  4: LgArrLongs           : \").append(lgArrLongs).append(LS);\n  sb.append(\"Byte  5: Flags Field          : \").append(flagsStr).append(LS);\n  sb.append(\"  Bit Flag Name               : State:\").append(LS);\n  sb.append(\"    0 BIG_ENDIAN_STORAGE      : \").append(bigEndian).append(LS);\n  sb.append(\"    1 READ_ONLY               : \").append(readOnly).append(LS);\n  sb.append(\"    2 EMPTY                   : \").append(empty).append(LS);\n  sb.append(\"    3 COMPACT                 : \").append(compact).append(LS);\n  sb.append(\"    4 ORDERED                 : \").append(ordered).append(LS);\n  sb.append(\"    5 SINGLE_ITEM             : \").append(singleItem).append(LS);\n  sb.append(\"Bytes 6-7  : Seed Hash Hex    : \").append(Integer.toHexString(seedHash)).append(LS);\n  if (preLongs == 1) {\n    sb.append(\" --ABSENT FIELDS, ASSUMED:\").append(LS);\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else   if (preLongs == 2) {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\" --ABSENT, ASSUMED:\").append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else   if (preLongs == 3) {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n  }\n else {\n    sb.append(\"Bytes 8-11 : CurrentCount     : \").append(curCount).append(LS);\n    sb.append(\"Bytes 12-15: P                : \").append(p).append(LS);\n    sb.append(\"Bytes 16-23: Theta (double)   : \").append(thetaDbl).append(LS);\n    sb.append(\"             Theta (long)     : \").append(thetaLong).append(LS);\n    sb.append(\"             Theta (long,hex) : \").append(thetaHex).append(LS);\n    sb.append(\"Bytes 25-31: ThetaU (double)  : \").append(thetaUDbl).append(LS);\n    sb.append(\"             ThetaU (long)    : \").append(thetaULong).append(LS);\n    sb.append(\"             ThetaU (long,hex): \").append(thetaUHex).append(LS);\n  }\n  sb.append(\"Preamble Bytes                : \").append(preLongs * 8).append(LS);\n  sb.append(\"Data Bytes                    : \").append(curCount * 8).append(LS);\n  sb.append(\"TOTAL Sketch Bytes            : \").append((preLongs + curCount) * 8).append(LS);\n  sb.append(\"TOTAL Capacity Bytes          : \").append(mem.getCapacity()).append(LS);\n  sb.append(\"### END SKETCH PREAMBLE SUMMARY\").append(LS);\n  return sb.toString();\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/theta/PreambleUtil.java",
        "Start": 10484,
        "Stop": 17176,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "preambleToString"
    },
    {
        "Old_Method": "private void doTrialsAtLgKAtN(final int lgK,final long n,final int totalTrials){\n  final int k=1 << lgK;\n  final int minNK=(int)((k < n) ? k : n);\n  final double nOverK=(double)n / k;\n  final int lgTotTrials=Integer.numberOfTrailingZeros(totalTrials);\n  final int lgWaves=Math.max(lgTotTrials - 10,0);\n  final int trialsPerWave=1 << (lgTotTrials - lgWaves);\n  streamSketches=new CpcSketch[trialsPerWave];\n  compressedStates1=new CompressedState[trialsPerWave];\n  memoryArr=new WritableMemory[trialsPerWave];\n  compressedStates2=new CompressedState[trialsPerWave];\n  unCompressedSketches=new CpcSketch[trialsPerWave];\n  long totalC=0;\n  long totalW=0;\n  long sumCtor_nS=0;\n  long sumUpd_nS=0;\n  long sumCom_nS=0;\n  long sumSer_nS=0;\n  long sumDes_nS=0;\n  long sumUnc_nS=0;\n  long sumEqu_nS=0;\n  long nanoStart, nanoEnd;\n  final long start=System.currentTimeMillis();\n  for (int w=0; w < (1 << lgWaves); w++) {\n    nanoStart=System.nanoTime();\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=new CpcSketch(lgK);\n      streamSketches[trial]=sketch;\n    }\n    nanoEnd=System.nanoTime();\n    sumCtor_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=streamSketches[trial];\n      for (long i=0; i < n; i++) {\n        sketch.update(vIn+=INVERSE_GOLDEN_U64);\n      }\n    }\n    nanoEnd=System.nanoTime();\n    sumUpd_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CpcSketch sketch=streamSketches[trial];\n      final CompressedState state=CompressedState.compress(sketch);\n      compressedStates1[trial]=state;\n      totalC+=sketch.numCoupons;\n      totalW+=state.csvLengthInts + state.cwLengthInts;\n    }\n    nanoEnd=System.nanoTime();\n    sumCom_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CompressedState state=compressedStates1[trial];\n      final long cap=state.getRequiredSerializedBytes();\n      final WritableMemory wmem=WritableMemory.allocate((int)cap);\n      state.exportToMemory(wmem);\n      memoryArr[trial]=wmem;\n    }\n    nanoEnd=System.nanoTime();\n    sumSer_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final Memory mem=memoryArr[trial];\n      final CompressedState state=importFromMemory(mem);\n      compressedStates2[trial]=state;\n    }\n    nanoEnd=System.nanoTime();\n    sumDes_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      final CompressedState state=compressedStates2[trial];\n      CpcSketch uncSk=null;\n      uncSk=CpcSketch.uncompress(state,ThetaUtil.DEFAULT_UPDATE_SEED);\n      unCompressedSketches[trial]=uncSk;\n    }\n    nanoEnd=System.nanoTime();\n    sumUnc_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n    for (int trial=0; trial < trialsPerWave; trial++) {\n      rtAssert(TestUtil.specialEquals(streamSketches[trial],unCompressedSketches[trial],false,false));\n    }\n    nanoEnd=System.nanoTime();\n    sumEqu_nS+=nanoEnd - nanoStart;\n    nanoStart=nanoEnd;\n  }\n  final double total_S=(System.currentTimeMillis() - start) / 1E3;\n  final double avgC=(1.0 * totalC) / totalTrials;\n  final double avgCoK=avgC / k;\n  final double avgWords=(1.0 * totalW) / totalTrials;\n  final double avgBytes=(4.0 * totalW) / totalTrials;\n  final double avgCtor_nS=Math.round((double)sumCtor_nS / totalTrials);\n  final double avgUpd_nS=Math.round((double)sumUpd_nS / totalTrials);\n  final double avgUpd_nSperN=avgUpd_nS / n;\n  final double avgCom_nS=Math.round((double)sumCom_nS / totalTrials);\n  final double avgCom_nSper2C=avgCom_nS / (2.0 * avgC);\n  final double avgCom_nSperK=avgCom_nS / k;\n  final double avgSer_nS=Math.round((double)sumSer_nS / totalTrials);\n  final double avgSer_nSperW=avgSer_nS / avgWords;\n  final double avgDes_nS=Math.round((double)sumDes_nS / totalTrials);\n  final double avgDes_nSperW=avgDes_nS / avgWords;\n  final double avgUnc_nS=Math.round((double)sumUnc_nS / totalTrials);\n  final double avgUnc_nSper2C=avgUnc_nS / (2.0 * avgC);\n  final double avgUnc_nSperK=avgUnc_nS / k;\n  final double avgEqu_nS=Math.round((double)sumEqu_nS / totalTrials);\n  final double avgEqu_nSperMinNK=avgEqu_nS / minNK;\n  final int len=unCompressedSketches.length;\n  final Flavor finFlavor=unCompressedSketches[len - 1].getFlavor();\n  final String offStr=Integer.toString(unCompressedSketches[len - 1].windowOffset);\n  final String flavorOff=finFlavor.toString() + String.format(\"%2s\",offStr);\n  printf(dfmt,lgK,totalTrials,n,minNK,avgCoK,flavorOff,nOverK,avgBytes,avgCtor_nS,avgUpd_nS,avgCom_nS,avgSer_nS,avgDes_nS,avgUnc_nS,avgEqu_nS,avgUpd_nSperN,avgCom_nSper2C,avgCom_nSperK,avgSer_nSperW,avgDes_nSperW,avgUnc_nSper2C,avgUnc_nSperK,avgEqu_nSperMinNK,total_S);\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/cpc/CompressionCharacterization.java",
        "Start": 3877,
        "Stop": 9810,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "doTrialsAtLgKAtN"
    },
    {
        "Old_Method": "@Test public void checkInsertsAndExtracts(){\n  final int bytes=32;\n  try (WritableHandle offHeapMemHandler=WritableMemory.allocateDirect(bytes)){\n    final WritableMemory offHeapMem=offHeapMemHandler.getWritable();\n    final WritableMemory onHeapMem=WritableMemory.writableWrap(new byte[bytes]);\n    onHeapMem.clear();\n    offHeapMem.clear();\n    int v=0XFF;\n    int onH, offH;\n    insertPreLongs(onHeapMem,v);\n    onH=extractPreLongs(onHeapMem);\n    assertEquals(onH,v);\n    insertPreLongs(offHeapMem,v);\n    offH=extractPreLongs(offHeapMem);\n    assertEquals(offH,v);\n    onHeapMem.clear();\n    offHeapMem.clear();\n    insertSerVer(onHeapMem,v);\n    onH=extractSerVer(onHeapMem);\n    assertEquals(onH,v);\n    insertSerVer(offHeapMem,v);\n    offH=extractSerVer(offHeapMem);\n    assertEquals(offH,v);\n    onHeapMem.clear();\n    offHeapMem.clear();\n    insertFamilyID(onHeapMem,v);\n    onH=extractFamilyID(onHeapMem);\n    assertEquals(onH,v);\n    insertFamilyID(offHeapMem,v);\n    offH=extractFamilyID(offHeapMem);\n    assertEquals(offH,v);\n    onHeapMem.clear();\n    offHeapMem.clear();\n    insertFlags(onHeapMem,v);\n    onH=extractFlags(onHeapMem);\n    assertEquals(onH,v);\n    insertFlags(offHeapMem,v);\n    offH=extractFlags(offHeapMem);\n    assertEquals(offH,v);\n    onHeapMem.clear();\n    offHeapMem.clear();\n    v=0XFFFF;\n    insertK(onHeapMem,v);\n    onH=extractK(onHeapMem);\n    assertEquals(onH,v);\n    insertK(offHeapMem,v);\n    offH=extractK(offHeapMem);\n    assertEquals(offH,v);\n    onHeapMem.clear();\n    offHeapMem.clear();\n    long onHL, offHL, vL=1L << 30;\n    insertN(onHeapMem,vL);\n    onHL=extractN(onHeapMem);\n    assertEquals(onHL,vL);\n    insertN(offHeapMem,vL);\n    offHL=extractN(offHeapMem);\n    assertEquals(offHL,vL);\n    onHeapMem.clear();\n    offHeapMem.clear();\n    double onHD, offHD, vD=1L << 40;\n    insertMinDouble(onHeapMem,vD);\n    onHD=extractMinDouble(onHeapMem);\n    assertEquals(onHD,vD);\n    insertMinDouble(offHeapMem,vD);\n    offHD=extractMinDouble(offHeapMem);\n    assertEquals(offHD,vD);\n    onHeapMem.clear();\n    offHeapMem.clear();\n    insertMaxDouble(onHeapMem,vD);\n    onHD=extractMaxDouble(onHeapMem);\n    assertEquals(onHD,vD);\n    insertMaxDouble(offHeapMem,vD);\n    offHD=extractMaxDouble(offHeapMem);\n    assertEquals(offHD,vD);\n    onHeapMem.clear();\n    offHeapMem.clear();\n  }\n catch (  final Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/quantiles/PreambleUtilTest.java",
        "Start": 2333,
        "Stop": 5225,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkInsertsAndExtracts"
    },
    {
        "Old_Method": "@Test public void checkWrapCompactSketchGivenDefaultSeed(){\n  final int k=64;\n  final long seed=ThetaUtil.DEFAULT_UPDATE_SEED;\n  final short seedHash=Util.computeSeedHash(seed);\n  UpdateSketch sv3usk=UpdateSketch.builder().setNominalEntries(k).setSeed(seed).build();\n  for (int i=0; i < k; i++) {\n    sv3usk.update(i);\n  }\n  CompactSketch sv3cskResult;\n  WritableHandle wh;\n  CompactSketch sv3csk=sv3usk.compact();\n  wh=putOffHeap(Memory.wrap(sv3csk.toByteArray()));\n  sv3cskResult=Sketches.wrapCompactSketch(wh.getWritable(),seed);\n  assertEquals(sv3cskResult.getEstimate(),sv3usk.getEstimate());\n  assertEquals(sv3cskResult.getSeedHash(),seedHash);\n  assertTrue(sv3cskResult.isDirect());\n  try {\n    wh.close();\n  }\n catch (  Exception e) {\n  }\n  wh=putOffHeap(BackwardConversions.convertSerVer3toSerVer2(sv3csk,seed));\n  sv3cskResult=Sketches.wrapCompactSketch(wh.getWritable(),seed);\n  assertEquals(sv3cskResult.getEstimate(),sv3usk.getEstimate());\n  assertEquals(sv3cskResult.getSeedHash(),seedHash);\n  assertFalse(sv3cskResult.isDirect());\n  try {\n    wh.close();\n  }\n catch (  Exception e) {\n  }\n  wh=putOffHeap(BackwardConversions.convertSerVer3toSerVer1(sv3csk));\n  sv3cskResult=Sketches.wrapCompactSketch(wh.getWritable(),seed);\n  assertEquals(sv3cskResult.getEstimate(),sv3usk.getEstimate());\n  assertEquals(sv3cskResult.getSeedHash(),seedHash);\n  assertFalse(sv3cskResult.isDirect());\n  try {\n    wh.close();\n  }\n catch (  Exception e) {\n  }\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/theta/HeapifyWrapSerVer1and2Test.java",
        "Start": 14530,
        "Stop": 16090,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkWrapCompactSketchGivenDefaultSeed"
    },
    {
        "Old_Method": "@Test public void checkEndToEnd(){\n  int k=256;\n  UpdateDoublesSketch qs=DoublesSketch.builder().setK(k).build();\n  UpdateDoublesSketch qs2=DoublesSketch.builder().setK(k).build();\n  int n=1000000;\n  for (int item=n; item >= 1; item--) {\n    if ((item % 4) == 0) {\n      qs.update(item);\n    }\n else {\n      qs2.update(item);\n    }\n  }\n  assertEquals(qs.getN() + qs2.getN(),n);\n  DoublesUnion union=DoublesUnion.heapify(qs);\n  union.union(qs2);\n  DoublesSketch result=union.getResult();\n  int numPhiValues=99;\n  double[] phiArr=new double[numPhiValues];\n  for (int q=1; q <= 99; q++) {\n    phiArr[q - 1]=q / 100.0;\n  }\n  double[] splitPoints=result.getQuantiles(phiArr);\n  for (int q=1; q <= 99; q++) {\n    double nominal=(1e6 * q) / 100.0;\n    double reported=splitPoints[q - 1];\n    assertTrue(reported >= (nominal - 10000.0));\n    assertTrue(reported <= (nominal + 10000.0));\n  }\n  double[] pmfResult=result.getPMF(splitPoints);\n  double subtotal=0.0;\n  for (int q=1; q <= 100; q++) {\n    double phi=q / 100.0;\n    subtotal+=pmfResult[q - 1];\n    assertTrue(subtotal >= (phi - 0.01));\n    assertTrue(subtotal <= (phi + 0.01));\n  }\n  double[] cdfResult=result.getCDF(splitPoints);\n  for (int q=1; q <= 100; q++) {\n    double phi=q / 100.0;\n    subtotal=cdfResult[q - 1];\n    assertTrue(subtotal >= (phi - 0.01));\n    assertTrue(subtotal <= (phi + 0.01));\n  }\n  assertEquals(result.getRank(500000),0.5,0.01);\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/quantiles/HeapUpdateDoublesSketchTest.java",
        "Start": 2693,
        "Stop": 4396,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkEndToEnd"
    },
    {
        "Old_Method": "@Test(expectedExceptions=SketchesArgumentException.class) public void checkSizedTooSmall(){\n  final int lgK=5;\n  final int k=1 << lgK;\n  final int u=4 * k;\n  final int memBytes=getMaxIntersectionBytes(k / 2);\n  final byte[] memArr=new byte[memBytes];\n  final WritableMemory iMem=WritableMemory.writableWrap(memArr);\n  final UpdateSketch usk1=UpdateSketch.builder().setNominalEntries(k).build();\n  for (int i=0; i < u; i++) {\n    usk1.update(i);\n  }\n  final CompactSketch csk1=usk1.compact(true,null);\n  final Intersection inter=SetOperation.builder().buildIntersection(iMem);\n  inter.intersect(csk1);\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/theta/DirectIntersectionTest.java",
        "Start": 17194,
        "Stop": 17845,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkSizedTooSmall"
    },
    {
        "Old_Method": "@Override HllSketchImpl couponUpdate(final int coupon){\n  if (wmem == null) {\n    noWriteAccess();\n  }\n  final int index=find(mem,getLgCouponArrInts(),coupon);\n  if (index >= 0) {\n    return this;\n  }\n  insertInt(wmem,HASH_SET_INT_ARR_START + (~index << 2),coupon);\n  insertHashSetCount(wmem,getCouponCount() + 1);\n  final boolean promote=checkGrowOrPromote();\n  if (!promote) {\n    return this;\n  }\n  return promoteListOrSetToHll(this);\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/hll/DirectCouponHashSet.java",
        "Start": 2926,
        "Stop": 3436,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "couponUpdate"
    },
    {
        "Old_Method": "/** \n * Returns a sketch instance of this class from the given srcMem, which must be a Memory representation of this sketch class.\n * @param < T >    The type of item this sketch contains\n * @param srcMem a Memory representation of a sketch of this class.<a href=\" {@docRoot}/resources/dictionary.html#mem\">See Memory<\/a>\n * @param serDe  An instance of ArrayOfItemsSerDe\n * @return a sketch instance of this class\n */\npublic static <T>VarOptItemsSketch<T> heapify(final Memory srcMem,final ArrayOfItemsSerDe<T> serDe){\n  final int numPreLongs=getAndCheckPreLongs(srcMem);\n  final ResizeFactor rf=ResizeFactor.getRF(extractResizeFactor(srcMem));\n  final int serVer=extractSerVer(srcMem);\n  final int familyId=extractFamilyID(srcMem);\n  final int flags=extractFlags(srcMem);\n  final boolean isEmpty=(flags & EMPTY_FLAG_MASK) != 0;\n  final boolean isGadget=(flags & GADGET_FLAG_MASK) != 0;\n  if (isEmpty) {\n    if (numPreLongs != VO_PRELONGS_EMPTY) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_EMPTY + \" for an empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n else {\n    if ((numPreLongs != VO_PRELONGS_WARMUP) && (numPreLongs != VO_PRELONGS_FULL)) {\n      throw new SketchesArgumentException(\"Possible corruption: Must be \" + VO_PRELONGS_WARMUP + \" or \"+ VO_PRELONGS_FULL+ \" for a non-empty sketch. Found: \"+ numPreLongs);\n    }\n  }\n  if (serVer != SER_VER) {\n    throw new SketchesArgumentException(\"Possible Corruption: Ser Ver must be \" + SER_VER + \": \"+ serVer);\n  }\n  final int reqFamilyId=Family.VAROPT.getID();\n  if (familyId != reqFamilyId) {\n    throw new SketchesArgumentException(\"Possible Corruption: FamilyID must be \" + reqFamilyId + \": \"+ familyId);\n  }\n  final int k=extractK(srcMem);\n  if (k < 1) {\n    throw new SketchesArgumentException(\"Possible Corruption: k must be at least 1: \" + k);\n  }\n  if (isEmpty) {\n    assert numPreLongs == Family.VAROPT.getMinPreLongs();\n    return new VarOptItemsSketch<>(k,rf);\n  }\n  final long n=extractN(srcMem);\n  if (n < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: n cannot be negative: \" + n);\n  }\n  final int hCount=extractHRegionItemCount(srcMem);\n  final int rCount=extractRRegionItemCount(srcMem);\n  if (hCount < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: H region count cannot be \" + \"negative: \" + hCount);\n  }\n  if (rCount < 0) {\n    throw new SketchesArgumentException(\"Possible Corruption: R region count cannot be \" + \"negative: \" + rCount);\n  }\n  double totalRWeight=0.0;\n  if (numPreLongs == Family.VAROPT.getMaxPreLongs()) {\n    if (rCount > 0) {\n      totalRWeight=extractTotalRWeight(srcMem);\n    }\n else {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + Family.VAROPT.getMaxPreLongs() + \" preLongs but no items in R region\");\n    }\n  }\n  final int preLongBytes=numPreLongs << 3;\n  final int totalItems=hCount + rCount;\n  int allocatedItems=k + 1;\n  if (rCount == 0) {\n    final int ceilingLgK=Util.exactLog2OfInt(Util.ceilingPowerOf2(k),\"heapify\");\n    final int minLgSize=Util.exactLog2OfInt(Util.ceilingPowerOf2(hCount),\"heapify\");\n    final int initialLgSize=SamplingUtil.startingSubMultiple(ceilingLgK,rf.lg(),Math.max(minLgSize,MIN_LG_ARR_ITEMS));\n    allocatedItems=SamplingUtil.getAdjustedSize(k,1 << initialLgSize);\n    if (allocatedItems == k) {\n      ++allocatedItems;\n    }\n  }\n  final long weightOffsetBytes=TOTAL_WEIGHT_R_DOUBLE + (rCount > 0 ? Double.BYTES : 0);\n  final ArrayList<Double> weightList=new ArrayList<>(allocatedItems);\n  final double[] wts=new double[allocatedItems];\n  srcMem.getDoubleArray(weightOffsetBytes,wts,0,hCount);\n  for (int i=0; i < hCount; ++i) {\n    if (wts[i] <= 0.0) {\n      throw new SketchesArgumentException(\"Possible Corruption: \" + \"Non-positive weight in heapify(): \" + wts[i]);\n    }\n    weightList.add(wts[i]);\n  }\n  long markBytes=0;\n  int markCount=0;\n  ArrayList<Boolean> markList=null;\n  if (isGadget) {\n    final long markOffsetBytes=preLongBytes + ((long)hCount * Double.BYTES);\n    markBytes=ArrayOfBooleansSerDe.computeBytesNeeded(hCount);\n    markList=new ArrayList<>(allocatedItems);\n    final ArrayOfBooleansSerDe booleansSerDe=new ArrayOfBooleansSerDe();\n    final Boolean[] markArray=booleansSerDe.deserializeFromMemory(srcMem.region(markOffsetBytes,(hCount >>> 3) + 1),0,hCount);\n    for (    Boolean mark : markArray) {\n      if (mark) {\n        ++markCount;\n      }\n    }\n    markList.addAll(Arrays.asList(markArray));\n  }\n  final long offsetBytes=preLongBytes + ((long)hCount * Double.BYTES) + markBytes;\n  final T[] data=serDe.deserializeFromMemory(srcMem.region(offsetBytes,srcMem.getCapacity() - offsetBytes),0,totalItems);\n  final List<T> wrappedData=Arrays.asList(data);\n  final ArrayList<T> dataList=new ArrayList<>(allocatedItems);\n  dataList.addAll(wrappedData.subList(0,hCount));\n  if (rCount > 0) {\n    weightList.add(-1.0);\n    if (isGadget) {\n      markList.add(false);\n    }\n    for (int i=0; i < rCount; ++i) {\n      weightList.add(-1.0);\n      if (isGadget) {\n        markList.add(false);\n      }\n    }\n    dataList.add(null);\n    dataList.addAll(wrappedData.subList(hCount,totalItems));\n  }\n  final VarOptItemsSketch<T> sketch=new VarOptItemsSketch<>(dataList,weightList,k,n,allocatedItems,rf,hCount,rCount,totalRWeight);\n  if (isGadget) {\n    sketch.marks_=markList;\n    sketch.numMarksInH_=markCount;\n  }\n  return sketch;\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/sampling/VarOptItemsSketch.java",
        "Start": 11791,
        "Stop": 18243,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "heapify"
    },
    {
        "Old_Method": "@Test public void checkCombinations(){\n  final int k=512;\n  final UpdateSketch aNull=null;\n  final UpdateSketch bNull=null;\n  final UpdateSketch aEmpty=UpdateSketch.builder().setNominalEntries(k).build();\n  final UpdateSketch bEmpty=UpdateSketch.builder().setNominalEntries(k).build();\n  final UpdateSketch aHT=UpdateSketch.builder().setNominalEntries(k).build();\n  for (int i=0; i < k; i++) {\n    aHT.update(i);\n  }\n  final CompactSketch aC=aHT.compact(false,null);\n  final CompactSketch aO=aHT.compact(true,null);\n  final UpdateSketch bHT=UpdateSketch.builder().setNominalEntries(k).build();\n  for (int i=k / 2; i < k + k / 2; i++) {\n    bHT.update(i);\n  }\n  final CompactSketch bC=bHT.compact(false,null);\n  final CompactSketch bO=bHT.compact(true,null);\n  CompactSketch result;\n  AnotB aNb;\n  final boolean ordered=true;\n  aNb=SetOperation.builder().buildANotB();\n  try {\n    aNb.setA(aNull);\n    fail();\n  }\n catch (  final SketchesArgumentException e) {\n  }\n  aNb.notB(bNull);\n  try {\n    aNb.aNotB(aNull,bNull);\n    fail();\n  }\n catch (  final SketchesArgumentException e) {\n  }\n  try {\n    aNb.aNotB(aNull,bEmpty);\n    fail();\n  }\n catch (  final SketchesArgumentException e) {\n  }\n  try {\n    aNb.aNotB(aEmpty,bNull);\n    fail();\n  }\n catch (  final SketchesArgumentException e) {\n  }\n  result=aNb.aNotB(aEmpty,bEmpty,!ordered,null);\n  assertEquals(result.getEstimate(),0.0);\n  assertTrue(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aEmpty,bC,!ordered,null);\n  assertEquals(result.getEstimate(),0.0);\n  assertTrue(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aEmpty,bO,!ordered,null);\n  assertEquals(result.getEstimate(),0.0);\n  assertTrue(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aEmpty,bHT,!ordered,null);\n  assertEquals(result.getEstimate(),0.0);\n  assertTrue(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aC,bEmpty,!ordered,null);\n  assertEquals(result.getEstimate(),k);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aC,bC,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aC,bO,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aC,bHT,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aO,bEmpty,!ordered,null);\n  assertEquals(result.getEstimate(),k);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aO,bC,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aO,bO,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aO,bHT,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aHT,bEmpty,!ordered,null);\n  assertEquals(result.getEstimate(),k);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aHT,bC,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aHT,bO,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n  result=aNb.aNotB(aHT,bHT,!ordered,null);\n  assertEquals(result.getEstimate(),k / 2.0);\n  assertFalse(result.isEmpty());\n  assertEquals(result.getThetaLong(),Long.MAX_VALUE);\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/theta/AnotBimplTest.java",
        "Start": 2863,
        "Stop": 7247,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkCombinations"
    },
    {
        "Old_Method": "@Test public void checkSeedHash(){\n  int k=64;\n  UpdateSketch tmp1=Sketches.updateSketchBuilder().setNominalEntries(k).setSeed(123).build();\n  tmp1.update(1);\n  tmp1.update(3);\n  CompactSketch skSmallSeed2A=tmp1.compact(true,null);\n  UpdateSketch tmp2=Sketches.updateSketchBuilder().setNominalEntries(k).setSeed(123).build();\n  tmp2.update(1);\n  tmp2.update(2);\n  CompactSketch skSmallSeed2B=tmp2.compact(true,null);\n  CompactSketch skExact=generate(EXACT,k);\n  CompactSketch skHeap=generate(EST_HEAP,2 * k);\n  Intersection inter=SetOperation.builder().buildIntersection();\n  AnotB aNotB=SetOperation.builder().buildANotB();\n  Union union=SetOperation.builder().setNominalEntries(k).buildUnion();\n  try {\n    inter.intersect(skExact,skSmallSeed2A);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    inter.intersect(skExact,skSmallSeed2B);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    inter.intersect(skSmallSeed2B,skExact);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    inter.intersect(skHeap,skSmallSeed2B);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    aNotB.aNotB(skExact,skSmallSeed2A);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    aNotB.aNotB(skExact,skSmallSeed2B);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    aNotB.aNotB(skSmallSeed2B,skExact);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    aNotB.aNotB(skHeap,skSmallSeed2B);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    union.union(skExact,skSmallSeed2A);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    union.union(skExact,skSmallSeed2B);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    union.union(skSmallSeed2B,skExact);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n  try {\n    union.union(skHeap,skSmallSeed2B);\n    Assert.fail();\n  }\n catch (  Exception e) {\n  }\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/theta/SetOpsCornerCasesTest.java",
        "Start": 10314,
        "Stop": 12460,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkSeedHash"
    },
    {
        "Old_Method": "/** \n * Compression algorithm used to merge higher levels. <p>Here is what we do for each level:<\/p> <ul><li>If it does not need to be compacted, then simply copy it over.<\/li> <li>Otherwise, it does need to be compacted, so... <ul><li>Copy zero or one guy over.<\/li> <li>If the level above is empty, halve up.<\/li> <li>Else the level above is nonempty, so halve down, then merge up.<\/li> <\/ul><\/li> <li>Adjust the boundaries of the level above.<\/li> <\/ul> <p>It can be proved that generalCompress returns a sketch that satisfies the space constraints no matter how much data is passed in. We are pretty sure that it works correctly when inBuf and outBuf are the same. All levels except for level zero must be sorted before calling this, and will still be sorted afterwards. Level zero is not required to be sorted before, and may not be sorted afterwards.<\/p> <p>This trashes inBuf and inLevels and modifies outBuf and outLevels.<\/p>\n * @param k The sketch parameter k\n * @param m The minimum level size\n * @param numLevelsIn provisional number of number of levels = max(this.numLevels, other.numLevels)\n * @param inBuf work buffer of size = this.getNumRetained() + other.getNumRetainedAboveLevelZero().This contains the items array of the other sketch\n * @param inLevels work levels array size = ubOnNumLevels(this.n + other.n) + 2\n * @param outBuf the same array as inBuf\n * @param outLevels the same size as inLevels\n * @param isLevelZeroSorted true if this.level 0 is sorted\n * @param random instance of java.util.Random\n * @param comp Comparator of T\n * @return int array of: {numLevels, targetItemCount, currentItemCount)\n */\nprivate static <T>int[] generalItemsCompress(final int k,final int m,final int numLevelsIn,final Object[] inBuf,final int[] inLevels,final Object[] outBuf,final int[] outLevels,final boolean isLevelZeroSorted,final Random random,final Comparator<? super T> comp){\n  assert numLevelsIn > 0;\n  int numLevels=numLevelsIn;\n  int currentItemCount=inLevels[numLevels] - inLevels[0];\n  int targetItemCount=KllHelper.computeTotalItemCapacity(k,m,numLevels);\n  boolean doneYet=false;\n  outLevels[0]=0;\n  int curLevel=-1;\n  while (!doneYet) {\n    curLevel++;\n    if (curLevel == (numLevels - 1)) {\n      inLevels[curLevel + 2]=inLevels[curLevel + 1];\n    }\n    final int rawBeg=inLevels[curLevel];\n    final int rawLim=inLevels[curLevel + 1];\n    final int rawPop=rawLim - rawBeg;\n    if ((currentItemCount < targetItemCount) || (rawPop < KllHelper.levelCapacity(k,numLevels,curLevel,m))) {\n      assert (rawBeg >= outLevels[curLevel]);\n      System.arraycopy(inBuf,rawBeg,outBuf,outLevels[curLevel],rawPop);\n      outLevels[curLevel + 1]=outLevels[curLevel] + rawPop;\n    }\n else {\n      final int popAbove=inLevels[curLevel + 2] - rawLim;\n      final boolean oddPop=isOdd(rawPop);\n      final int adjBeg=oddPop ? 1 + rawBeg : rawBeg;\n      final int adjPop=oddPop ? rawPop - 1 : rawPop;\n      final int halfAdjPop=adjPop / 2;\n      if (oddPop) {\n        outBuf[outLevels[curLevel]]=inBuf[rawBeg];\n        outLevels[curLevel + 1]=outLevels[curLevel] + 1;\n      }\n else {\n        outLevels[curLevel + 1]=outLevels[curLevel];\n      }\n      if ((curLevel == 0) && !isLevelZeroSorted) {\n        Arrays.sort(inBuf,adjBeg,adjBeg + adjPop);\n      }\n      if (popAbove == 0) {\n        randomlyHalveUpItems(inBuf,adjBeg,adjPop,random);\n      }\n else {\n        randomlyHalveDownItems(inBuf,adjBeg,adjPop,random);\n        mergeSortedItemsArrays(inBuf,adjBeg,halfAdjPop,inBuf,rawLim,popAbove,inBuf,adjBeg + halfAdjPop,comp);\n      }\n      currentItemCount-=halfAdjPop;\n      inLevels[curLevel + 1]=inLevels[curLevel + 1] - halfAdjPop;\n      if (curLevel == (numLevels - 1)) {\n        numLevels++;\n        targetItemCount+=KllHelper.levelCapacity(k,numLevels,0,m);\n      }\n    }\n    if (curLevel == (numLevels - 1)) {\n      doneYet=true;\n    }\n  }\n  assert (outLevels[numLevels] - outLevels[0]) == currentItemCount;\n  return new int[]{numLevels,targetItemCount,currentItemCount};\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/kll/KllItemsHelper.java",
        "Start": 13655,
        "Stop": 19262,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "generalItemsCompress"
    },
    {
        "Old_Method": "@Test public void empty(){\n  final ItemsSketch<String> sketch=ItemsSketch.getInstance(String.class,128,Comparator.naturalOrder());\n  assertNotNull(sketch);\n  sketch.update(null);\n  assertTrue(sketch.isEmpty());\n  assertEquals(sketch.getN(),0);\n  assertEquals(sketch.getNumRetained(),0);\n  try {\n    sketch.getMinItem();\n    fail();\n  }\n catch (  IllegalArgumentException e) {\n  }\n  try {\n    sketch.getMaxItem();\n    fail();\n  }\n catch (  IllegalArgumentException e) {\n  }\n  try {\n    sketch.getQuantile(0.5);\n    fail();\n  }\n catch (  IllegalArgumentException e) {\n  }\n  try {\n    sketch.getQuantiles(new double[]{0.0,1.0});\n    fail();\n  }\n catch (  IllegalArgumentException e) {\n  }\n  final byte[] byteArr=sketch.toByteArray(new ArrayOfStringsSerDe());\n  assertEquals(byteArr.length,8);\n  try {\n    sketch.getPMF(new String[0]);\n    fail();\n  }\n catch (  IllegalArgumentException e) {\n  }\n  try {\n    sketch.getCDF(new String[0]);\n    fail();\n  }\n catch (  IllegalArgumentException e) {\n  }\n  try {\n    sketch.getRank(\"a\");\n    fail();\n  }\n catch (  IllegalArgumentException e) {\n  }\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/quantiles/ItemsSketchTest.java",
        "Start": 2142,
        "Stop": 3166,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "empty"
    },
    {
        "Old_Method": "public void checkHeapifyWrap(int k,int u,boolean ordered){\n  UpdateSketch usk=UpdateSketch.builder().setNominalEntries(k).build();\n  for (int i=0; i < u; i++) {\n    usk.update(i);\n  }\n  CompactSketch refSk=usk.compact(ordered,null);\n  byte[] barr=refSk.toByteArray();\n  Memory srcMem=Memory.wrap(barr);\n  CompactSketch testSk=(CompactSketch)Sketch.heapify(srcMem);\n  checkByRange(refSk,testSk,u,ordered);\n  byte[] byteArray=refSk.toByteArray();\n  Memory heapROMem=Memory.wrap(byteArray);\n  testSk=(CompactSketch)Sketch.heapify(heapROMem);\n  checkByRange(refSk,testSk,u,ordered);\n  int bytes=usk.getCompactBytes();\n  try (WritableHandle wdh=WritableMemory.allocateDirect(bytes)){\n    WritableMemory directMem=wdh.getWritable();\n    refSk=usk.compact(ordered,directMem);\n    testSk=(CompactSketch)Sketch.wrap(directMem);\n    checkByRange(refSk,testSk,u,ordered);\n    testSk=(CompactSketch)Sketch.wrap(directMem);\n    checkByRange(refSk,testSk,u,ordered);\n  }\n catch (  final Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/theta/CompactSketchTest.java",
        "Start": 1975,
        "Stop": 3351,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkHeapifyWrap"
    },
    {
        "Old_Method": "@Test public void checkUnion4DirectCompact(){\n  final int k1=8;\n  final int n1=2 * k1;\n  final int k2=4;\n  final int n2=5 * k2;\n  final int bytes=DoublesSketch.getUpdatableStorageBytes(256,50);\n  final WritableMemory skMem=WritableMemory.writableWrap(new byte[bytes]);\n  final UpdateDoublesSketch sketchIn0=DoublesSketch.builder().setK(k1).build(skMem);\n  for (int i=0; i < n1; i++) {\n    sketchIn0.update(i + 1);\n  }\n  final CompactDoublesSketch sketchIn1=sketchIn0.compact();\n  final WritableMemory uMem=WritableMemory.writableWrap(new byte[bytes]);\n  final DoublesUnion union=DoublesUnion.builder().setMaxK(256).build(uMem);\n  union.union(sketchIn1);\n  assertEquals(union.getResult().getN(),n1);\n  assertEquals(union.getMaxK(),256);\n  assertEquals(union.getEffectiveK(),k1);\n  DoublesSketch result=union.getResult();\n  assertEquals(result.getN(),16);\n  assertEquals(result.getMaxItem(),n1,0.0);\n  assertEquals(result.getMinItem(),1.0,0.0);\n  assertEquals(result.getK(),k1);\n  final CompactDoublesSketch sketchIn2=buildAndLoadDQS(k2,n2,17).compact();\n  union.reset();\n  union.union(sketchIn2);\n  result=union.getResult();\n  assertEquals(result.getMaxItem(),n2 + 17,0.0);\n  assertEquals(result.getMinItem(),1.0 + 17,0.0);\n  println(\"\\nFinal\" + union.getResult().toString(true,true));\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/quantiles/DoublesUnionImplTest.java",
        "Start": 9412,
        "Stop": 10835,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkUnion4DirectCompact"
    },
    {
        "Old_Method": "static String toString(final Memory mem,final boolean detail){\n  final long capBytes=mem.getCapacity();\n  final int preInts=mem.getByte(getLoFieldOffset(LoField.PRE_INTS)) & 0xFF;\n  final int serVer=mem.getByte(getLoFieldOffset(LoField.SER_VERSION)) & 0xFF;\n  final Family family=Family.idToFamily(mem.getByte(getLoFieldOffset(LoField.FAMILY)) & 0xFF);\n  final int lgK=mem.getByte(getLoFieldOffset(LoField.LG_K)) & 0xFF;\n  final int fiCol=mem.getByte(getLoFieldOffset(LoField.FI_COL)) & 0xFF;\n  final int flags=mem.getByte(getLoFieldOffset(LoField.FLAGS)) & 0XFF;\n  final int seedHash=mem.getShort(getLoFieldOffset(LoField.SEED_HASH)) & 0XFFFF;\n  final String seedHashStr=Integer.toHexString(seedHash);\n  final String flagsStr=zeroPad(Integer.toBinaryString(flags),8) + \", \" + (flags);\n  final boolean bigEndian=(flags & BIG_ENDIAN_FLAG_MASK) > 0;\n  final boolean compressed=(flags & COMPRESSED_FLAG_MASK) > 0;\n  final boolean hasHip=(flags & HIP_FLAG_MASK) > 0;\n  final boolean hasSV=(flags & SUP_VAL_FLAG_MASK) > 0;\n  final boolean hasWindow=(flags & WINDOW_FLAG_MASK) > 0;\n  final int formatOrdinal=(flags >>> 2) & 0x7;\n  final Format format=Format.ordinalToFormat(formatOrdinal);\n  final String nativeOrderStr=ByteOrder.nativeOrder().toString();\n  long numCoupons=0;\n  long numSv=0;\n  long winOffset=0;\n  long svLengthInts=0;\n  long wLengthInts=0;\n  double kxp=0;\n  double hipAccum=0;\n  long svStreamStart=0;\n  long wStreamStart=0;\n  long reqBytes=0;\n  final StringBuilder sb=new StringBuilder();\n  sb.append(LS);\n  sb.append(\"### CPC SKETCH IMAGE - PREAMBLE:\").append(LS);\n  sb.append(\"Format                          : \").append(format.name()).append(LS);\n  sb.append(\"Byte 0: Preamble Ints           : \").append(preInts).append(LS);\n  sb.append(\"Byte 1: SerVer                  : \").append(serVer).append(LS);\n  sb.append(\"Byte 2: Family                  : \").append(family).append(LS);\n  sb.append(\"Byte 3: lgK                     : \").append(lgK).append(LS);\n  sb.append(\"Byte 4: First Interesting Col   : \").append(fiCol).append(LS);\n  sb.append(\"Byte 5: Flags                   : \").append(flagsStr).append(LS);\n  sb.append(\"  BIG_ENDIAN_STORAGE            : \").append(bigEndian).append(LS);\n  sb.append(\"  (Native Byte Order)           : \").append(nativeOrderStr).append(LS);\n  sb.append(\"  Compressed                    : \").append(compressed).append(LS);\n  sb.append(\"  Has HIP                       : \").append(hasHip).append(LS);\n  sb.append(\"  Has Surprising Values         : \").append(hasSV).append(LS);\n  sb.append(\"  Has Window Values             : \").append(hasWindow).append(LS);\n  sb.append(\"Byte 6, 7: Seed Hash            : \").append(seedHashStr).append(LS);\n  final Flavor flavor;\nswitch (format) {\ncase EMPTY_MERGED:\ncase EMPTY_HIP:\n{\n      flavor=CpcUtil.determineFlavor(lgK,numCoupons);\n      sb.append(\"Flavor                          : \").append(flavor).append(LS);\n      break;\n    }\ncase SPARSE_HYBRID_MERGED:\n{\n    numCoupons=mem.getInt(getHiFieldOffset(format,HiField.NUM_COUPONS)) & 0xFFFF_FFFFL;\n    numSv=numCoupons;\n    svLengthInts=mem.getInt(getHiFieldOffset(format,HiField.SV_LENGTH_INTS)) & 0xFFFF_FFFFL;\n    svStreamStart=getSvStreamOffset(mem);\n    reqBytes=svStreamStart + (svLengthInts << 2);\n    flavor=CpcUtil.determineFlavor(lgK,numCoupons);\n    sb.append(\"Flavor                          : \").append(flavor).append(LS);\n    sb.append(\"Num Coupons                     : \").append(numCoupons).append(LS);\n    sb.append(\"Num SV                          : \").append(numSv).append(LS);\n    sb.append(\"SV Length Ints                  : \").append(svLengthInts).append(LS);\n    sb.append(\"SV Stream Start                 : \").append(svStreamStart).append(LS);\n    break;\n  }\ncase SPARSE_HYBRID_HIP:\n{\n  numCoupons=mem.getInt(getHiFieldOffset(format,HiField.NUM_COUPONS)) & 0xFFFF_FFFFL;\n  numSv=numCoupons;\n  svLengthInts=mem.getInt(getHiFieldOffset(format,HiField.SV_LENGTH_INTS)) & 0xFFFF_FFFFL;\n  svStreamStart=getSvStreamOffset(mem);\n  kxp=mem.getDouble(getHiFieldOffset(format,HiField.KXP));\n  hipAccum=mem.getDouble(getHiFieldOffset(format,HiField.HIP_ACCUM));\n  reqBytes=svStreamStart + (svLengthInts << 2);\n  flavor=CpcUtil.determineFlavor(lgK,numCoupons);\n  sb.append(\"Flavor                          : \").append(flavor).append(LS);\n  sb.append(\"Num Coupons                     : \").append(numCoupons).append(LS);\n  sb.append(\"Num SV                          : \").append(numSv).append(LS);\n  sb.append(\"SV Length Ints                  : \").append(svLengthInts).append(LS);\n  sb.append(\"SV Stream Start                 : \").append(svStreamStart).append(LS);\n  sb.append(\"KxP                             : \").append(kxp).append(LS);\n  sb.append(\"HipAccum                        : \").append(hipAccum).append(LS);\n  break;\n}\ncase PINNED_SLIDING_MERGED_NOSV:\n{\nnumCoupons=mem.getInt(getHiFieldOffset(format,HiField.NUM_COUPONS)) & 0xFFFF_FFFFL;\nwinOffset=CpcUtil.determineCorrectOffset(lgK,numCoupons);\nwLengthInts=mem.getInt(getHiFieldOffset(format,HiField.W_LENGTH_INTS)) & 0xFFFF_FFFFL;\nwStreamStart=getWStreamOffset(mem);\nreqBytes=wStreamStart + (wLengthInts << 2);\nflavor=CpcUtil.determineFlavor(lgK,numCoupons);\nsb.append(\"Flavor                          : \").append(flavor).append(LS);\nsb.append(\"Num Coupons                     : \").append(numCoupons).append(LS);\nsb.append(\"Window Offset                   : \").append(winOffset).append(LS);\nsb.append(\"Window Length Ints              : \").append(wLengthInts).append(LS);\nsb.append(\"Window Stream Start             : \").append(wStreamStart).append(LS);\nbreak;\n}\ncase PINNED_SLIDING_HIP_NOSV:\n{\nnumCoupons=mem.getInt(getHiFieldOffset(format,HiField.NUM_COUPONS)) & 0xFFFF_FFFFL;\nwinOffset=CpcUtil.determineCorrectOffset(lgK,numCoupons);\nwLengthInts=mem.getInt(getHiFieldOffset(format,HiField.W_LENGTH_INTS)) & 0xFFFF_FFFFL;\nwStreamStart=getWStreamOffset(mem);\nkxp=mem.getDouble(getHiFieldOffset(format,HiField.KXP));\nhipAccum=mem.getDouble(getHiFieldOffset(format,HiField.HIP_ACCUM));\nreqBytes=wStreamStart + (wLengthInts << 2);\nflavor=CpcUtil.determineFlavor(lgK,numCoupons);\nsb.append(\"Flavor                          : \").append(flavor).append(LS);\nsb.append(\"Num Coupons                     : \").append(numCoupons).append(LS);\nsb.append(\"Window Offset                   : \").append(winOffset).append(LS);\nsb.append(\"Window Length Ints              : \").append(wLengthInts).append(LS);\nsb.append(\"Window Stream Start             : \").append(wStreamStart).append(LS);\nsb.append(\"KxP                             : \").append(kxp).append(LS);\nsb.append(\"HipAccum                        : \").append(hipAccum).append(LS);\nbreak;\n}\ncase PINNED_SLIDING_MERGED:\n{\nnumCoupons=mem.getInt(getHiFieldOffset(format,HiField.NUM_COUPONS) & 0xFFFF_FFFFL);\nwinOffset=CpcUtil.determineCorrectOffset(lgK,numCoupons);\nwLengthInts=mem.getInt(getHiFieldOffset(format,HiField.W_LENGTH_INTS)) & 0xFFFF_FFFFL;\nnumSv=mem.getInt(getHiFieldOffset(format,HiField.NUM_SV)) & 0xFFFF_FFFFL;\nsvLengthInts=mem.getInt(getHiFieldOffset(format,HiField.SV_LENGTH_INTS)) & 0xFFFF_FFFFL;\nwStreamStart=getWStreamOffset(mem);\nsvStreamStart=getSvStreamOffset(mem);\nreqBytes=svStreamStart + (svLengthInts << 2);\nflavor=CpcUtil.determineFlavor(lgK,numCoupons);\nsb.append(\"Flavor                          : \").append(flavor).append(LS);\nsb.append(\"Num Coupons                     : \").append(numCoupons).append(LS);\nsb.append(\"Num SV                          : \").append(numSv).append(LS);\nsb.append(\"SV Length Ints                  : \").append(svLengthInts).append(LS);\nsb.append(\"SV Stream Start                 : \").append(svStreamStart).append(LS);\nsb.append(\"Window Offset                   : \").append(winOffset).append(LS);\nsb.append(\"Window Length Ints              : \").append(wLengthInts).append(LS);\nsb.append(\"Window Stream Start             : \").append(wStreamStart).append(LS);\nbreak;\n}\ncase PINNED_SLIDING_HIP:\n{\nnumCoupons=mem.getInt(getHiFieldOffset(format,HiField.NUM_COUPONS) & 0xFFFF_FFFFL);\nwinOffset=CpcUtil.determineCorrectOffset(lgK,numCoupons);\nwLengthInts=mem.getInt(getHiFieldOffset(format,HiField.W_LENGTH_INTS)) & 0xFFFF_FFFFL;\nnumSv=mem.getInt(getHiFieldOffset(format,HiField.NUM_SV)) & 0xFFFF_FFFFL;\nsvLengthInts=mem.getInt(getHiFieldOffset(format,HiField.SV_LENGTH_INTS)) & 0xFFFF_FFFFL;\nwStreamStart=getWStreamOffset(mem);\nsvStreamStart=getSvStreamOffset(mem);\nkxp=mem.getDouble(getHiFieldOffset(format,HiField.KXP));\nhipAccum=mem.getDouble(getHiFieldOffset(format,HiField.HIP_ACCUM));\nreqBytes=svStreamStart + (svLengthInts << 2);\nflavor=CpcUtil.determineFlavor(lgK,numCoupons);\nsb.append(\"Flavor                          : \").append(flavor).append(LS);\nsb.append(\"Num Coupons                     : \").append(numCoupons).append(LS);\nsb.append(\"Num SV                          : \").append(numSv).append(LS);\nsb.append(\"SV Length Ints                  : \").append(svLengthInts).append(LS);\nsb.append(\"SV Stream Start                 : \").append(svStreamStart).append(LS);\nsb.append(\"Window Offset                   : \").append(winOffset).append(LS);\nsb.append(\"Window Length Ints              : \").append(wLengthInts).append(LS);\nsb.append(\"Window Stream Start             : \").append(wStreamStart).append(LS);\nsb.append(\"KxP                             : \").append(kxp).append(LS);\nsb.append(\"HipAccum                        : \").append(hipAccum).append(LS);\nbreak;\n}\n}\nsb.append(\"Actual Bytes                    : \").append(capBytes).append(LS);\nsb.append(\"Required Bytes                  : \").append(reqBytes).append(LS);\nif (detail) {\nsb.append(LS).append(\"### CPC SKETCH IMAGE - DATA\").append(LS);\nif (wLengthInts > 0) {\nsb.append(LS).append(\"Window Stream:\").append(LS);\nlistData(mem,wStreamStart,wLengthInts,sb);\n}\nif (svLengthInts > 0) {\nsb.append(LS).append(\"SV Stream:\").append(LS);\nlistData(mem,svStreamStart,svLengthInts,sb);\n}\n}\nsb.append(\"### END CPC SKETCH IMAGE\").append(LS);\nreturn sb.toString();\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/cpc/PreambleUtil.java",
        "Start": 22718,
        "Stop": 33920,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "toString"
    },
    {
        "Old_Method": "/** \n * This grows the levels arr by 1 (if needed) and increases the capacity of the items array at the bottom.  Only numLevels, the levels array and the items array are affected. This assumes sketch is writable and UPDATABLE.\n * @param sketch the current sketch\n */\nstatic void addEmptyTopLevelToCompletelyFullSketch(final KllSketch sketch){\n  final SketchType sketchType=sketch.sketchType;\n  final int[] myCurLevelsArr=sketch.getLevelsArray(sketch.sketchStructure);\n  final int myCurNumLevels=sketch.getNumLevels();\n  final int myCurTotalItemsCapacity=myCurLevelsArr[myCurNumLevels];\n  final int myNewNumLevels;\n  final int[] myNewLevelsArr;\n  final int myNewTotalItemsCapacity;\n  double[] myCurDoubleItemsArr=null;\n  double[] myNewDoubleItemsArr=null;\n  double minDouble=Double.NaN;\n  double maxDouble=Double.NaN;\n  float[] myCurFloatItemsArr=null;\n  float[] myNewFloatItemsArr=null;\n  float minFloat=Float.NaN;\n  float maxFloat=Float.NaN;\n  Object[] myCurItemsArr=null;\n  Object[] myNewItemsArr=null;\n  Object minItem=null;\n  Object maxItem=null;\n  if (sketchType == DOUBLES_SKETCH) {\n    final KllDoublesSketch dblSk=(KllDoublesSketch)sketch;\n    myCurDoubleItemsArr=dblSk.getDoubleItemsArray();\n    minDouble=dblSk.getMinItem();\n    maxDouble=dblSk.getMaxItem();\n    assert myCurDoubleItemsArr.length == myCurTotalItemsCapacity;\n  }\n else   if (sketchType == FLOATS_SKETCH) {\n    final KllFloatsSketch fltSk=(KllFloatsSketch)sketch;\n    myCurFloatItemsArr=fltSk.getFloatItemsArray();\n    minFloat=fltSk.getMinItem();\n    maxFloat=fltSk.getMaxItem();\n    assert myCurFloatItemsArr.length == myCurTotalItemsCapacity;\n  }\n else {\n    final KllItemsSketch<?> itmSk=(KllItemsSketch<?>)sketch;\n    myCurItemsArr=itmSk.getTotalItemsArray();\n    minItem=itmSk.getMinItem();\n    maxItem=itmSk.getMaxItem();\n  }\n  assert myCurLevelsArr[0] == 0;\n  final int deltaItemsCap=levelCapacity(sketch.getK(),myCurNumLevels + 1,0,sketch.getM());\n  myNewTotalItemsCapacity=myCurTotalItemsCapacity + deltaItemsCap;\n  final boolean growLevelsArr=myCurLevelsArr.length < myCurNumLevels + 2;\n  if (growLevelsArr) {\n    myNewLevelsArr=Arrays.copyOf(myCurLevelsArr,myCurNumLevels + 2);\n    assert myNewLevelsArr.length == myCurLevelsArr.length + 1;\n    myNewNumLevels=myCurNumLevels + 1;\n    sketch.incNumLevels();\n  }\n else {\n    myNewLevelsArr=myCurLevelsArr;\n    myNewNumLevels=myCurNumLevels;\n  }\n  for (int level=0; level <= myNewNumLevels - 1; level++) {\n    myNewLevelsArr[level]+=deltaItemsCap;\n  }\n  myNewLevelsArr[myNewNumLevels]=myNewTotalItemsCapacity;\n  if (sketchType == DOUBLES_SKETCH) {\n    myNewDoubleItemsArr=new double[myNewTotalItemsCapacity];\n    System.arraycopy(myCurDoubleItemsArr,0,myNewDoubleItemsArr,deltaItemsCap,myCurTotalItemsCapacity);\n  }\n else   if (sketchType == FLOATS_SKETCH) {\n    myNewFloatItemsArr=new float[myNewTotalItemsCapacity];\n    System.arraycopy(myCurFloatItemsArr,0,myNewFloatItemsArr,deltaItemsCap,myCurTotalItemsCapacity);\n  }\n else {\n    myNewItemsArr=new Object[myNewTotalItemsCapacity];\n    System.arraycopy(myCurItemsArr,0,myNewItemsArr,deltaItemsCap,myCurTotalItemsCapacity);\n  }\n  if (sketch.getWritableMemory() != null) {\n    final WritableMemory wmem=memorySpaceMgmt(sketch,myNewLevelsArr.length,myNewTotalItemsCapacity);\n    sketch.setWritableMemory(wmem);\n  }\n  sketch.setNumLevels(myNewNumLevels);\n  sketch.setLevelsArray(myNewLevelsArr);\n  if (sketchType == DOUBLES_SKETCH) {\n    final KllDoublesSketch dblSk=(KllDoublesSketch)sketch;\n    dblSk.setMinItem(minDouble);\n    dblSk.setMaxItem(maxDouble);\n    dblSk.setDoubleItemsArray(myNewDoubleItemsArr);\n  }\n else   if (sketchType == FLOATS_SKETCH) {\n    final KllFloatsSketch fltSk=(KllFloatsSketch)sketch;\n    fltSk.setMinItem(minFloat);\n    fltSk.setMaxItem(maxFloat);\n    fltSk.setFloatItemsArray(myNewFloatItemsArr);\n  }\n else {\n    final KllItemsSketch<?> itmSk=(KllItemsSketch<?>)sketch;\n    itmSk.setMinItem(minItem);\n    itmSk.setMaxItem(maxItem);\n    itmSk.setItemsArray(myNewItemsArr);\n  }\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/kll/KllHelper.java",
        "Start": 23832,
        "Stop": 29162,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "addEmptyTopLevelToCompletelyFullSketch"
    },
    {
        "Old_Method": "/** \n * The task here is to check the transition boundaries as the sketch morphs between LIST to SET to HLL modes. The transition points vary as a function of lgConfigK. In addition, this checks that the union operation is operating properly based on the order the sketches are presented to the union.\n */\n@Test public void checkUnions(){\n  int t1=2;\n  int t2=2;\n  int rt=2;\n  println(\"TgtR: \" + TgtHllType.values()[rt].toString());\n  int lgK1=7;\n  int lgK2=7;\n  int lgMaxK=7;\n  int n1=7;\n  int n2=7;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  n1=8;\n  n2=7;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  n1=7;\n  n2=8;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  n1=8;\n  n2=8;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  n1=7;\n  n2=14;\n  basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n  println(\"++END BASE GROUP++\");\n  int i=0;\n  for (i=7; i <= 13; i++) {\n    lgK1=i;\n    lgK2=i;\n    lgMaxK=i;\n{\n      n1=((1 << (i - 3)) * 3) / 4;\n      n2=n1;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1-=2;\n      n2+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    }\n    println(\"--END MINOR GROUP--\");\n    lgK1=i;\n    lgK2=i + 1;\n    lgMaxK=i;\n{\n      n1=((1 << (i - 3)) * 3) / 4;\n      n2=n1;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1-=2;\n      n2+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    }\n    println(\"--END MINOR GROUP--\");\n    lgK1=i + 1;\n    lgK2=i;\n    lgMaxK=i;\n{\n      n1=((1 << (i - 3)) * 3) / 4;\n      n2=n1;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1-=2;\n      n2+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    }\n    println(\"--END MINOR GROUP--\");\n    lgK1=i + 1;\n    lgK2=i + 1;\n    lgMaxK=i;\n{\n      n1=((1 << (i - 3)) * 3) / 4;\n      n2=n1;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1-=2;\n      n2+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n      n1+=2;\n      basicUnion(n1,n2,lgK1,lgK2,lgMaxK,t1,t2,rt);\n    }\n    println(\"++END MAJOR GROUP++\");\n  }\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/hll/UnionTest.java",
        "Start": 2061,
        "Stop": 5085,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkUnions"
    },
    {
        "Old_Method": "/** \n * Returns the A-and-not-B set operation on a Tuple sketch and a Theta sketch. <p>This a stateless operation and has no impact on the internal state of this operator. Thus, this is not an accumulating update and is independent of the  {@link #setA(Sketch)}, {@link #notB(Sketch)},  {@link #notB(org.apache.datasketches.theta.Sketch)}, and {@link #getResult(boolean)} methods.<\/p><p>If either argument is null an exception is thrown.<\/p> <p>Rationale: In mathematics a \"null set\" is a set with no members, which we call an empty set. That is distinctly different from the java <i>null<\/i>, which represents a nonexistent object. In most cases it is a programming error due to some object that was not properly initialized. With a null as the first argument, we cannot know what the user's intent is. With a null as the second argument, we can't ignore it as we must return a result and there is no following possible viable arguments for the second argument. Since it is very likely that a <i>null<\/i> is a programming error for either argument we throw a an exception.<\/p>\n * @param skA The incoming Tuple sketch for the first argument\n * @param skB The incoming Theta sketch for the second argument\n * @param < S > Type of Summary\n * @return the result as an unordered {@link CompactSketch}\n */\n@SuppressFBWarnings(value=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",justification=\"hashArr and summaryArr are guaranteed to be valid due to the switch on CornerCase\") public static <S extends Summary>CompactSketch<S> aNotB(final Sketch<S> skA,final org.apache.datasketches.theta.Sketch skB){\n  if (skA == null || skB == null) {\n    throw new SketchesArgumentException(\"Neither argument may be null for this stateless operation.\");\n  }\n  final long thetaLongA=skA.getThetaLong();\n  final int countA=skA.getRetainedEntries();\n  final boolean emptyA=skA.isEmpty();\n  final long thetaLongB=skB.getThetaLong();\n  final int countB=skB.getRetainedEntries();\n  final boolean emptyB=skB.isEmpty();\n  final int id=SetOperationCornerCases.createCornerCaseId(thetaLongA,countA,emptyA,thetaLongB,countB,emptyB);\n  final CornerCase cCase=CornerCase.caseIdToCornerCase(id);\n  final AnotbAction anotbAction=cCase.getAnotbAction();\n  CompactSketch<S> result=null;\nswitch (anotbAction) {\ncase EMPTY_1_0_T:\n{\n      result=new CompactSketch<>(null,null,Long.MAX_VALUE,true);\n      break;\n    }\ncase DEGEN_MIN_0_F:\n{\n    final long thetaLong=min(thetaLongA,thetaLongB);\n    result=new CompactSketch<>(null,null,thetaLong,false);\n    break;\n  }\ncase DEGEN_THA_0_F:\n{\n  result=new CompactSketch<>(null,null,thetaLongA,false);\n  break;\n}\ncase TRIM_A:\n{\nfinal DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\nfinal long[] hashArrA=daA.hashArr;\nfinal S[] summaryArrA=daA.summaryArr;\nfinal long minThetaLong=min(thetaLongA,thetaLongB);\nfinal DataArrays<S> da=trimAndCopyDataArrays(hashArrA,summaryArrA,minThetaLong,false);\nresult=new CompactSketch<>(da.hashArr,da.summaryArr,minThetaLong,skA.empty_);\nbreak;\n}\ncase SKETCH_A:\n{\nfinal DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\nresult=new CompactSketch<>(daA.hashArr,daA.summaryArr,thetaLongA,skA.empty_);\nbreak;\n}\ncase FULL_ANOTB:\n{\nfinal DataArrays<S> daA=getCopyOfDataArraysTuple(skA);\nfinal long minThetaLong=min(thetaLongA,thetaLongB);\n@SuppressFBWarnings(value=\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",justification=\"hashArr and summaryArr are guaranteed to be valid due to the switch on CornerCase\") final DataArrays<S> daR=getCopyOfResultArraysTheta(minThetaLong,daA.hashArr.length,daA.hashArr,daA.summaryArr,skB);\nfinal int countR=(daR.hashArr == null) ? 0 : daR.hashArr.length;\nif (countR == 0) {\nresult=new CompactSketch<>(null,null,minThetaLong,minThetaLong == Long.MAX_VALUE);\n}\n else {\nresult=new CompactSketch<>(daR.hashArr,daR.summaryArr,minThetaLong,false);\n}\n}\n}\nreturn result;\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/tuple/AnotB.java",
        "Start": 15811,
        "Stop": 20259,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "aNotB"
    },
    {
        "Old_Method": "static void packBits58(final long[] values,final int i,final byte[] buf,int off){\n  buf[off++]=(byte)(values[i + 0] >>> 50);\n  buf[off++]=(byte)(values[i + 0] >>> 42);\n  buf[off++]=(byte)(values[i + 0] >>> 34);\n  buf[off++]=(byte)(values[i + 0] >>> 26);\n  buf[off++]=(byte)(values[i + 0] >>> 18);\n  buf[off++]=(byte)(values[i + 0] >>> 10);\n  buf[off++]=(byte)(values[i + 0] >>> 2);\n  buf[off]=(byte)(values[i + 0] << 6);\n  buf[off++]|=values[i + 1] >>> 52;\n  buf[off++]=(byte)(values[i + 1] >>> 44);\n  buf[off++]=(byte)(values[i + 1] >>> 36);\n  buf[off++]=(byte)(values[i + 1] >>> 28);\n  buf[off++]=(byte)(values[i + 1] >>> 20);\n  buf[off++]=(byte)(values[i + 1] >>> 12);\n  buf[off++]=(byte)(values[i + 1] >>> 4);\n  buf[off]=(byte)(values[i + 1] << 4);\n  buf[off++]|=values[i + 2] >>> 54;\n  buf[off++]=(byte)(values[i + 2] >>> 46);\n  buf[off++]=(byte)(values[i + 2] >>> 38);\n  buf[off++]=(byte)(values[i + 2] >>> 30);\n  buf[off++]=(byte)(values[i + 2] >>> 22);\n  buf[off++]=(byte)(values[i + 2] >>> 14);\n  buf[off++]=(byte)(values[i + 2] >>> 6);\n  buf[off]=(byte)(values[i + 2] << 2);\n  buf[off++]|=values[i + 3] >>> 56;\n  buf[off++]=(byte)(values[i + 3] >>> 48);\n  buf[off++]=(byte)(values[i + 3] >>> 40);\n  buf[off++]=(byte)(values[i + 3] >>> 32);\n  buf[off++]=(byte)(values[i + 3] >>> 24);\n  buf[off++]=(byte)(values[i + 3] >>> 16);\n  buf[off++]=(byte)(values[i + 3] >>> 8);\n  buf[off++]=(byte)(values[i + 3]);\n  buf[off++]=(byte)(values[i + 4] >>> 50);\n  buf[off++]=(byte)(values[i + 4] >>> 42);\n  buf[off++]=(byte)(values[i + 4] >>> 34);\n  buf[off++]=(byte)(values[i + 4] >>> 26);\n  buf[off++]=(byte)(values[i + 4] >>> 18);\n  buf[off++]=(byte)(values[i + 4] >>> 10);\n  buf[off++]=(byte)(values[i + 4] >>> 2);\n  buf[off]=(byte)(values[i + 4] << 6);\n  buf[off++]|=values[i + 5] >>> 52;\n  buf[off++]=(byte)(values[i + 5] >>> 44);\n  buf[off++]=(byte)(values[i + 5] >>> 36);\n  buf[off++]=(byte)(values[i + 5] >>> 28);\n  buf[off++]=(byte)(values[i + 5] >>> 20);\n  buf[off++]=(byte)(values[i + 5] >>> 12);\n  buf[off++]=(byte)(values[i + 5] >>> 4);\n  buf[off]=(byte)(values[i + 5] << 4);\n  buf[off++]|=values[i + 6] >>> 54;\n  buf[off++]=(byte)(values[i + 6] >>> 46);\n  buf[off++]=(byte)(values[i + 6] >>> 38);\n  buf[off++]=(byte)(values[i + 6] >>> 30);\n  buf[off++]=(byte)(values[i + 6] >>> 22);\n  buf[off++]=(byte)(values[i + 6] >>> 14);\n  buf[off++]=(byte)(values[i + 6] >>> 6);\n  buf[off]=(byte)(values[i + 6] << 2);\n  buf[off++]|=values[i + 7] >>> 56;\n  buf[off++]=(byte)(values[i + 7] >>> 48);\n  buf[off++]=(byte)(values[i + 7] >>> 40);\n  buf[off++]=(byte)(values[i + 7] >>> 32);\n  buf[off++]=(byte)(values[i + 7] >>> 24);\n  buf[off++]=(byte)(values[i + 7] >>> 16);\n  buf[off++]=(byte)(values[i + 7] >>> 8);\n  buf[off]=(byte)(values[i + 7]);\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/theta/BitPacking.java",
        "Start": 105006,
        "Stop": 108078,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "packBits58"
    },
    {
        "Old_Method": "@Test public void checkMemDeSerExceptions(){\n  int k=1024;\n  UpdateSketch sk1=UpdateSketch.builder().setFamily(ALPHA).setNominalEntries(k).build();\n  sk1.update(1L);\n  byte[] bytearray1=sk1.toByteArray();\n  WritableMemory mem=WritableMemory.writableWrap(bytearray1);\n  long pre0=mem.getLong(0);\n  tryBadMem(mem,PREAMBLE_LONGS_BYTE,2);\n  mem.putLong(0,pre0);\n  tryBadMem(mem,SER_VER_BYTE,2);\n  mem.putLong(0,pre0);\n  tryBadMem(mem,FAMILY_BYTE,2);\n  mem.putLong(0,pre0);\n  tryBadMem(mem,FLAGS_BYTE,2);\n  mem.putLong(0,pre0);\n  final long origThetaLong=mem.getLong(THETA_LONG);\n  try {\n    mem.putLong(THETA_LONG,Long.MAX_VALUE / 2);\n    HeapAlphaSketch.heapifyInstance(mem,ThetaUtil.DEFAULT_UPDATE_SEED);\n    fail();\n  }\n catch (  SketchesArgumentException e) {\n  }\n  mem.putLong(THETA_LONG,origThetaLong);\n  byte[] byteArray2=new byte[bytearray1.length - 1];\n  WritableMemory mem2=WritableMemory.writableWrap(byteArray2);\n  mem.copyTo(0,mem2,0,mem2.getCapacity());\n  try {\n    HeapAlphaSketch.heapifyInstance(mem2,ThetaUtil.DEFAULT_UPDATE_SEED);\n    fail();\n  }\n catch (  SketchesArgumentException e) {\n  }\n  insertLgResizeFactor(mem,ResizeFactor.X1.lg());\n  UpdateSketch usk=HeapAlphaSketch.heapifyInstance(mem,ThetaUtil.DEFAULT_UPDATE_SEED);\n  ResizeFactor rf=usk.getResizeFactor();\n  assertEquals(rf,ResizeFactor.X2);\n}\n",
        "File_Path": "datasketches-java/src/test/java/org/apache/datasketches/theta/HeapAlphaSketchTest.java",
        "Start": 19344,
        "Stop": 21113,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "checkMemDeSerExceptions"
    },
    {
        "Old_Method": "private static String getDataDetail(final DoublesSketch sketchIn){\n  final DoublesSketch sketch=sketchIn.isCompact() ? copyToHeap(sketchIn) : sketchIn;\n  final StringBuilder sb=new StringBuilder();\n  final String skName=sketch.getClass().getSimpleName();\n  sb.append(LS).append(\"### Quantiles \").append(skName).append(\" DATA DETAIL: \").append(LS);\n  final int k=sketch.getK();\n  final long n=sketch.getN();\n  final int bbCount=sketch.getBaseBufferCount();\n  final long bitPattern=sketch.getBitPattern();\n  final double[] combBuf=sketch.getCombinedBuffer();\n  sb.append(\"   BaseBuffer   : \");\n  for (int i=0; i < bbCount; i++) {\n    sb.append(String.format(\"%10.1f\",combBuf[i]));\n  }\n  sb.append(LS);\n  final int combBufSize=combBuf.length;\n  if (n >= (2 * k)) {\n    sb.append(\"   Valid | Level\");\n    for (int j=2 * k; j < combBufSize; j++) {\n      if ((j % k) == 0) {\n        final int levelNum=(j / k) - 2;\n        final String validLvl=((1L << levelNum) & bitPattern) > 0 ? \"    T  \" : \"    F  \";\n        final String lvl=String.format(\"%5d\",levelNum);\n        sb.append(LS).append(\"   \").append(validLvl).append(\" \").append(lvl).append(\": \");\n      }\n      sb.append(String.format(\"%10.1f\",combBuf[j]));\n    }\n    sb.append(LS);\n  }\n  sb.append(\"### END DATA DETAIL\").append(LS);\n  return sb.toString();\n}\n",
        "File_Path": "datasketches-java/src/main/java/org/apache/datasketches/quantiles/DoublesUtil.java",
        "Start": 7871,
        "Stop": 9398,
        "Project_Name": "data/projects/datasketches-java",
        "Method_Name": "getDataDetail"
    }
]